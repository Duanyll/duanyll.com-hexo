---
title: 算法分析与复杂度理论 - 作业 5
tags:
  - 题解
  - 算法分析
hidden: true
---

![提交记录](https://img.duanyll.com/img/cc1d57cd.png)

## 5. 最长回文子串

{% link https://leetcode.cn/problems/longest-palindromic-substring/ %}

这不是 Manacher 算法吗？

```cpp
class Solution {
   public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n == 0) return "";
        // 插入分隔符
        std::vector<char> t(2 * n + 1, '#');
        for (int i = 0; i < n; ++i) {
            t[2 * i + 1] = s[i];
        }
        int m = t.size();
        std::vector<int> p(m, 0);
        int center = 0, right = 0;
        for (int i = 0; i < m; ++i) {
            if (i < right) {
                p[i] = std::min(right - i, p[2 * center - i]);
            }
            // 尝试扩展回文半径
            while (i - p[i] - 1 >= 0 && i + p[i] + 1 < m && t[i - p[i] - 1] == t[i + p[i] + 1]) {
                p[i]++;
            }
            // 更新中心和右边界
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }
        }
        // 找到最大回文子串
        int maxLen = 0, maxCenter = 0;
        for (int i = 0; i < m; ++i) {
            if (p[i] > maxLen) {
                maxLen = p[i];
                maxCenter = i;
            }
        }
        // 提取原始字符串中的回文子串
        return s.substr((maxCenter - maxLen) / 2, maxLen);
    }
};
```

要理解 Manacher 算法，首先考虑非常显然的 $O(n^2)$ 解法：对于每个位置 $i$，向两边扩展回文子串，直到不相等为止。同时为了方便处理，我们在每个字符之间插入一个特殊字符 `#` 作为分隔符，这样可以统一处理奇数长度和偶数长度的回文子串。

```cpp
class Solution {
   public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n == 0) return "";
        // 插入分隔符
        std::vector<char> t(2 * n + 1, '#');
        for (int i = 0; i < n; ++i) {
            t[2 * i + 1] = s[i];
        }
        int m = t.size();
        std::vector<int> p(m, 0);
        for (int i = 0; i < m; ++i) {
            // 向两边扩展回文半径
            while (i - p[i] - 1 >= 0 && i + p[i] + 1 < m && t[i - p[i] - 1] == t[i + p[i] + 1]) {
                p[i]++;
            }
        }
        // 找到最大回文子串
        int maxLen = 0, maxCenter = 0;
        for (int i = 0; i < m; ++i) {
            if (p[i] > maxLen) {
                maxLen = p[i];
                maxCenter = i;
            }
        }
        // 提取原始字符串中的回文子串
        return s.substr((maxCenter - maxLen) / 2, maxLen);
    }
};
```

我们离 $O(1)$ 的解法只有一步之遥了。Manacher 算法的 Insight 在于：假如我们已经在位置 `center` 处找到了一个回文子串，并且它的右边界是 `right`，那么考虑 `center` 和 `right` 之间的某个位置 `i` 作为对称中心，那么 `i` 关于 `center` 的对称位置 `j = 2 * center - i` 处的回文子串的信息可以帮助我们快速确定 `i` 处的回文半径 `p[i]` 至少有 `min(p[j], right - i)` 大。这样我们就不需要从头开始扩展 `p[i]` 了。

进一步我们发现 `right` 会随着 `i` 的移动不断增大，因此每个位置最多只会被扩展一次，从而达到了线性时间复杂度。

## 64. 最小路径和

{% link https://leetcode.cn/problems/minimum-path-sum/ %}

过于显然的网格 DP。

```cpp
class Solution {
    int dp[201][201];
   public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        memset(dp, 0x3f, sizeof(dp));
        dp[0][0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + grid[i][j]);
                }
                if (j > 0) {
                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + grid[i][j]);
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

注：此处使用了静态分配的二维数组，相比于

```cpp
vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
```

可以偷一些分配上的常数。实际上也可以 Inplace 修改 `grid` 来节省空间。

## 120. 三角形最小路径和

{% link https://leetcode.cn/problems/triangle/ %}

同样是非常显然的网格 DP，不过这次是三角形。既然题面上已经明示了不做任何额外的分配，我们就直接 Inplace 修改 `triangle` 吧。

```cpp
class Solution {
   public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                if (j == 0) {
                    triangle[i][j] += triangle[i - 1][j];
                } else if (j == i) {
                    triangle[i][j] += triangle[i - 1][j - 1];
                } else {
                    triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j]);
                }
            }
        }
        int ans = 0x3f3f3f3f;
        for (int j = 0; j < n; j++) {
            ans = min(ans, triangle[n - 1][j]);
        }
        return ans;
    }
};
```