---
title: 算法分析与复杂度理论 - 作业 3
tags:
  - 题解
  - 算法分析
hidden: true
---

![提交记录](https://img.duanyll.com/img/c21758a3.png)

## 16. 最接近的三数之和

{% link https://leetcode.cn/problems/3sum-closest/ %}

首先 $n\leq 1000$ 意味着 $O(n^3)$ 的暴力是可以过的。

处理三个数没有太好的方法，所以先枚举第一个数 $a_i$，这样转换成找两个数之和最接近 $\text{target}-a_i$ 的问题。

```cpp
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        std::sort(nums.begin(), nums.end());
        int n = nums.size();
        int ans = nums[n - 1] + nums[n - 2] + nums[n - 3];
        for (int i = 0; i < n - 2; i++) {
            int l = i + 1;
            int r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum == target) return sum;
                if (std::abs(sum - target) < std::abs(ans - target)) {
                    ans = sum;
                }
                if (sum < target) {
                    l++;
                } else {
                    r--;
                }
            }
        }
        return ans;
    }
};
```

容易证明此方法的时间复杂度是 $O(n^2)$。为什么排序后，`sum < target` 时 `l++` 是正确的？因为对于当前的 `r` 来说，比 `l` 更小的数只会让 `sum` 变得更小，离得更远，因此对当前的 `r` 是更不优秀的，而将来 `r` 也只会变小，因此只能选择增大 `l` 来让 `sum` 变大，而增大 `r` 的情况之前已经考虑过了。另一侧的情况是同理的。

## 17. 电话号码的字母组合

{% link https://leetcode.cn/problems/letter-combinations-of-a-phone-number/ %}

我知道出题人是想考察递归回溯，但这个 $n$ 给的实在是太小了，很难让人忍住不偷点常数。既然都要节约常数了，为什么不直接用 C 再节约一点分配上的开销呢？

```c
#include <stdlib.h>
#include <string.h>

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char** letterCombinations(char* digits, int* returnSize) {
    const int len = strlen(digits);

    if (len == 0) {
        *returnSize = 0;
        return NULL;
    }

    const char* map[] = {
        "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
    };
    const int len_map[] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};

    int totalCombinations = 1;
    for (int i = 0; i < len; ++i) {
        totalCombinations *= len_map[digits[i] - '0'];
    }
    *returnSize = totalCombinations;

    char** result = (char**)malloc(totalCombinations * sizeof(char*) + totalCombinations * (len + 1) * sizeof(char));
    if (result == NULL) {
        *returnSize = 0;
        return NULL;
    }

    char* string_buffer = (char*)(result + totalCombinations);
    for (int i = 0; i < totalCombinations; ++i) {
        result[i] = string_buffer + i * (len + 1);
        result[i][len] = '\0';
    }

    int k = 0;
    switch (len) {
        case 4: {
            const char* s0 = map[digits[0] - '0']; const int l0 = len_map[digits[0] - '0'];
            const char* s1 = map[digits[1] - '0']; const int l1 = len_map[digits[1] - '0'];
            const char* s2 = map[digits[2] - '0']; const int l2 = len_map[digits[2] - '0'];
            const char* s3 = map[digits[3] - '0']; const int l3 = len_map[digits[3] - '0'];
            for (int i = 0; i < l0; ++i) {
                for (int j = 0; j < l1; ++j) {
                    for (int l = 0; l < l2; ++l) {
                        for (int m = 0; m < l3; ++m) {
                            result[k][0] = s0[i];
                            result[k][1] = s1[j];
                            result[k][2] = s2[l];
                            result[k][3] = s3[m];
                            k++;
                        }
                    }
                }
            }
            break;
        }
        case 3: {
            const char* s0 = map[digits[0] - '0']; const int l0 = len_map[digits[0] - '0'];
            const char* s1 = map[digits[1] - '0']; const int l1 = len_map[digits[1] - '0'];
            const char* s2 = map[digits[2] - '0']; const int l2 = len_map[digits[2] - '0'];
            for (int i = 0; i < l0; ++i) {
                for (int j = 0; j < l1; ++j) {
                    for (int l = 0; l < l2; ++l) {
                        result[k][0] = s0[i];
                        result[k][1] = s1[j];
                        result[k][2] = s2[l];
                        k++;
                    }
                }
            }
            break;
        }
        case 2: {
            const char* s0 = map[digits[0] - '0']; const int l0 = len_map[digits[0] - '0'];
            const char* s1 = map[digits[1] - '0']; const int l1 = len_map[digits[1] - '0'];
            for (int i = 0; i < l0; ++i) {
                for (int j = 0; j < l1; ++j) {
                    result[k][0] = s0[i];
                    result[k][1] = s1[j];
                    k++;
                }
            }
            break;
        }
        case 1: {
            const char* s0 = map[digits[0] - '0']; const int l0 = len_map[digits[0] - '0'];
            for (int i = 0; i < l0; ++i) {
                result[k][0] = s0[i];
                k++;
            }
            break;
        }
    }

    return result;
}
```

## 19. 删除链表的倒数第 N 个结点

{% link https://leetcode.cn/problems/remove-nth-node-from-end-of-list/ %}

这个题的 `sz` 给的太小了，很难忍住不写偷懒的做法。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    ListNode* nodes[50];
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* cur = head;
        int sz = 0;
        while (cur != nullptr) {
            nodes[sz++] = cur;
            cur = cur->next;
        }
        nodes[sz] = nullptr;
        int pos = sz - n - 1;
        if (pos == -1) {
            return nodes[1];
        } else {
            nodes[pos]->next = nodes[pos + 2];
            return head;
        }
    }
};
```

如果用真的链表操作来写，很重要的防止错误的技巧是操作前先把附近的节点都存进变量里，再来操作指针，尽量直接引用变量，而不要访问指针的指针。完成所有赋值后，再释放不需要的节点。

现实生活中链表的应用场景已经很少了，几乎每个场景都会有更好的（更方便的，标准库自带的，内存碎片更少的）数据结构来替代链表。