---
title: 算法分析与复杂度理论 - 作业 6
tags:
  - 题解
  - 算法分析
hidden: true
---

## 背包问题 (Knapsack Problem)

> 一个旅行者随身携带一个背包，可以放入背包的物品有 $n$ 种，每种物品的重量和价值分别是 $w_i, v_i, i = 1, \dots, n$。如果背包的最大容量限制是 $b$，怎样选择放入背包的物品以使得背包的价值最大？

经典 0-1 背包问题可以用动态规划来解决。定义状态 $dp[i][j]$ 表示前 $i$ 种物品在背包容量为 $j$ 时的最大价值。状态转移方程如下：

$$
dp[i][j] = \begin{cases}
  dp[i-1][j] & j < w_i \\
  \max(dp[i-1][j], dp[i-1][j - w_i] + v_i) & j \geq w_i
\end{cases}
$$

注意到可以使用滚动数组优化：

$$
dp_{new}[j] = \max(dp_{old}[j], dp_{old}[j-w] + v)
$$

```haskell
knapsack :: Int -> [(Int, Int)] -> Int
knapsack b items = last (foldl updateState (replicate (b + 1) 0) items)
  where
    updateState dp (w, v) =
      zipWith max dp (replicate w 0 ++ map (+v) dp)
```

- 第一行定义了 `knapsack` 函数，接受 Int 背包容量 `b`，和一个包含物品重量和价值的元组列表 `items`，返回最大价值。
- 第二行：`dp` 数组从 `b + 1` 个 0 开始，用每个物品依次去更新状态 (`foldl updateState ... items`)，取最后一个元素作为结果 (`last ...`)。
  - `updateState` 函数接受当前的 `dp` 数组和一个物品 `(w, v)`，返回更新后的 `dp` 数组。
    - `zipWith max dp ...`：对每个容量 `j`，计算不放入当前物品和放入当前物品的最大值。
      - `++` 拼接两个数组
      - `replicate w 0`：前 `w` 个容量不能放入当前物品，价值为 0，垫 `w` 个 0。
      - `map (+v) dp`：对于容量 `j >= w`，放入当前物品后，价值为 `dp[j - w] + v`。
    - `dp` 和垫了 `w` 个 0 的数组长度不一致，但 `zipWith` 会自动截断到较短的长度，实现背包容量的限制。

总的复杂度是 $O(n \times b)$，其中 $n$ 是物品数量，$b$ 是背包容量。

## 投资问题

> 设有 $m$ 元钱，$n$ 项投资，函数 $f_i(x)$ 表示将 $x$ 元钱投入到第 $i$ 项项目所产生的效益，$i = 1, \dots, n$。问：如何分配这 $m$ 元钱，使得投资的总效益最高？

分组背包问题。定义状态 $dp[i][j]$ 表示前 $i$ 项投资在总资金为 $j$ 时的最大效益。状态转移方程如下：

$$
dp[i][j] = \max_{0 \le k \le j} \{ f_i(k) + dp[i-1][j-k] \}
$$

实际上是两个序列的 Max 和加法运算卷积。

```haskell
maximizeProfit :: Int -> [Int -> Int] -> Int
maximizeProfit m funcs = last (foldl updateState (replicate (m + 1) 0) funcs)
  where
    updateState :: [Int] -> (Int -> Int) -> [Int]
    updateState prevDp f = 
      let 
        currentProfits = map f [0..m]
      in
        [ convolution j currentProfits prevDp | j <- [0..m] ]

    convolution :: Int -> [Int] -> [Int] -> Int
    convolution j profits prev = 
      let 
        ps = take (j + 1) profits
        qs = reverse (take (j + 1) prev)
      in 
        maximum (zipWith (+) ps qs)
```

- `maximizeProfit` 函数接受总资金 `m` 和一个函数列表 `funcs`，返回最大效益。
- `dp` 数组从 `m + 1` 个 0 开始，用每个投资函数依次去更新状态 (`foldl updateState ... funcs`)，取最后一个元素作为结果 (`last ...`)。
  - `updateState` 函数接受前一个状态的 `dp` 数组和当前投资函数 `f`，返回更新后的 `dp` 数组。
    - `currentProfits` 计算当前投资函数在所有可能资金分配下的效益。
    - 对于每个总资金 `j`，计算卷积结果，得到新的最大效益。
  - `convolution` 函数计算两个序列在位置 `j` 的卷积结果。
    - `ps` 是当前投资函数在资金 `0` 到 `j` 下的效益。
    - `qs` 是前一个状态的 `dp` 数组的反转，表示剩余资金的最大效益。
    - 使用 `zipWith (+)` 对应位置相加，取最大值作为卷积结果。
    - 反转之后，效果就是 `max(f(0)+dp(j), f(1)+dp(j-1), ...)`

复杂度是 $O(n \times m^2)$，其中 $n$ 是投资项目数量，$m$ 是总资金。

## 235. 二叉搜索树的最近公共祖先

{% link https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/ %}

$O(\log n)$ 查询的倍增算法已经呼之欲出了，但这个题只有一次查询呐。所以直接 $O(n)$ 扫一遍就可以了。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
   public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return nullptr;
        }
        if (root == p || root == q) {
            return root;
        }
        auto left_val = lowestCommonAncestor(root->left, p, q);
        auto right_val = lowestCommonAncestor(root->right, p, q);
        if (left_val != nullptr && right_val != nullptr) {
            return root;
        }
        return left_val != nullptr ? left_val : right_val;
    }
};
```

![](https://img.duanyll.com/img/406c004a.png)

思路就是递归地在左右子树中寻找 $p$ 和 $q$。如果当前节点是 $p$ 或 $q$，就返回当前节点。如果在左子树和右子树中都找到了非空结果，说明当前节点就是最近公共祖先，返回当前节点。否则返回非空的那个结果。不过这个搞法没有用到 BST 的性质，用上 BST 的 `val` 的有序性还能再剪一点枝

```cpp
class Solution {
   public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) {
            return nullptr;
        }
        if (p->val < root->val && q->val < root->val) {
            return lowestCommonAncestor(root->left, p, q);
        }
        if (p->val > root->val && q->val > root->val) {
            return lowestCommonAncestor(root->right, p, q);
        }
        return root;
    }
};
```

![](https://img.duanyll.com/img/83df03f1.png)

利用 `val` 的有序性，如果 $p$ 和 $q$ 都小于当前节点，就去左子树找；如果都大于当前节点，就去右子树找。否则当前节点就是最近公共祖先。

但是还能再凹一点常数？试试交换一下两个 `if` 语句的位置，并展开递归：

```cpp
class Solution {
   public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while (root != nullptr) {
            if (p->val > root->val && q->val > root->val) {
                root = root->right;
            } else if (p->val < root->val && q->val < root->val) {
                root = root->left;
            } else {
                return root;
            }
        }
        return nullptr;
    }
};
```

![](https://img.duanyll.com/img/9a8d6afd.png)

> 可能是评测机波动吧。

## 110. 平衡二叉树

{% link https://leetcode.cn/problems/balanced-binary-tree/ %}

反正就是 dfs 扫一遍呗。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int dfs(TreeNode* node) {
        if (node == nullptr) {
            return 0;
        }
        int left_height = dfs(node->left);
        if (left_height == -1) {
            return -1;
        }
        int right_height = dfs(node->right);
        if (right_height == -1) {
            return -1;
        }
        if (left_height - right_height > 1 || right_height - left_height > 1) {
            return -1;
        }
        return std::max(left_height, right_height) + 1;
    }
   public:
    bool isBalanced(TreeNode* root) {
        return dfs(root) != -1;
    }
};
```

![](https://img.duanyll.com/img/a117b62e.png)

## 257. 二叉树的所有路径

{% link https://leetcode.cn/problems/binary-tree-paths/ %}

就 dfs 扫一遍呗。随手写一个看看常数怎样。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 class Solution {
    void dfs(TreeNode* node, std::string path, std::vector<std::string>& result) {
        if (node == nullptr) {
            return;
        }
        path += std::to_string(node->val);
        if (node->left == nullptr && node->right == nullptr) {
            result.push_back(path);
            return;
        }
        path += "->";
        dfs(node->left, path, result);
        dfs(node->right, path, result);
    }
   public:
    std::vector<std::string> binaryTreePaths(TreeNode* root) {
        std::vector<std::string> result;
        dfs(root, "", result);
        return result;
    }
};
```

![](https://img.duanyll.com/img/3beea359.png)

那确实不怎么样。考虑开一个 C 字符串缓冲区，自己手工在每次递归时写入数字和箭头，在叶子结点处一次性构造 `std::string` 对象。

```cpp
class Solution {
    char buffer[1000];
    std::vector<std::string> result;
    void printInt(int val, int& pos) {
        if (val < 0) {
            buffer[pos++] = '-';
            val = -val;
        }
        if (val > 9) {
            printInt(val / 10, pos);
        }
        buffer[pos++] = '0' + (val % 10);
    }

    void dfs(TreeNode* node, int pos) {
        if (node == nullptr) {
            return;
        }
        printInt(node->val, pos);
        if (node->left == nullptr && node->right == nullptr) {
            buffer[pos] = '\0';
            result.emplace_back(buffer);
            return;
        }
        buffer[pos++] = '-';
        buffer[pos++] = '>';
        dfs(node->left, pos);
        dfs(node->right, pos);
    }
   public:
    std::vector<std::string> binaryTreePaths(TreeNode* root) {
        dfs(root, 0);
        return result;
    }
};
```

![](https://img.duanyll.com/img/8840e744.png)

> 开摆，可能今天评测机状态不好吧。