---
title: 数字媒体技术基础 - 作业 2
tags:
  - 数字媒体
hidden: true
---

![作业题目](https://img.duanyll.com/img/ede821a2.png)

## 构建 ITM 15.0 编码器

为了方便构建 ITM 15.0 编码器，给项目添加了一个简单的 CMake 构建脚本 `CMakeLists.txt`，可以直接使用 CMake 进行构建。

```cmake
cmake_minimum_required(VERSION 3.16)

project(ITM15 LANGUAGES C)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

option(BUILD_LENCOD "Build the AVS encoder" ON)
option(BUILD_LDECOD "Build the AVS decoder" ON)

find_library(MATH_LIBRARY m)
if(MATH_LIBRARY)
  set(ITM15_EXTRA_LIBS ${MATH_LIBRARY})
else()
  set(ITM15_EXTRA_LIBS "")
endif()
set(ITM15_EXTRA_LIBS "${ITM15_EXTRA_LIBS}" CACHE INTERNAL "Extra libraries shared by ITM15 targets")

if(BUILD_LENCOD)
  add_subdirectory(lencod)
endif()

if(BUILD_LDECOD)
  add_subdirectory(ldecod)
endif()
```

`lencod` 目录下的 `CMakeLists.txt` 内容如下：

```cmake
set(LDECOD_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src)

file(GLOB_RECURSE LDECOD_SOURCES CONFIGURE_DEPENDS
  "${LDECOD_SOURCE_DIR}/*.c"
)

add_executable(ldecod ${LDECOD_SOURCES})

set_target_properties(ldecod PROPERTIES
  C_STANDARD 99
  C_STANDARD_REQUIRED YES
)

target_include_directories(ldecod
  PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/inc
    ${CMAKE_CURRENT_SOURCE_DIR}/src/x86
)

target_compile_definitions(ldecod
  PRIVATE
    $<$<C_COMPILER_ID:MSVC>:_CRT_SECURE_NO_WARNINGS>
)

target_compile_options(ldecod
  PRIVATE
    $<$<C_COMPILER_ID:MSVC>:/W3 /MP>
    $<$<OR:$<C_COMPILER_ID:GNU>,$<C_COMPILER_ID:Clang>>:-Wall -ffloat-store>
)

if(ITM15_EXTRA_LIBS)
  target_link_libraries(ldecod PRIVATE ${ITM15_EXTRA_LIBS})
endif()
```

`lencod` 目录下的 `CMakeLists.txt` 内容如下：

```cmake
set(LENCOD_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src)

file(GLOB_RECURSE LENCOD_SOURCES CONFIGURE_DEPENDS
  "${LENCOD_SOURCE_DIR}/*.c"
)

add_executable(lencod ${LENCOD_SOURCES})

set_target_properties(lencod PROPERTIES
  C_STANDARD 99
  C_STANDARD_REQUIRED YES
)

target_include_directories(lencod
  PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/inc
    ${CMAKE_CURRENT_SOURCE_DIR}/src/x86
)

target_compile_definitions(lencod
  PRIVATE
    $<$<C_COMPILER_ID:MSVC>:_CRT_SECURE_NO_WARNINGS>
)

target_compile_options(lencod
  PRIVATE
    $<$<C_COMPILER_ID:MSVC>:/W3 /MP>
    $<$<OR:$<C_COMPILER_ID:GNU>,$<C_COMPILER_ID:Clang>>:-Wall -ffloat-store>
)

if(ITM15_EXTRA_LIBS)
  target_link_libraries(lencod PRIVATE ${ITM15_EXTRA_LIBS})
endif()
```

同时移除 `lencod/src/x86/intrinsics.h` 文件中对宏定义的注释以便使用 SSE 指令集。

使用 CMake 编译项目：

```sh
cmake -S . -B build -G Ninja -DCMAKE_BUILD_TYPE=Release
cmake --build build
```

编译完成后，`build/bin` 目录下会生成 `lencod` 和 `ldecod` 可执行文件。

## 验证编解码器的正确性

下载 QCIF 分辨率的 foreman 视频文件并转换为 YUV 4:2:0 格式：

```sh
wget https://media.xiph.org/video/derf/y4m/foreman_qcif.y4m
ffmpeg -i foreman_qcif.y4m -c:v rawvideo -pix_fmt yuv420p workspace/foreman_qcif.yuv
```

使用示例中的 `encoder_ra.cfg` 配置文件对视频进行编码：

```
InputFile              = "./workspace/foreman_qcif.yuv"			# Input sequence, YUV 4:2:0
InputHeaderLength      = 0    # If the inputfile has a header, state it's length in byte here 
FramesToBeEncoded      = 300  # Number of frames to be coded
SourceWidth            = 176  # Image width  in Pels, must be multiple of 16
SourceHeight           = 144  # Image height in Pels, must be multiple of 16
TraceFile              = "./workspace/trace_enc.txt"
ReconFile              = "./workspace/test_rec.yuv"
OutputFile             = "./workspace/test.bit"

# ... Unchanged  ...

FrameRate               =  4  # (1: 24000/1001,2: 24,3: 25,4: 30000/1001,5: 30,6: 50,7: 60000/1001,8: 60)######

# ... Unchanged ...
```

运行编码器：

```sh
./build/bin/lencod -file config/encoder.cfg
```

![编码器输出](https://img.duanyll.com/img/6145ee20.png)

![编码器输出](https://img.duanyll.com/img/d1b67755.png)

使用 YUView 查看编码器的重建结果：

![编码器 YUView](https://img.duanyll.com/img/4c9bd2c1.png)

可以看到编码器的输出与原始视频基本一致。

调用解码器对编码后的视频进行解码：

```sh
./build/bin/ldecod config/decoder.cfg
```

![解码器输出](https://img.duanyll.com/img/868ba613.png)

![解码器 YUView](https://img.duanyll.com/img/23139526.png)

解码器解码的 YUV 视频和编码器的重建结果完全一致，说明编解码器工作正常。

## 绘制率失真曲线

使用不同的量化参数对视频进行编码，记录每次编码后的码率和 PSNR 值，绘制率失真曲线。将 I 帧，P 帧和 B 帧的 QP 全部设置为 20, 25, 30, 35, 40，分别进行编码，使用 ffmpeg 计算 PSNR：

```sh
ffmpeg -s 176x144 -i ./workspace/foreman_qcif.yuv -s 176x144 -i ./workspace/test_rec.yuv -filter_complex psnr -f null -
```

![ffmpeg 输出](https://img.duanyll.com/img/092a0e42.png)

取最后一行输出的 Average PSNR 作为视频的 PSNR 值，根据 bit 文件大小计算码率：

```python
def calculate_bitrate(bit_file, frames=300, fps=30.0):
    if not os.path.exists(bit_file):
        return None
    file_size = os.path.getsize(bit_file)  # in bytes
    duration = frames / fps  # in seconds
    bitrate = (file_size * 8) / duration  # bits per second
    return bitrate

def parse_psnr(ffmpeg_output):
    # Find the line with PSNR values
    match = re.search(r'PSNR y:([\d.]+) u:([\d.]+) v:([\d.]+) average:([\d.]+) min:([\d.]+) max:([\d.]+)', ffmpeg_output)
    if match:
        return float(match.group(4))  # Return the average PSNR
    return None
```

绘制出率失真曲线如下：

![率失真曲线](https://img.duanyll.com/img/657a065e.png)