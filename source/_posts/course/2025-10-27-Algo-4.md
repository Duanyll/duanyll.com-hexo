---
title: 算法分析与复杂度理论 - 作业 4
tags:
  - 题解
  - 算法分析
hidden: true
---

## 58. 合并区间

{% link https://leetcode.cn/problems/merge-intervals/ %}

只需要按左端点排序后，从左到右扫一次即可。

```cpp
class Solution {
  public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        std::sort(intervals.begin(), intervals.end(),
                  [](const auto& a, const auto& b) {
                      return a[0] < b[0];
                  });
        std::vector<std::vector<int>> ans;
        for (const auto& interval : intervals) {
            if (ans.empty() || ans.back()[1] < interval[0]) {
                ans.push_back(interval);
            } else {
                ans.back()[1] = std::max(ans.back()[1], interval[1]);
            }
        }
        return ans;     
    }
};
```

## 148. 排序链表

{% link https://leetcode.cn/problems/sort-list/ %}

有点意思的地方在于可以不分配新的空间来实现排序。这里使用归并排序的思路，先用快慢指针找到链表中点，然后递归排序左右两部分，最后合并两个有序链表。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
  public:
    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        // 使用快慢指针找到中点
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* prev = nullptr;
        while (fast != nullptr && fast->next != nullptr) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        // 切断链表
        prev->next = nullptr;

        ListNode* left = sortList(head);
        ListNode* right = sortList(slow);

        // 合并两个有序链表
        ListNode dummy;
        ListNode* tail = &dummy;
        while (left != nullptr && right != nullptr) {
            if (left->val < right->val) {
                tail->next = left;
                left = left->next;
            } else {
                tail->next = right;
                right = right->next;
            }
            tail = tail->next;
        }
        if (left != nullptr) {
            tail->next = left;
        } else {
            tail->next = right;
        }
        return dummy.next;
    }
};
```

## 274. H 指数

{% link https://leetcode.cn/problems/h-index/ %}

排序后二分查找。

```cpp
class Solution {
public:
    int hIndex(vector<int>& citations) {
        std::sort(citations.begin(), citations.end());
        int n = citations.size();
        int left = 0, right = n - 1;
        int ans = 0;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (citations[mid] >= n - mid) {
                ans = n - mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;     
    }
};
```