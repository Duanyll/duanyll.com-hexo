---
title: 算法分析与复杂度理论 - 作业 1
tags:
  - 题解
  - 算法分析
hidden: true
---

![提交记录](https://img.duanyll.com/img/e7dfd19a.png)

## 1. 两数之和

{% link https://leetcode.cn/problems/two-sum/ %}

只需要扫一遍，确认需要的数是否存在，并把新扫到的数放入哈希表中，`std::unordered_map` 实现即可，使用平衡树 `std::map` 也可以过，浪费一个 $\log$ 的复杂度。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> loc;
        for (int i = 0; i < nums.size(); i++) {
            auto it = loc.find(target - nums[i]);
            if (it != loc.end()) {
                return { it->second, i };
            }
            loc.emplace(nums[i], i);
        }
        return {};
    }
};
```

## 69. x 的平方根

{% link https://leetcode.cn/problems/sqrtx/ %}

不允许使用内置指数函数和算符？那用 CPU 内置的。使用 SSE 指令集的 `sqrtsd` 指令可以在 $O(1)$ 时间内计算出一个双精度浮点数的平方根，然后向下取整即可，只需要 18 个 CPU 周期。

```cpp
#include <emmintrin.h>

class Solution {
public:
    int mySqrt(int x) {
        double input = x;
        __m128d a = _mm_setzero_pd();       // 高 64 位无关，置零
        __m128d b = _mm_set_sd(input);      // 设置低 64 位为输入值
        __m128d result = _mm_sqrt_sd(a, b); // 计算平方根

        double output;
        _mm_store_sd(&output, result);      // 提取低 64 位结果

        return output;
    }
};
```

真做可以考虑牛顿迭代法。

$$
x_{n+1} = \frac{x_n + \frac{S}{x_n}}{2}
$$

```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) return 0;
        double last = 0;
        double curr = 1;
        for (int i = 0; i < 20; i++) {
            last = curr;
            curr = (curr + x / curr) / 2;
        }
        return (int)curr;
    }
};
```

## 70. 爬楼梯

{% link https://leetcode.cn/problems/climbing-stairs/ %}

注意到 $1 \leq n \leq 45$, 所以我们直接打表

```cpp
class Solution {
public:
    int climbStairs(int n) {
        const int ans[] = {
            1,         1,         2,          3,          5,         8,
            13,        21,        34,         55,         89,        144,
            233,       377,       610,        987,        1597,      2584,
            4181,      6765,      10946,      17711,      28657,     46368,
            75025,     121393,    196418,     317811,     514229,    832040,
            1346269,   2178309,   3524578,    5702887,    9227465,   14930352,
            24157817,  39088169,  63245986,   102334155,  165580141, 267914296,
            433494437, 701408733, 1134903170, 1836311903};
        return ans[n];
    }
};
```

打表生成

```python
ans = [0, 1]
for _ in range(2, 46):
    ans.append(ans[-1] + ans[-2])
ans
```
